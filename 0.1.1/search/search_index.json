{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"EMMOntoPy \u00b6 Python API for the Elemental Multiperspective Material Ontology ( EMMO ). Note : EMMOntoPy is a continuation of the EMMO-python project and the associated emmo Python package. To see the legacy versions go to PyPI . This package is based on Owlready2 and provides an intuitive representation of EMMO in Python. It is available on GitHub and on PyPI under the open source BSD 3-Clause license . The Elemental Multiperspective Material Ontology (EMMO) is an ongoing effort to create an ontology that takes into account fundamental concepts of physics, chemistry and materials science and is designed to pave the road for semantic interoperability. The aim of EMMO is to be generic and provide a common ground for describing materials, models and data that can be adapted by all domains. EMMO is formulated using OWL. EMMOntoPy is a Python API for using EMMO to solving real problems. By using the excellent Python package Owlready2 , EMMOntoPy provides a natural representation of EMMO in Python. On top of that EMMOntoPy provides: Access by label (as well as by names, important since class and property names in EMMO are based on UUIDs). Test suite for EMMO-based ontologies. Generation of graphs. Generation of documentation. Command-line tools: emmocheck : Checks an ontology against EMMO conventions. ontoversion : Prints ontology version number. ontograph : Vertasile tool for visualising (parts of) an ontology. ontodoc : Documents an ontology. ontoconvert : Converts between ontology formats. Some examples of what you can do with EMMOntoPy includes: Access and query RDF-based ontologies from your application. This includes several different flavors of RDF (OWL, Turtle ( ttl ) , and more). Access and query EMMO-based ontologies from your application. Extend EMMO with new domain or application ontologies. This can be done both statically with easy readable Python code or dynamically within your application. Generate graphs and documentation of your ontologies. EMMOntoPy includes ontodoc : A dedicated command line tool for this. You find it in the tools/ sub directory. Check that an EMMO-based domain or application ontology adhere to the conventions of EMMO. Interactively explore an ontology in any Python interpreter, e.g., IPython . Tab-completion makes exploration easy and fast. Below is an example of an IPython session where we check the relations of Matter in EMMO utilizing the emmopy.get_emmo function: In [ 1 ]: from emmopy import get_emmo In [ 2 ]: emmo = get_emmo () In [ 3 ]: emmo . Matter Out [ 3 ]: physicalistic . Matter In [ 4 ]: emmo . Matter . is_a Out [ 4 ]: [ physicalistic . Physicalistic , physical . Physical , mereotopology . hasPart . some ( physicalistic . Massive ), physical . hasTemporalPart . only ( physicalistic . Matter )] Documentation and examples \u00b6 The Owlready2 documentation is a good starting point. The EMMOntoPy package also has its own dedicated documentation . This includes a few examples and demos: demo/vertical shows an example of how EMMO may be used to achieve vertical interoperability. The file define-ontology.py provides a good example for how an EMMO-based application ontology can be defined in Python. demo/horizontal shows an example of how EMMO may be used to achieve horizontal interoperability. This demo also shows how you can use EMMOntoPy to represent your ontology with the low-level metadata framework DLite . In addition to achieve interoperability, as shown in the demo, DLite also allow you to automatically generate C or Fortran code base on your ontology. examples/emmodoc shows how the documentation of EMMO is generated using the ontodoc tool. Installation \u00b6 Install with pip install EMMOntoPy Required Dependencies \u00b6 Python 3.6 or later. Owlready2 v0.23 or later. Optional Dependencies \u00b6 Graphviz : Needed for graph generation. With support for generation pdf, png and svg figures for tests and generation of documentation automatically ( ontodoc ). pandoc : Only used for generated documentation from markdown to nicely formatted html or pdf. Tested with v2.1.2. pdfLaTeX or XeLaTeX and the upgreek LaTeX package (included in texlive-was on RetHat-based distributions and texlive-latex-extra on Ubuntu) for generation of pdf documentation. If your ontology contains exotic unicode characters, we recommend XeLaTeX. Java. Needed for reasoning. Optional Python packages: graphviz : Generation of documentation and graphs. PyYAML : Required for generating documentation with pandoc. blessings : Clean output for emmocheck . Pygments : Coloured output for emmocheck . rdflib : Required for ontoversion -tool. semver : Required for ontoversion -tool. pydot : Used for generating graphs. Will be deprecated. See docker-instructions.md for how to build a docker image. Known issues \u00b6 Invalid serialising to turtle: Due to rdflib issue #1043 ontoconvert may produce invalid turtle output (if your ontology contains real literals using scientific notation without a dot in the mantissa). This issue was fixed after the release of rdflib 5.0.0. Hence, install the latest rdflib from PyPI ( pip install --upgrade rdflib ) or directly from the source code repository: GitHub if you need to serialise to turtle. Attributions and credits \u00b6 EMMOntoPy is maintained by EMMC-ASBL . It has mainly been developed by SINTEF , specifically: Jesper Friis ( jesper-friis ) Francesca L. Bleken ( francescalb ) Casper W. Andersen ( CasperWA ) Bj\u00f8rn Tore L\u00f8vfall ( lovfall ) Contributing projects \u00b6 EMMC-CSA ; Grant Agreement No: 723867 MarketPlace ; Grant Agreement No: 760173 OntoTrans ; Grant Agreement No: 862136 BIG-MAP ; Grant Agreement No: 957189 OpenModel ; Grant Agreement No: 953167","title":"Home"},{"location":"#emmontopy","text":"Python API for the Elemental Multiperspective Material Ontology ( EMMO ). Note : EMMOntoPy is a continuation of the EMMO-python project and the associated emmo Python package. To see the legacy versions go to PyPI . This package is based on Owlready2 and provides an intuitive representation of EMMO in Python. It is available on GitHub and on PyPI under the open source BSD 3-Clause license . The Elemental Multiperspective Material Ontology (EMMO) is an ongoing effort to create an ontology that takes into account fundamental concepts of physics, chemistry and materials science and is designed to pave the road for semantic interoperability. The aim of EMMO is to be generic and provide a common ground for describing materials, models and data that can be adapted by all domains. EMMO is formulated using OWL. EMMOntoPy is a Python API for using EMMO to solving real problems. By using the excellent Python package Owlready2 , EMMOntoPy provides a natural representation of EMMO in Python. On top of that EMMOntoPy provides: Access by label (as well as by names, important since class and property names in EMMO are based on UUIDs). Test suite for EMMO-based ontologies. Generation of graphs. Generation of documentation. Command-line tools: emmocheck : Checks an ontology against EMMO conventions. ontoversion : Prints ontology version number. ontograph : Vertasile tool for visualising (parts of) an ontology. ontodoc : Documents an ontology. ontoconvert : Converts between ontology formats. Some examples of what you can do with EMMOntoPy includes: Access and query RDF-based ontologies from your application. This includes several different flavors of RDF (OWL, Turtle ( ttl ) , and more). Access and query EMMO-based ontologies from your application. Extend EMMO with new domain or application ontologies. This can be done both statically with easy readable Python code or dynamically within your application. Generate graphs and documentation of your ontologies. EMMOntoPy includes ontodoc : A dedicated command line tool for this. You find it in the tools/ sub directory. Check that an EMMO-based domain or application ontology adhere to the conventions of EMMO. Interactively explore an ontology in any Python interpreter, e.g., IPython . Tab-completion makes exploration easy and fast. Below is an example of an IPython session where we check the relations of Matter in EMMO utilizing the emmopy.get_emmo function: In [ 1 ]: from emmopy import get_emmo In [ 2 ]: emmo = get_emmo () In [ 3 ]: emmo . Matter Out [ 3 ]: physicalistic . Matter In [ 4 ]: emmo . Matter . is_a Out [ 4 ]: [ physicalistic . Physicalistic , physical . Physical , mereotopology . hasPart . some ( physicalistic . Massive ), physical . hasTemporalPart . only ( physicalistic . Matter )]","title":"EMMOntoPy"},{"location":"#documentation-and-examples","text":"The Owlready2 documentation is a good starting point. The EMMOntoPy package also has its own dedicated documentation . This includes a few examples and demos: demo/vertical shows an example of how EMMO may be used to achieve vertical interoperability. The file define-ontology.py provides a good example for how an EMMO-based application ontology can be defined in Python. demo/horizontal shows an example of how EMMO may be used to achieve horizontal interoperability. This demo also shows how you can use EMMOntoPy to represent your ontology with the low-level metadata framework DLite . In addition to achieve interoperability, as shown in the demo, DLite also allow you to automatically generate C or Fortran code base on your ontology. examples/emmodoc shows how the documentation of EMMO is generated using the ontodoc tool.","title":"Documentation and examples"},{"location":"#installation","text":"Install with pip install EMMOntoPy","title":"Installation"},{"location":"#required-dependencies","text":"Python 3.6 or later. Owlready2 v0.23 or later.","title":"Required Dependencies"},{"location":"#optional-dependencies","text":"Graphviz : Needed for graph generation. With support for generation pdf, png and svg figures for tests and generation of documentation automatically ( ontodoc ). pandoc : Only used for generated documentation from markdown to nicely formatted html or pdf. Tested with v2.1.2. pdfLaTeX or XeLaTeX and the upgreek LaTeX package (included in texlive-was on RetHat-based distributions and texlive-latex-extra on Ubuntu) for generation of pdf documentation. If your ontology contains exotic unicode characters, we recommend XeLaTeX. Java. Needed for reasoning. Optional Python packages: graphviz : Generation of documentation and graphs. PyYAML : Required for generating documentation with pandoc. blessings : Clean output for emmocheck . Pygments : Coloured output for emmocheck . rdflib : Required for ontoversion -tool. semver : Required for ontoversion -tool. pydot : Used for generating graphs. Will be deprecated. See docker-instructions.md for how to build a docker image.","title":"Optional Dependencies"},{"location":"#known-issues","text":"Invalid serialising to turtle: Due to rdflib issue #1043 ontoconvert may produce invalid turtle output (if your ontology contains real literals using scientific notation without a dot in the mantissa). This issue was fixed after the release of rdflib 5.0.0. Hence, install the latest rdflib from PyPI ( pip install --upgrade rdflib ) or directly from the source code repository: GitHub if you need to serialise to turtle.","title":"Known issues"},{"location":"#attributions-and-credits","text":"EMMOntoPy is maintained by EMMC-ASBL . It has mainly been developed by SINTEF , specifically: Jesper Friis ( jesper-friis ) Francesca L. Bleken ( francescalb ) Casper W. Andersen ( CasperWA ) Bj\u00f8rn Tore L\u00f8vfall ( lovfall )","title":"Attributions and credits"},{"location":"#contributing-projects","text":"EMMC-CSA ; Grant Agreement No: 723867 MarketPlace ; Grant Agreement No: 760173 OntoTrans ; Grant Agreement No: 862136 BIG-MAP ; Grant Agreement No: 957189 OpenModel ; Grant Agreement No: 953167","title":"Contributing projects"},{"location":"CHANGELOG/","text":"Changelog \u00b6 v0.1.1 (2021-10-27) \u00b6 Full Changelog v0.1.0 (2021-10-27) \u00b6 Full Changelog Implemented enhancements: \"Warning\" Importing from collections #236 Fixed bugs: Loading ontologies that do not import skos fails #261 Fix documentation build warnings #250 Fix images in documentation #233 Circular reference from Owlready2 #210 Closed issues: Write up transfer from EMMOpython to EMMOntoPy i README.md #267 Add test to emmocheck for upcoming EMMO #257 Add packaging as dependency in requirements #255 Add CI check for building documentation #244 Add OpenModel as contributing project #237 Update public documentation to new framework #234 Automate documentation releases #232 Update name of EMMO to Elemental Multiperspective Material Ontology #230 Tidy up unittests #220 Remove importability of sub- factpluspluswrapper folders #213 Make function that automatically loads emmo #209 Require rdflib>5.0.0? #206 change package name #205 test_catalog fails because seraching for .owl in emmo/master #203 Consider using mike for versioned documentation #197 Add a test that checks that loading of non-EMMO based ontologies work - e.g. do not require skos:prefLabel #196 Setup Materials for MkDocs framework #195 Clean up demo, examples and docs #193 Formalize review process with checklists #190 funksjon ontology.add_class(label, parent) #183 Merged pull requests: Reset version to 0.1.0 #271 ( CasperWA ) Update README with PyPI and deprecation msgs #270 ( CasperWA ) Added option: EMMObased = False in ontology.load() #262 ( francescalb ) Update pyyaml requirement from \\<6,>=5.4.1 to >=5.4.1,\\<7 #260 ( dependabot[bot] ) Update owlready2 requirement from !=0.32,!=0.34,\\<0.35,>=0.28 to >=0.28,!=0.32,!=0.34,\\<0.36 #259 ( dependabot[bot] ) Added new test \"test_physical_quantity_dimension\" #258 ( jesper-friis ) Add packaging to list of requirements #256 ( CasperWA ) Fix MkDocs build warnings and CI job #254 ( CasperWA ) Update mkdocstrings requirement from ~=0.16.1 to ~=0.16.2 #253 ( dependabot[bot] ) Update dependencies #252 ( CasperWA ) Add OpenModel contributing project #247 ( francescalb ) Automate documentation releases #242 ( CasperWA ) Import from collections.abc when possible #240 ( CasperWA ) Ensure all produced files from tests are in a temp dir #239 ( CasperWA ) Changed EMMO to be acronym for Elemental Multiperspective Material Ontology #238 ( francescalb ) Use width in img HTML #235 ( CasperWA ) Update graphviz requirement from \\<0.17,>=0.16 to >=0.16,\\<0.18 #229 ( dependabot[bot] ) Added function to load the emmo (the ontology) directly #226 ( francescalb ) Created pull request template #225 ( francescalb ) Setup new documentation framework #222 ( CasperWA ) Remove __init__.py files for FaCT++ wrapper (again) #221 ( CasperWA ) Unskip test as #210 has been resolved #218 ( CasperWA ) Remove sub-fact++ modules importability #217 ( CasperWA ) Update requirements #216 ( CasperWA ) Avoid using Owlready2 v0.34 #211 ( CasperWA ) Update package names #208 ( CasperWA ) Added function new_entitiy to ontology #207 ( francescalb ) ttl standard for emmo #204 ( francescalb ) Added choice for specifying namespace in get_by_label #202 ( francescalb ) v1.0.1b (2021-07-01) \u00b6 Full Changelog Closed issues: Correct updating of catalog in ontology.load #188 Merged pull requests: Update version to 1.0.1 #189 ( francescalb ) v1.0.1 (2021-07-01) \u00b6 Full Changelog Implemented enhancements: Specify version ranges for dependencies #155 Fixed bugs: Windows paths are not handled properly #147 Closed issues: Failing tests when lodaing battinfo #185 Fix dependatbot to 'wider' #182 Change to get_label instead of asstring in ontograph, emmodoc, ontodoc, be careful #158 licence does not work with metadata #157 ontograph with several roots fails #153 fix redudant getlabel, get_preferred_label, get_label #152 add --no-catalog and default as in emmocheck for ontograph #150 make tests for checking upgrade of Owlready2 #137 Add periodic_table to examples #130 Add support for simple property-based ontology annotations like dcterms:license #129 Update documentation of tools re reasoner #123 Ontograph: Include multiple parents/inheritance #86 Merged pull requests: Fixed updating of catalog in load #187 ( francescalb ) Temporarily commented out loading ontologies with error in redirecting link on emmo.info #186 ( francescalb ) Changed dependabot to widen #181 ( francescalb ) Changed requirements to greater than #179 ( francescalb ) Owread2-0.32 not accepted die to error in owlready2 triplelite #178 ( francescalb ) Fixed import of defaultstyle in ontograph-tool #177 ( francescalb ) Update pyyaml requirement from ~=5.4.0 to ~=5.4.1 #171 ( dependabot[bot] ) Updated pygments req to at least 2.7.4 because of high seq alert #168 ( francescalb ) Owlready requirement >0.28 #167 ( francescalb ) Bump actions/setup-python from 2 to 2.2.2 #166 ( dependabot[bot] ) Bump actions/checkout from 2 to 2.3.4 #165 ( dependabot[bot] ) Bump owlready2 from 0.30 to 0.31 #164 ( dependabot[bot] ) WIP: Ipycytoscape #163 ( francescalb ) Made it possible to load other ontologies like foaf #162 ( jesper-friis ) Added get_label instead of asstring #160 ( francescalb ) Added write_catalog() #159 ( jesper-friis ) Periodic table example #156 ( francescalb ) Make one get label #154 ( francescalb ) Issue150 ontograph cannotload emmo inferred directly #151 ( francescalb ) Added Fact++ in tools documentation #149 ( francescalb ) Bump owlready2 from 0.29 to 0.30 #148 ( dependabot[bot] ) Improved issue reporting in emmocheck #146 ( jesper-friis ) v1.0.0 (2021-03-25) \u00b6 Full Changelog Closed issues: Use rdflib in Ontology.save() to support more file formats #143 Tool for publishing domain ontologies #140 Merged pull requests: Save to turtle and ontology annotations (via the metadata attribute) #144 ( jesper-friis ) Corrected configuration of exceptions for test_class_label test. #142 ( jesper-friis ) v1.0.0-alpha-30 (2021-03-18) \u00b6 Full Changelog Merged pull requests: Load ontology #141 ( jesper-friis ) v1.0.0-alpha-29 (2021-03-16) \u00b6 Full Changelog Implemented enhancements: Add Wu&Palmer measure #134 Closed issues: Convert-imported update in utils #138 Merged pull requests: Fixed reading xml as 'rdfxml' #139 ( francescalb ) Bump owlready2 from 0.28 to 0.29 #136 ( dependabot[bot] ) Added wu_palmer_measure for semantic similarity #135 ( francescalb ) v1.0.0-alpha-28 (2021-03-09) \u00b6 Full Changelog Closed issues: Also use the catalog file to map web URLs, not only local files. #109 Check Error with Owlready2-0.26 #81 Merged pull requests: Version updated for rel of v0.28 #133 ( francescalb ) Bump owlready2 from 0.27 to 0.28 #132 ( dependabot[bot] ) Load ontology #131 ( jesper-friis ) Optimised label lookup in ontology and dir listing. It is now much faster #127 ( jesper-friis ) Use catalog by default #126 ( jesper-friis ) v1.0.0-alpha-27 (2021-02-27) \u00b6 Full Changelog Merged pull requests: Ontodoc #125 ( jesper-friis ) v1.0.0-alpha-26 (2021-02-26) \u00b6 Full Changelog Closed issues: Make fact++ reasoner available and default in tools #122 Use PyPI token in publish workflow #118 Update publish workflow #115 do something #108 Merged pull requests: Added functionality to document domain ontologies #124 ( jesper-friis ) Bump owlready2 from 0.25 to 0.27 #121 ( dependabot[bot] ) Made ontoconvert and ontograph tools executable in linux #120 ( jesper-friis ) Update CI #119 ( CasperWA ) Update publish workflow + add dependabot #116 ( CasperWA ) v1.0.0-alpha-25 (2021-01-17) \u00b6 Full Changelog Closed issues: Update Dockerfile to install correct pandoc #99 Correct turtle serialisation #97 Merged pull requests: Update emmocheck exceptions #113 ( jesper-friis ) Fix recursion in graph #112 ( jesper-friis ) Avoid unnessesary/infinite recursion in get_imported_ontologies() #111 ( jesper-friis ) Break recursion error in get_by_label() #110 ( jesper-friis ) Updated the Ontology.sync_attributes() method. #107 ( jesper-friis ) Updated pandoc req in Dockerfile #106 ( francescalb ) v1.0.0-alpha-24 (2021-01-04) \u00b6 Full Changelog Merged pull requests: Bumped version number up to 1.0.0-alpha-24 #105 ( jesper-friis ) v1.0.0-alpha-23 (2021-01-04) \u00b6 Full Changelog Closed issues: Fix loading imported ttl from web such that emmocheck works for crystallography.ttl #98 Add reasoning with FaCT++ #95 Correctly load ontologies like crystallography that imports both local and online sub-ontologies #91 Fix flake8 errors #88 Remove the .ttl namespace when loading domain-crystallography in EMMO-python #83 Add option of documenting imported ontologies in ontodoc and ontograph #82 Emmocheck fails if Physicaluantities and MeaurementsUnits are not imported from emmo. Make sure that it does not fail if whole of EMMO is not imported. #80 Ontograph: Make default root #79 Ontodoc: PDF is not generated, produces error. #76 AttributeError from ontodoc #70 Import emmo .ttl from emmo-repo.github.io #69 Unable to use the vertical interoperability demo .py files #66 Merged pull requests: Release 1.0.0-alpha-23 #104 ( jesper-friis ) Allow to load turtle ontologies without catalog file. #102 ( jesper-friis ) Bump junit from 4.11 to 4.13.1 in /emmo/factpluspluswrapper/java #101 ( dependabot[bot] ) Updated README file #100 ( jesper-friis ) Changed the sync_reasoner() method to use FaCT++ as the default reasoner #94 ( jesper-friis ) Add reasoning #93 ( jesper-friis ) Improve load ontologies #92 ( jesper-friis ) Remove the '.ttl' in namespace names by monkey patching owlready2.Namespace #90 ( jesper-friis ) Fix flake8 warnings #89 ( jesper-friis ) Ontodoc pdf #87 ( jesper-friis ) Automatically find roots in ontograph #85 ( francescalb ) Automatic import of ttl from GitHub emmo-repo.io #84 ( francescalb ) Fixes needed for access ontologies #77 ( jesper-friis ) v1.0.0-alpha-22 (2020-12-21) \u00b6 Full Changelog Merged pull requests: Loading ttl both locally and importing from iri #75 ( francescalb ) Added sync_python_names() and corrected handling of individuals in sync_attributes() #73 ( jesper-friis ) Add preflabel to individuals declared in python #72 ( jesper-friis ) v1.0.0-alpha-21b (2020-12-13) \u00b6 Full Changelog Merged pull requests: Fix bug introduced in ontoconvert #71 ( jesper-friis ) v1.0.0-alpha-21 (2020-12-11) \u00b6 Full Changelog Merged pull requests: Use rdflib to load non-supported formats. #68 ( jesper-friis ) Added a quick fix for vertical demo. #67 ( jesper-friis ) Updated emmocheck to new 1.0.0-beta. Old version should still work. #65 ( jesper-friis ) Added ontoconvert tool #64 ( jesper-friis ) Improved error messages for classes that doesn't define prefLabel #63 ( jesper-friis ) v1.0.0-alpha-20b (2020-11-04) \u00b6 Full Changelog Merged pull requests: Version1.0.0 alpha20 #62 ( francescalb ) v1.0.0-alpha-20 (2020-11-04) \u00b6 Full Changelog Merged pull requests: Improve support for imported ontologies #61 ( jesper-friis ) v1.0.0-alpha-19 (2020-11-02) \u00b6 Full Changelog Merged pull requests: Added --ignore-namespace to emmocheck #60 ( francescalb ) v1.0.0-alpha-18 (2020-10-29) \u00b6 Full Changelog Merged pull requests: Bumped up version number to 1.0.0-alpha-18 #59 ( jesper-friis ) Added option url_from_catalog to ontology.load() #58 ( jesper-friis ) Added get_preferred_label() method to classes, properties and individuals #57 ( jesper-friis ) Correct default IRI to inferred ontology #56 ( jesper-friis ) v1.0.0-alpha-17 (2020-10-21) \u00b6 Full Changelog Merged pull requests: Added materials.EngineeredMaterial to namespace exception in emmocheck #55 ( francescalb ) v1.0.0-alpha-16 (2020-10-20) \u00b6 Full Changelog Closed issues: Include all annotations in .get_annotations() #50 Merged pull requests: Update to v1.0.0-alpha-16 for new release #54 ( francescalb ) Update dimensionality checks #53 ( jesper-friis ) Updated to say that pypi realese is automatic in docs #52 ( francescalb ) v1.0.0-alpha-15 (2020-09-25) \u00b6 Full Changelog Merged pull requests: Added all labels in get_class_annotations in emmo/patch.py including #51 ( francescalb ) Support use of skos:prefLabel instead of rdfs:label #49 ( jesper-friis ) v1.0.0-alpha-14 #48 ( jesper-friis ) Fix emmocheck to not fail upon use of dcterms and skos #47 ( jesper-friis ) v1.0.0-alpha-13 (2020-09-19) \u00b6 Full Changelog Closed issues: Not immediately installable with pip #45 Merged pull requests: Fix setup #46 ( jesper-friis ) Make emmo package pip installable in fresh env #44 ( CasperWA ) Update emmodoc to latest version of emmo-alpha2 #43 ( jesper-friis ) Ensure that emmocheck exit with non-zero return value if a test is faing #42 ( jesper-friis ) Installed missing dependencies in pythonpublish deployment workflow #41 ( jesper-friis ) v1.0.0-alpha-11 (2020-08-12) \u00b6 Full Changelog Merged pull requests: Add skip option to emmocheck #40 ( jesper-friis ) v1.0.0-alpha-10 (2020-04-27) \u00b6 Full Changelog Merged pull requests: Added exceptions to emmocheck \"test_number_of_labels\" #39 ( jesper-friis ) v1.0.0-alpha-9 (2020-04-13) \u00b6 Full Changelog Closed issues: Enhance ontology.sync_attributes() to also update class names #10 Add support for the FaCT++ reasoner #9 Merged pull requests: Set new release version 1.0.0-alpha-9 #38 ( francescalb ) Added get_version() and set_version() methods to emmo.Ontology. #37 ( jesper-friis ) Updated example in README file to current version of EMMO. #36 ( jesper-friis ) Update tools #35 ( jesper-friis ) Updated simplifed demo_vertical in compliance with EMMO-1.0.0alpha2 as of 202\u2026 #34 ( francescalb ) Fixed PyPI badge in README #33 ( jesper-friis ) Update emmocheck #32 ( jesper-friis ) Sync attributes #31 ( jesper-friis ) Cleanup ci workflow #28 ( jesper-friis ) Added ontoversion tool #27 ( jesper-friis ) Update emmodoc #25 ( jesper-friis ) v1.0.0-alpha-8 (2020-03-22) \u00b6 Full Changelog Merged pull requests: 1.0.0 alpha 8 #30 ( jesper-friis ) Updated requirements such that \"pip install EMMO\" works #24 ( jesper-friis ) v1.0.0-alpha-5 (2020-03-18) \u00b6 Full Changelog Implemented enhancements: Make EMMO-python available on pypi (installable with pip) #7 Merged pull requests: Bumbed up version to 1.0.0-alpha-5 #23 ( jesper-friis ) Emmocheck #22 ( jesper-friis ) Reworked the generation of graphs - using the graphviz Python package #21 ( jesper-friis ) 1.0.0 #19 ( jesper-friis ) v1.0.0-alpha-3 (2020-02-16) \u00b6 Full Changelog v1.0.0-alpha-2 (2020-01-11) \u00b6 Full Changelog v1.0.0-alpha-1 (2020-01-11) \u00b6 Full Changelog Closed issues: Missing https://emmc.info/emmo-inferred #16 setup.py #15 Fix emmodoc #6 v1.0.0-alpha (2020-01-08) \u00b6 Full Changelog Closed issues: Update the user case ontology #3 Merged pull requests: Fixed a typo in the title #14 ( blokhin ) Fixed #5 - homogenised call to reasoner #13 ( francescalb ) v0.9.9 (2019-07-14) \u00b6 Full Changelog Closed issues: Homogenise call to reasoner in emmo.Ontology.sync_reasoner() #5 Merged pull requests: #3 update usercase ontology #12 ( jesper-friis ) Fixed 3 #8 ( jesper-friis ) Dockerdevel #2 ( francescalb ) Fix by lukas #1 ( jesper-friis ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#v011-2021-10-27","text":"Full Changelog","title":"v0.1.1 (2021-10-27)"},{"location":"CHANGELOG/#v010-2021-10-27","text":"Full Changelog Implemented enhancements: \"Warning\" Importing from collections #236 Fixed bugs: Loading ontologies that do not import skos fails #261 Fix documentation build warnings #250 Fix images in documentation #233 Circular reference from Owlready2 #210 Closed issues: Write up transfer from EMMOpython to EMMOntoPy i README.md #267 Add test to emmocheck for upcoming EMMO #257 Add packaging as dependency in requirements #255 Add CI check for building documentation #244 Add OpenModel as contributing project #237 Update public documentation to new framework #234 Automate documentation releases #232 Update name of EMMO to Elemental Multiperspective Material Ontology #230 Tidy up unittests #220 Remove importability of sub- factpluspluswrapper folders #213 Make function that automatically loads emmo #209 Require rdflib>5.0.0? #206 change package name #205 test_catalog fails because seraching for .owl in emmo/master #203 Consider using mike for versioned documentation #197 Add a test that checks that loading of non-EMMO based ontologies work - e.g. do not require skos:prefLabel #196 Setup Materials for MkDocs framework #195 Clean up demo, examples and docs #193 Formalize review process with checklists #190 funksjon ontology.add_class(label, parent) #183 Merged pull requests: Reset version to 0.1.0 #271 ( CasperWA ) Update README with PyPI and deprecation msgs #270 ( CasperWA ) Added option: EMMObased = False in ontology.load() #262 ( francescalb ) Update pyyaml requirement from \\<6,>=5.4.1 to >=5.4.1,\\<7 #260 ( dependabot[bot] ) Update owlready2 requirement from !=0.32,!=0.34,\\<0.35,>=0.28 to >=0.28,!=0.32,!=0.34,\\<0.36 #259 ( dependabot[bot] ) Added new test \"test_physical_quantity_dimension\" #258 ( jesper-friis ) Add packaging to list of requirements #256 ( CasperWA ) Fix MkDocs build warnings and CI job #254 ( CasperWA ) Update mkdocstrings requirement from ~=0.16.1 to ~=0.16.2 #253 ( dependabot[bot] ) Update dependencies #252 ( CasperWA ) Add OpenModel contributing project #247 ( francescalb ) Automate documentation releases #242 ( CasperWA ) Import from collections.abc when possible #240 ( CasperWA ) Ensure all produced files from tests are in a temp dir #239 ( CasperWA ) Changed EMMO to be acronym for Elemental Multiperspective Material Ontology #238 ( francescalb ) Use width in img HTML #235 ( CasperWA ) Update graphviz requirement from \\<0.17,>=0.16 to >=0.16,\\<0.18 #229 ( dependabot[bot] ) Added function to load the emmo (the ontology) directly #226 ( francescalb ) Created pull request template #225 ( francescalb ) Setup new documentation framework #222 ( CasperWA ) Remove __init__.py files for FaCT++ wrapper (again) #221 ( CasperWA ) Unskip test as #210 has been resolved #218 ( CasperWA ) Remove sub-fact++ modules importability #217 ( CasperWA ) Update requirements #216 ( CasperWA ) Avoid using Owlready2 v0.34 #211 ( CasperWA ) Update package names #208 ( CasperWA ) Added function new_entitiy to ontology #207 ( francescalb ) ttl standard for emmo #204 ( francescalb ) Added choice for specifying namespace in get_by_label #202 ( francescalb )","title":"v0.1.0 (2021-10-27)"},{"location":"CHANGELOG/#v101b-2021-07-01","text":"Full Changelog Closed issues: Correct updating of catalog in ontology.load #188 Merged pull requests: Update version to 1.0.1 #189 ( francescalb )","title":"v1.0.1b (2021-07-01)"},{"location":"CHANGELOG/#v101-2021-07-01","text":"Full Changelog Implemented enhancements: Specify version ranges for dependencies #155 Fixed bugs: Windows paths are not handled properly #147 Closed issues: Failing tests when lodaing battinfo #185 Fix dependatbot to 'wider' #182 Change to get_label instead of asstring in ontograph, emmodoc, ontodoc, be careful #158 licence does not work with metadata #157 ontograph with several roots fails #153 fix redudant getlabel, get_preferred_label, get_label #152 add --no-catalog and default as in emmocheck for ontograph #150 make tests for checking upgrade of Owlready2 #137 Add periodic_table to examples #130 Add support for simple property-based ontology annotations like dcterms:license #129 Update documentation of tools re reasoner #123 Ontograph: Include multiple parents/inheritance #86 Merged pull requests: Fixed updating of catalog in load #187 ( francescalb ) Temporarily commented out loading ontologies with error in redirecting link on emmo.info #186 ( francescalb ) Changed dependabot to widen #181 ( francescalb ) Changed requirements to greater than #179 ( francescalb ) Owread2-0.32 not accepted die to error in owlready2 triplelite #178 ( francescalb ) Fixed import of defaultstyle in ontograph-tool #177 ( francescalb ) Update pyyaml requirement from ~=5.4.0 to ~=5.4.1 #171 ( dependabot[bot] ) Updated pygments req to at least 2.7.4 because of high seq alert #168 ( francescalb ) Owlready requirement >0.28 #167 ( francescalb ) Bump actions/setup-python from 2 to 2.2.2 #166 ( dependabot[bot] ) Bump actions/checkout from 2 to 2.3.4 #165 ( dependabot[bot] ) Bump owlready2 from 0.30 to 0.31 #164 ( dependabot[bot] ) WIP: Ipycytoscape #163 ( francescalb ) Made it possible to load other ontologies like foaf #162 ( jesper-friis ) Added get_label instead of asstring #160 ( francescalb ) Added write_catalog() #159 ( jesper-friis ) Periodic table example #156 ( francescalb ) Make one get label #154 ( francescalb ) Issue150 ontograph cannotload emmo inferred directly #151 ( francescalb ) Added Fact++ in tools documentation #149 ( francescalb ) Bump owlready2 from 0.29 to 0.30 #148 ( dependabot[bot] ) Improved issue reporting in emmocheck #146 ( jesper-friis )","title":"v1.0.1 (2021-07-01)"},{"location":"CHANGELOG/#v100-2021-03-25","text":"Full Changelog Closed issues: Use rdflib in Ontology.save() to support more file formats #143 Tool for publishing domain ontologies #140 Merged pull requests: Save to turtle and ontology annotations (via the metadata attribute) #144 ( jesper-friis ) Corrected configuration of exceptions for test_class_label test. #142 ( jesper-friis )","title":"v1.0.0 (2021-03-25)"},{"location":"CHANGELOG/#v100-alpha-30-2021-03-18","text":"Full Changelog Merged pull requests: Load ontology #141 ( jesper-friis )","title":"v1.0.0-alpha-30 (2021-03-18)"},{"location":"CHANGELOG/#v100-alpha-29-2021-03-16","text":"Full Changelog Implemented enhancements: Add Wu&Palmer measure #134 Closed issues: Convert-imported update in utils #138 Merged pull requests: Fixed reading xml as 'rdfxml' #139 ( francescalb ) Bump owlready2 from 0.28 to 0.29 #136 ( dependabot[bot] ) Added wu_palmer_measure for semantic similarity #135 ( francescalb )","title":"v1.0.0-alpha-29 (2021-03-16)"},{"location":"CHANGELOG/#v100-alpha-28-2021-03-09","text":"Full Changelog Closed issues: Also use the catalog file to map web URLs, not only local files. #109 Check Error with Owlready2-0.26 #81 Merged pull requests: Version updated for rel of v0.28 #133 ( francescalb ) Bump owlready2 from 0.27 to 0.28 #132 ( dependabot[bot] ) Load ontology #131 ( jesper-friis ) Optimised label lookup in ontology and dir listing. It is now much faster #127 ( jesper-friis ) Use catalog by default #126 ( jesper-friis )","title":"v1.0.0-alpha-28 (2021-03-09)"},{"location":"CHANGELOG/#v100-alpha-27-2021-02-27","text":"Full Changelog Merged pull requests: Ontodoc #125 ( jesper-friis )","title":"v1.0.0-alpha-27 (2021-02-27)"},{"location":"CHANGELOG/#v100-alpha-26-2021-02-26","text":"Full Changelog Closed issues: Make fact++ reasoner available and default in tools #122 Use PyPI token in publish workflow #118 Update publish workflow #115 do something #108 Merged pull requests: Added functionality to document domain ontologies #124 ( jesper-friis ) Bump owlready2 from 0.25 to 0.27 #121 ( dependabot[bot] ) Made ontoconvert and ontograph tools executable in linux #120 ( jesper-friis ) Update CI #119 ( CasperWA ) Update publish workflow + add dependabot #116 ( CasperWA )","title":"v1.0.0-alpha-26 (2021-02-26)"},{"location":"CHANGELOG/#v100-alpha-25-2021-01-17","text":"Full Changelog Closed issues: Update Dockerfile to install correct pandoc #99 Correct turtle serialisation #97 Merged pull requests: Update emmocheck exceptions #113 ( jesper-friis ) Fix recursion in graph #112 ( jesper-friis ) Avoid unnessesary/infinite recursion in get_imported_ontologies() #111 ( jesper-friis ) Break recursion error in get_by_label() #110 ( jesper-friis ) Updated the Ontology.sync_attributes() method. #107 ( jesper-friis ) Updated pandoc req in Dockerfile #106 ( francescalb )","title":"v1.0.0-alpha-25 (2021-01-17)"},{"location":"CHANGELOG/#v100-alpha-24-2021-01-04","text":"Full Changelog Merged pull requests: Bumped version number up to 1.0.0-alpha-24 #105 ( jesper-friis )","title":"v1.0.0-alpha-24 (2021-01-04)"},{"location":"CHANGELOG/#v100-alpha-23-2021-01-04","text":"Full Changelog Closed issues: Fix loading imported ttl from web such that emmocheck works for crystallography.ttl #98 Add reasoning with FaCT++ #95 Correctly load ontologies like crystallography that imports both local and online sub-ontologies #91 Fix flake8 errors #88 Remove the .ttl namespace when loading domain-crystallography in EMMO-python #83 Add option of documenting imported ontologies in ontodoc and ontograph #82 Emmocheck fails if Physicaluantities and MeaurementsUnits are not imported from emmo. Make sure that it does not fail if whole of EMMO is not imported. #80 Ontograph: Make default root #79 Ontodoc: PDF is not generated, produces error. #76 AttributeError from ontodoc #70 Import emmo .ttl from emmo-repo.github.io #69 Unable to use the vertical interoperability demo .py files #66 Merged pull requests: Release 1.0.0-alpha-23 #104 ( jesper-friis ) Allow to load turtle ontologies without catalog file. #102 ( jesper-friis ) Bump junit from 4.11 to 4.13.1 in /emmo/factpluspluswrapper/java #101 ( dependabot[bot] ) Updated README file #100 ( jesper-friis ) Changed the sync_reasoner() method to use FaCT++ as the default reasoner #94 ( jesper-friis ) Add reasoning #93 ( jesper-friis ) Improve load ontologies #92 ( jesper-friis ) Remove the '.ttl' in namespace names by monkey patching owlready2.Namespace #90 ( jesper-friis ) Fix flake8 warnings #89 ( jesper-friis ) Ontodoc pdf #87 ( jesper-friis ) Automatically find roots in ontograph #85 ( francescalb ) Automatic import of ttl from GitHub emmo-repo.io #84 ( francescalb ) Fixes needed for access ontologies #77 ( jesper-friis )","title":"v1.0.0-alpha-23 (2021-01-04)"},{"location":"CHANGELOG/#v100-alpha-22-2020-12-21","text":"Full Changelog Merged pull requests: Loading ttl both locally and importing from iri #75 ( francescalb ) Added sync_python_names() and corrected handling of individuals in sync_attributes() #73 ( jesper-friis ) Add preflabel to individuals declared in python #72 ( jesper-friis )","title":"v1.0.0-alpha-22 (2020-12-21)"},{"location":"CHANGELOG/#v100-alpha-21b-2020-12-13","text":"Full Changelog Merged pull requests: Fix bug introduced in ontoconvert #71 ( jesper-friis )","title":"v1.0.0-alpha-21b (2020-12-13)"},{"location":"CHANGELOG/#v100-alpha-21-2020-12-11","text":"Full Changelog Merged pull requests: Use rdflib to load non-supported formats. #68 ( jesper-friis ) Added a quick fix for vertical demo. #67 ( jesper-friis ) Updated emmocheck to new 1.0.0-beta. Old version should still work. #65 ( jesper-friis ) Added ontoconvert tool #64 ( jesper-friis ) Improved error messages for classes that doesn't define prefLabel #63 ( jesper-friis )","title":"v1.0.0-alpha-21 (2020-12-11)"},{"location":"CHANGELOG/#v100-alpha-20b-2020-11-04","text":"Full Changelog Merged pull requests: Version1.0.0 alpha20 #62 ( francescalb )","title":"v1.0.0-alpha-20b (2020-11-04)"},{"location":"CHANGELOG/#v100-alpha-20-2020-11-04","text":"Full Changelog Merged pull requests: Improve support for imported ontologies #61 ( jesper-friis )","title":"v1.0.0-alpha-20 (2020-11-04)"},{"location":"CHANGELOG/#v100-alpha-19-2020-11-02","text":"Full Changelog Merged pull requests: Added --ignore-namespace to emmocheck #60 ( francescalb )","title":"v1.0.0-alpha-19 (2020-11-02)"},{"location":"CHANGELOG/#v100-alpha-18-2020-10-29","text":"Full Changelog Merged pull requests: Bumped up version number to 1.0.0-alpha-18 #59 ( jesper-friis ) Added option url_from_catalog to ontology.load() #58 ( jesper-friis ) Added get_preferred_label() method to classes, properties and individuals #57 ( jesper-friis ) Correct default IRI to inferred ontology #56 ( jesper-friis )","title":"v1.0.0-alpha-18 (2020-10-29)"},{"location":"CHANGELOG/#v100-alpha-17-2020-10-21","text":"Full Changelog Merged pull requests: Added materials.EngineeredMaterial to namespace exception in emmocheck #55 ( francescalb )","title":"v1.0.0-alpha-17 (2020-10-21)"},{"location":"CHANGELOG/#v100-alpha-16-2020-10-20","text":"Full Changelog Closed issues: Include all annotations in .get_annotations() #50 Merged pull requests: Update to v1.0.0-alpha-16 for new release #54 ( francescalb ) Update dimensionality checks #53 ( jesper-friis ) Updated to say that pypi realese is automatic in docs #52 ( francescalb )","title":"v1.0.0-alpha-16 (2020-10-20)"},{"location":"CHANGELOG/#v100-alpha-15-2020-09-25","text":"Full Changelog Merged pull requests: Added all labels in get_class_annotations in emmo/patch.py including #51 ( francescalb ) Support use of skos:prefLabel instead of rdfs:label #49 ( jesper-friis ) v1.0.0-alpha-14 #48 ( jesper-friis ) Fix emmocheck to not fail upon use of dcterms and skos #47 ( jesper-friis )","title":"v1.0.0-alpha-15 (2020-09-25)"},{"location":"CHANGELOG/#v100-alpha-13-2020-09-19","text":"Full Changelog Closed issues: Not immediately installable with pip #45 Merged pull requests: Fix setup #46 ( jesper-friis ) Make emmo package pip installable in fresh env #44 ( CasperWA ) Update emmodoc to latest version of emmo-alpha2 #43 ( jesper-friis ) Ensure that emmocheck exit with non-zero return value if a test is faing #42 ( jesper-friis ) Installed missing dependencies in pythonpublish deployment workflow #41 ( jesper-friis )","title":"v1.0.0-alpha-13 (2020-09-19)"},{"location":"CHANGELOG/#v100-alpha-11-2020-08-12","text":"Full Changelog Merged pull requests: Add skip option to emmocheck #40 ( jesper-friis )","title":"v1.0.0-alpha-11 (2020-08-12)"},{"location":"CHANGELOG/#v100-alpha-10-2020-04-27","text":"Full Changelog Merged pull requests: Added exceptions to emmocheck \"test_number_of_labels\" #39 ( jesper-friis )","title":"v1.0.0-alpha-10 (2020-04-27)"},{"location":"CHANGELOG/#v100-alpha-9-2020-04-13","text":"Full Changelog Closed issues: Enhance ontology.sync_attributes() to also update class names #10 Add support for the FaCT++ reasoner #9 Merged pull requests: Set new release version 1.0.0-alpha-9 #38 ( francescalb ) Added get_version() and set_version() methods to emmo.Ontology. #37 ( jesper-friis ) Updated example in README file to current version of EMMO. #36 ( jesper-friis ) Update tools #35 ( jesper-friis ) Updated simplifed demo_vertical in compliance with EMMO-1.0.0alpha2 as of 202\u2026 #34 ( francescalb ) Fixed PyPI badge in README #33 ( jesper-friis ) Update emmocheck #32 ( jesper-friis ) Sync attributes #31 ( jesper-friis ) Cleanup ci workflow #28 ( jesper-friis ) Added ontoversion tool #27 ( jesper-friis ) Update emmodoc #25 ( jesper-friis )","title":"v1.0.0-alpha-9 (2020-04-13)"},{"location":"CHANGELOG/#v100-alpha-8-2020-03-22","text":"Full Changelog Merged pull requests: 1.0.0 alpha 8 #30 ( jesper-friis ) Updated requirements such that \"pip install EMMO\" works #24 ( jesper-friis )","title":"v1.0.0-alpha-8 (2020-03-22)"},{"location":"CHANGELOG/#v100-alpha-5-2020-03-18","text":"Full Changelog Implemented enhancements: Make EMMO-python available on pypi (installable with pip) #7 Merged pull requests: Bumbed up version to 1.0.0-alpha-5 #23 ( jesper-friis ) Emmocheck #22 ( jesper-friis ) Reworked the generation of graphs - using the graphviz Python package #21 ( jesper-friis ) 1.0.0 #19 ( jesper-friis )","title":"v1.0.0-alpha-5 (2020-03-18)"},{"location":"CHANGELOG/#v100-alpha-3-2020-02-16","text":"Full Changelog","title":"v1.0.0-alpha-3 (2020-02-16)"},{"location":"CHANGELOG/#v100-alpha-2-2020-01-11","text":"Full Changelog","title":"v1.0.0-alpha-2 (2020-01-11)"},{"location":"CHANGELOG/#v100-alpha-1-2020-01-11","text":"Full Changelog Closed issues: Missing https://emmc.info/emmo-inferred #16 setup.py #15 Fix emmodoc #6","title":"v1.0.0-alpha-1 (2020-01-11)"},{"location":"CHANGELOG/#v100-alpha-2020-01-08","text":"Full Changelog Closed issues: Update the user case ontology #3 Merged pull requests: Fixed a typo in the title #14 ( blokhin ) Fixed #5 - homogenised call to reasoner #13 ( francescalb )","title":"v1.0.0-alpha (2020-01-08)"},{"location":"CHANGELOG/#v099-2019-07-14","text":"Full Changelog Closed issues: Homogenise call to reasoner in emmo.Ontology.sync_reasoner() #5 Merged pull requests: #3 update usercase ontology #12 ( jesper-friis ) Fixed 3 #8 ( jesper-friis ) Dockerdevel #2 ( francescalb ) Fix by lukas #1 ( jesper-friis ) * This Changelog was automatically generated by github_changelog_generator","title":"v0.9.9 (2019-07-14)"},{"location":"LICENSE/","text":"Copyright 2019 SINTEF Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"docker-instructions/","text":"EMMOntoPy Docker \u00b6 Clone project \u00b6 git clone git@github.com:emmo-repo/EMMO-python.git Build Docker image \u00b6 cd EMMO-python docker build -t emmo . Run Docker container \u00b6 docker run -it emmo Notes \u00b6 Your Docker container may run out of memory while executing the HermiT reasoner ( sync_reasoner ). Append --memory=2GB to docker run in order to align the memory limit with the Java runtime environment. It is recommended to instead use the FaCT++ reaonser (now default). Uncomment the last line in the Dockerfile, if you wish to start directly in the Python interpreter. Dockerfile for mounting EMMOntoPy as volume (mount.Dockerfile) \u00b6 Build Docker image (mount.DockerFile) \u00b6 docker build -t emmomount -f mount.Dockerfile . Run Docker container (mount.Dockerfile) \u00b6 In a unix terminal (Linux) docker run --rm -it -v $( pwd ) :/home/user/EMMO-python emmomount In PowerShell (Windows 10): docker run - -rm -it -v ${ PWD }:/ home / user / EMMO-python emmomount To install EMMOntoPy package inside container: cd EMMO-python pip install . Notes on mounting on Windows \u00b6 Allow for mounting of C: in Docker (as administrator). Docker (rightclick in system tray) -> Settings -> Shared Drives -> tick of C -> Apply. Run the following command in PowerShell: Set-NetConnectionProfile -interfacealias \"vEthernet (DockerNAT)\" -NetworkCategory Private If mounting does not succeed Reset Credentials (Docker -> Settings -> Shared Drives) and repeat the steps above.","title":"Docker"},{"location":"docker-instructions/#emmontopy-docker","text":"","title":"EMMOntoPy Docker"},{"location":"docker-instructions/#clone-project","text":"git clone git@github.com:emmo-repo/EMMO-python.git","title":"Clone project"},{"location":"docker-instructions/#build-docker-image","text":"cd EMMO-python docker build -t emmo .","title":"Build Docker image"},{"location":"docker-instructions/#run-docker-container","text":"docker run -it emmo","title":"Run Docker container"},{"location":"docker-instructions/#notes","text":"Your Docker container may run out of memory while executing the HermiT reasoner ( sync_reasoner ). Append --memory=2GB to docker run in order to align the memory limit with the Java runtime environment. It is recommended to instead use the FaCT++ reaonser (now default). Uncomment the last line in the Dockerfile, if you wish to start directly in the Python interpreter.","title":"Notes"},{"location":"docker-instructions/#dockerfile-for-mounting-emmontopy-as-volume-mountdockerfile","text":"","title":"Dockerfile for mounting EMMOntoPy as volume (mount.Dockerfile)"},{"location":"docker-instructions/#build-docker-image-mountdockerfile","text":"docker build -t emmomount -f mount.Dockerfile .","title":"Build Docker image (mount.DockerFile)"},{"location":"docker-instructions/#run-docker-container-mountdockerfile","text":"In a unix terminal (Linux) docker run --rm -it -v $( pwd ) :/home/user/EMMO-python emmomount In PowerShell (Windows 10): docker run - -rm -it -v ${ PWD }:/ home / user / EMMO-python emmomount To install EMMOntoPy package inside container: cd EMMO-python pip install .","title":"Run Docker container (mount.Dockerfile)"},{"location":"docker-instructions/#notes-on-mounting-on-windows","text":"Allow for mounting of C: in Docker (as administrator). Docker (rightclick in system tray) -> Settings -> Shared Drives -> tick of C -> Apply. Run the following command in PowerShell: Set-NetConnectionProfile -interfacealias \"vEthernet (DockerNAT)\" -NetworkCategory Private If mounting does not succeed Reset Credentials (Docker -> Settings -> Shared Drives) and repeat the steps above.","title":"Notes on mounting on Windows"},{"location":"release-instructions/","text":"Steps for creating a new release \u00b6 Create a release on GitHub with a short release description. Ensure you add a # <version number> title to the description. Set the tag to the version number prefixed with \"v\" and title to the version number as explained above. 1. Ensure the GitHub Action CD workflows run as expected. The workflow failed If something is wrong and the workflow fails before publishing the package to PyPI, make sure to remove all traces of the release and tag, fix the bug, and try again. If something is wrong and the workflow fails after publishing the package to PyPI: DO NOT REMOVE THE RELEASE OR TAG ! Deployment of the documentation should (in theory) be the only thing that has failed. This can be deployed manually using similar steps as in the workflow.","title":"Steps for creating a new release"},{"location":"release-instructions/#steps-for-creating-a-new-release","text":"Create a release on GitHub with a short release description. Ensure you add a # <version number> title to the description. Set the tag to the version number prefixed with \"v\" and title to the version number as explained above. 1. Ensure the GitHub Action CD workflows run as expected. The workflow failed If something is wrong and the workflow fails before publishing the package to PyPI, make sure to remove all traces of the release and tag, fix the bug, and try again. If something is wrong and the workflow fails after publishing the package to PyPI: DO NOT REMOVE THE RELEASE OR TAG ! Deployment of the documentation should (in theory) be the only thing that has failed. This can be deployed manually using similar steps as in the workflow.","title":"Steps for creating a new release"},{"location":"tools-instructions/","text":"Instructions for tools available in EMMOntoPy \u00b6 Content: emmocheck ontoversion ontograph ontodoc ontoconvert emmocheck \u00b6 Tool for checking that ontologies conform to EMMO conventions. Usage \u00b6 emmocheck [options] iri Options \u00b6 positional arguments: iri File name or URI to the ontology to test. optional arguments: -h, --help show this help message and exit --database FILENAME, -d FILENAME Load ontology from Owlready2 sqlite3 database. The `iri` argument should in this case be the IRI of the ontology you want to check. --local, -l Load imported ontologies locally. Their paths are specified in Prot\u00e9g\u00e9 catalog files or via the --path option. The IRI should be a file name. --catalog-file CATALOG_FILE Name of Prot\u00e9g\u00e9 catalog file in the same folder as the ontology. This option is used together with --local and defaults to \"catalog-v001.xml\". --path PATH Paths where imported ontologies can be found. May be provided as a comma-separated string and/or with multiple --path options. --check-imported, -i Whether to check imported ontologies. --verbose, -v Verbosity level. --configfile CONFIGFILE, -c CONFIGFILE A yaml file with additional test configurations. --skip, -s ShellPattern Shell pattern matching tests to skip. This option may be provided multiple times. --url-from-catalog, -u Get url from catalog file. --ignore-namespace, -n Namespace to be ignored. Can be given multiple times Examples \u00b6 emmocheck http://emmo.info/emmo/1.0.0-alpha2 emmocheck --database demo.sqlite3 http://www.emmc.info/emmc-csa/demo# emmocheck -l emmo.owl (in folder to which emmo was downloaded locally) emmocheck --check-imported --ignore-namespace=physicalistic --verbose --url-from-catalog emmo.owl (in folder with downloaded EMMO) emmocheck --check-imported --local --url-from-catalog --skip test_namespace emmo.owl Example configuration file \u00b6 Example of YAML configuration file provided with the --configfile option that will omit myunits.MyUnitCategory1 and myunits.MyUnitCategory1 from the unit dimensions test . test_unit_dimensions: exceptions: - myunits.MyUnitCategory1 - myunits.MyUnitCategory2 ontoversion \u00b6 Prints version of an ontology to standard output. This script uses RDFLib and the versionIRI tag of the ontology to infer the version. Usage \u00b6 ontoversion [options] iri Special dependencies \u00b6 rdflib (Python package) Options \u00b6 positional arguments: IRI IRI/file to OWL source to extract the version from. optional arguments: -h, --help show this help message and exit --format FORMAT, -f FORMAT OWL format. Default is \"xml\". Examples \u00b6 ontoversion http://emmo.info/emmo/1.0.0-alpha Warning Fails if ontology has no versionIRI tag. ontograph \u00b6 Tool for visualizing ontologies. Usage \u00b6 ontograph [options] iri [output] Dependencies \u00b6 Graphviz Options \u00b6 positional arguments: IRI File name or URI of the ontology to visualise. output name of output file. optional arguments: -h, --help show this help message and exit --format FORMAT, -f FORMAT Format of output file. By default it is inferred from the output file extension. --database FILENAME, -d FILENAME Load ontology from Owlready2 sqlite3 database. The `iri` argument should in this case be the IRI of the ontology you want to visualise. --local, -l Load imported ontologies locally. Their paths are specified in Prot\u00e9g\u00e9 catalog files or via the --path option. The IRI should be a file name. --catalog-file CATALOG_FILE Name of Prot\u00e9g\u00e9 catalog file in the same folder as the ontology. This option is used together with --local and defaults to \"catalog-v001.xml\". --path PATH Paths where imported ontologies can be found. May be provided as a comma-separated string and/or with multiple --path options. --reasoner [{FaCT++,HermiT,Pellet}] Run given reasoner on the ontology. Valid reasoners are \"FaCT++\" (default), \"HermiT\" and \"Pellet\". Note: FaCT++ is preferred with EMMO. --root ROOT, -r ROOT Name of root node in the graph. Defaults to all classes. --leafs LEAFS Leafs nodes for plotting sub-graphs. May be provided as a comma-separated string and/or with multiple --leafs options. --exclude EXCLUDE, -E EXCLUDE Nodes, including their subclasses, to exclude from sub-graphs. May be provided as a comma-separated string and/or with multiple --exclude options. --parents N, -p N Adds N levels of parents to graph. --relations RELATIONS, -R RELATIONS Comma-separated string of relations to visualise. Default is \"isA\". \"all\" means include all relations. --edgelabels, -e Whether to add labels to edges. --addnodes, -n Whether to add missing target nodes in relations. --addconstructs, -c Whether to add nodes representing class constructs. --rankdir {BT,TB,RL,LR} Graph direction (from leaves to root). Possible values are: \"BT\" (bottom-top, default), \"TB\" (top-bottom), \"RL\" (right-left) and \"LR\" (left-right). --style-file JSON_FILE, -s JSON_FILE A json file with style definitions. --legend, -L Whether to add a legend to the graph. --generate-style-file JSON_FILE, -S JSON_FILE Write default style file to a json file. --plot-modules, -m Whether to plot module inter-dependencies instead of their content. --display, -D Whether to display graph. Examples \u00b6 The figure below is generated with the following command: ontograph --root=Material --relations=all --legend emmo-inferred material.png ontodoc \u00b6 Tool for documenting ontologies. Usage \u00b6 ontodoc [options] iri outfile Dependencies \u00b6 pandoc pdflatex or xelatex Options \u00b6 positional arguments: IRI File name or URI of the ontology to document. OUTFILE Output file. optional arguments: -h, --help show this help message and exit --database FILENAME, -d FILENAME Load ontology from Owlready2 sqlite3 database. The `iri` argument should in this case be the IRI of the ontology you want to document. --local, -l Load imported ontologies locally. Their paths are specified in Prot\u00e9g\u00e9 catalog files or via the --path option. The IRI should be a file name. --imported, -i Include imported ontologies --no-catalog, -n Do not read url from catalog even if it exists. --catalog-file CATALOG_FILE Name of Prot\u00e9g\u00e9 catalog file in the same folder as the ontology. This option is used together with --local and defaults to \"catalog-v001.xml\". --path PATH Paths where imported ontologies can be found. May be provided as a comma-separated string and/or with multiple --path options. --reasoner [{FaCT++,HermiT,Pellet}] Run given reasoner on the ontology. Valid reasoners are \"FaCT++\" (default), \"HermiT\" and \"Pellet\". Note: FaCT++ is preferred with EMMO. --template FILE, -t FILE ontodoc input template. If not provided, a simple default template will be used. Don't confuse it with the pandoc templates. --format FORMAT, -f FORMAT Output format. May be \"md\", \"simple-html\" or any other format supported by pandoc. By default the format is inferred from --output. --figdir DIR, -D DIR Default directory to store generated figures. If a relative path is given, it is relative to the template (see --template), or the current directory, if --template is not given. Default: \"genfigs\" --figformat FIGFORMAT, -F FIGFORMAT Format for generated figures. The default is inferred from --format.\" --max-figwidth MAX_FIGWIDTH, -w MAX_FIGWIDTH Maximum figure width. The default is inferred from --format. --pandoc-option STRING, -p STRING Additional pandoc long options overriding those read from --pandoc-option-file. It is possible to remove pandoc option --XXX with \"--pandoc-option=no-XXX\". This option may be provided multiple times. --pandoc-option-file FILE, -P FILE YAML file with additional pandoc options. Note, that default pandoc options are read from the files \"pandoc-options.yaml\" and \"pandoc-FORMAT-options.yaml\" (where FORMAT is format specified with --format). This option allows to override the defaults and add additional pandoc options. This option may be provided multiple times. --keep-generated FILE, -k FILE Keep a copy of generated markdown input file for pandoc (for debugging). Examples \u00b6 Basic documentation of an ontology demo.owl can be generated with: ontodoc --format=simple-html --local demo.owl demo.html See examples/emmodoc/README.md for how this tool is used to generate the html and pdf documentation of EMMO itself. ontoconvert \u00b6 Tool for converting between different ontology formats. Usage \u00b6 ontoconvert [options] inputfile outputfile Dependencies \u00b6 rdflib (Python package) Options \u00b6 positional arguments: INPUTFILE Name of inputfile. OUTPUTFILE Name og output file. optional arguments: -h, --help show this help message and exit --input-format, -f INPUT_FORMAT Inputformat. Default is to infer from input. --output-format, -F OUTPUT_FORMAT Default is to infer from output. --no-catalog, -n Do not read catalog even if it exists. --inferred, -i Add additional relations inferred by the FaCT++ reasoner to the converted ontology. Implies --squash. --base-iri BASE_IRI, -b BASE_IRI Base iri of inferred ontology. The default is the base iri of the input ontology with \"-inferred\" appended to it. Used together with --inferred. --recursive, -r The output is written to the directories matching the input. This requires Protege catalog files to be present. --squash, -s Squash imported ontologies into a single output file. Examples \u00b6 ontoconvert --recursive emmo.ttl owl/emmo.owl ontoconvert --inferred emmo.ttl emmo-inferred.owl Note, it is then required to add the argument only_local=True when loading the locally converted ontology in EMMO-python, e.g.: from ontopy import get_ontology emmo_ontology = get_ontology ( \"emmo.owl\" ) . load ( only_local = True ) Since the catalog file will be overwritten in the above example writing output to a separate directory is useful. ontoconvert --recursive emmo.ttl owl/emmo.owl","title":"Tools"},{"location":"tools-instructions/#instructions-for-tools-available-in-emmontopy","text":"Content: emmocheck ontoversion ontograph ontodoc ontoconvert","title":"Instructions for tools available in EMMOntoPy"},{"location":"tools-instructions/#emmocheck","text":"Tool for checking that ontologies conform to EMMO conventions.","title":"emmocheck"},{"location":"tools-instructions/#usage","text":"emmocheck [options] iri","title":"Usage"},{"location":"tools-instructions/#options","text":"positional arguments: iri File name or URI to the ontology to test. optional arguments: -h, --help show this help message and exit --database FILENAME, -d FILENAME Load ontology from Owlready2 sqlite3 database. The `iri` argument should in this case be the IRI of the ontology you want to check. --local, -l Load imported ontologies locally. Their paths are specified in Prot\u00e9g\u00e9 catalog files or via the --path option. The IRI should be a file name. --catalog-file CATALOG_FILE Name of Prot\u00e9g\u00e9 catalog file in the same folder as the ontology. This option is used together with --local and defaults to \"catalog-v001.xml\". --path PATH Paths where imported ontologies can be found. May be provided as a comma-separated string and/or with multiple --path options. --check-imported, -i Whether to check imported ontologies. --verbose, -v Verbosity level. --configfile CONFIGFILE, -c CONFIGFILE A yaml file with additional test configurations. --skip, -s ShellPattern Shell pattern matching tests to skip. This option may be provided multiple times. --url-from-catalog, -u Get url from catalog file. --ignore-namespace, -n Namespace to be ignored. Can be given multiple times","title":"Options"},{"location":"tools-instructions/#examples","text":"emmocheck http://emmo.info/emmo/1.0.0-alpha2 emmocheck --database demo.sqlite3 http://www.emmc.info/emmc-csa/demo# emmocheck -l emmo.owl (in folder to which emmo was downloaded locally) emmocheck --check-imported --ignore-namespace=physicalistic --verbose --url-from-catalog emmo.owl (in folder with downloaded EMMO) emmocheck --check-imported --local --url-from-catalog --skip test_namespace emmo.owl","title":"Examples"},{"location":"tools-instructions/#example-configuration-file","text":"Example of YAML configuration file provided with the --configfile option that will omit myunits.MyUnitCategory1 and myunits.MyUnitCategory1 from the unit dimensions test . test_unit_dimensions: exceptions: - myunits.MyUnitCategory1 - myunits.MyUnitCategory2","title":"Example configuration file"},{"location":"tools-instructions/#ontoversion","text":"Prints version of an ontology to standard output. This script uses RDFLib and the versionIRI tag of the ontology to infer the version.","title":"ontoversion"},{"location":"tools-instructions/#usage_1","text":"ontoversion [options] iri","title":"Usage"},{"location":"tools-instructions/#special-dependencies","text":"rdflib (Python package)","title":"Special dependencies"},{"location":"tools-instructions/#options_1","text":"positional arguments: IRI IRI/file to OWL source to extract the version from. optional arguments: -h, --help show this help message and exit --format FORMAT, -f FORMAT OWL format. Default is \"xml\".","title":"Options"},{"location":"tools-instructions/#examples_1","text":"ontoversion http://emmo.info/emmo/1.0.0-alpha Warning Fails if ontology has no versionIRI tag.","title":"Examples"},{"location":"tools-instructions/#ontograph","text":"Tool for visualizing ontologies.","title":"ontograph"},{"location":"tools-instructions/#usage_2","text":"ontograph [options] iri [output]","title":"Usage"},{"location":"tools-instructions/#dependencies","text":"Graphviz","title":"Dependencies"},{"location":"tools-instructions/#options_2","text":"positional arguments: IRI File name or URI of the ontology to visualise. output name of output file. optional arguments: -h, --help show this help message and exit --format FORMAT, -f FORMAT Format of output file. By default it is inferred from the output file extension. --database FILENAME, -d FILENAME Load ontology from Owlready2 sqlite3 database. The `iri` argument should in this case be the IRI of the ontology you want to visualise. --local, -l Load imported ontologies locally. Their paths are specified in Prot\u00e9g\u00e9 catalog files or via the --path option. The IRI should be a file name. --catalog-file CATALOG_FILE Name of Prot\u00e9g\u00e9 catalog file in the same folder as the ontology. This option is used together with --local and defaults to \"catalog-v001.xml\". --path PATH Paths where imported ontologies can be found. May be provided as a comma-separated string and/or with multiple --path options. --reasoner [{FaCT++,HermiT,Pellet}] Run given reasoner on the ontology. Valid reasoners are \"FaCT++\" (default), \"HermiT\" and \"Pellet\". Note: FaCT++ is preferred with EMMO. --root ROOT, -r ROOT Name of root node in the graph. Defaults to all classes. --leafs LEAFS Leafs nodes for plotting sub-graphs. May be provided as a comma-separated string and/or with multiple --leafs options. --exclude EXCLUDE, -E EXCLUDE Nodes, including their subclasses, to exclude from sub-graphs. May be provided as a comma-separated string and/or with multiple --exclude options. --parents N, -p N Adds N levels of parents to graph. --relations RELATIONS, -R RELATIONS Comma-separated string of relations to visualise. Default is \"isA\". \"all\" means include all relations. --edgelabels, -e Whether to add labels to edges. --addnodes, -n Whether to add missing target nodes in relations. --addconstructs, -c Whether to add nodes representing class constructs. --rankdir {BT,TB,RL,LR} Graph direction (from leaves to root). Possible values are: \"BT\" (bottom-top, default), \"TB\" (top-bottom), \"RL\" (right-left) and \"LR\" (left-right). --style-file JSON_FILE, -s JSON_FILE A json file with style definitions. --legend, -L Whether to add a legend to the graph. --generate-style-file JSON_FILE, -S JSON_FILE Write default style file to a json file. --plot-modules, -m Whether to plot module inter-dependencies instead of their content. --display, -D Whether to display graph.","title":"Options"},{"location":"tools-instructions/#examples_2","text":"The figure below is generated with the following command: ontograph --root=Material --relations=all --legend emmo-inferred material.png","title":"Examples"},{"location":"tools-instructions/#ontodoc","text":"Tool for documenting ontologies.","title":"ontodoc"},{"location":"tools-instructions/#usage_3","text":"ontodoc [options] iri outfile","title":"Usage"},{"location":"tools-instructions/#dependencies_1","text":"pandoc pdflatex or xelatex","title":"Dependencies"},{"location":"tools-instructions/#options_3","text":"positional arguments: IRI File name or URI of the ontology to document. OUTFILE Output file. optional arguments: -h, --help show this help message and exit --database FILENAME, -d FILENAME Load ontology from Owlready2 sqlite3 database. The `iri` argument should in this case be the IRI of the ontology you want to document. --local, -l Load imported ontologies locally. Their paths are specified in Prot\u00e9g\u00e9 catalog files or via the --path option. The IRI should be a file name. --imported, -i Include imported ontologies --no-catalog, -n Do not read url from catalog even if it exists. --catalog-file CATALOG_FILE Name of Prot\u00e9g\u00e9 catalog file in the same folder as the ontology. This option is used together with --local and defaults to \"catalog-v001.xml\". --path PATH Paths where imported ontologies can be found. May be provided as a comma-separated string and/or with multiple --path options. --reasoner [{FaCT++,HermiT,Pellet}] Run given reasoner on the ontology. Valid reasoners are \"FaCT++\" (default), \"HermiT\" and \"Pellet\". Note: FaCT++ is preferred with EMMO. --template FILE, -t FILE ontodoc input template. If not provided, a simple default template will be used. Don't confuse it with the pandoc templates. --format FORMAT, -f FORMAT Output format. May be \"md\", \"simple-html\" or any other format supported by pandoc. By default the format is inferred from --output. --figdir DIR, -D DIR Default directory to store generated figures. If a relative path is given, it is relative to the template (see --template), or the current directory, if --template is not given. Default: \"genfigs\" --figformat FIGFORMAT, -F FIGFORMAT Format for generated figures. The default is inferred from --format.\" --max-figwidth MAX_FIGWIDTH, -w MAX_FIGWIDTH Maximum figure width. The default is inferred from --format. --pandoc-option STRING, -p STRING Additional pandoc long options overriding those read from --pandoc-option-file. It is possible to remove pandoc option --XXX with \"--pandoc-option=no-XXX\". This option may be provided multiple times. --pandoc-option-file FILE, -P FILE YAML file with additional pandoc options. Note, that default pandoc options are read from the files \"pandoc-options.yaml\" and \"pandoc-FORMAT-options.yaml\" (where FORMAT is format specified with --format). This option allows to override the defaults and add additional pandoc options. This option may be provided multiple times. --keep-generated FILE, -k FILE Keep a copy of generated markdown input file for pandoc (for debugging).","title":"Options"},{"location":"tools-instructions/#examples_3","text":"Basic documentation of an ontology demo.owl can be generated with: ontodoc --format=simple-html --local demo.owl demo.html See examples/emmodoc/README.md for how this tool is used to generate the html and pdf documentation of EMMO itself.","title":"Examples"},{"location":"tools-instructions/#ontoconvert","text":"Tool for converting between different ontology formats.","title":"ontoconvert"},{"location":"tools-instructions/#usage_4","text":"ontoconvert [options] inputfile outputfile","title":"Usage"},{"location":"tools-instructions/#dependencies_2","text":"rdflib (Python package)","title":"Dependencies"},{"location":"tools-instructions/#options_4","text":"positional arguments: INPUTFILE Name of inputfile. OUTPUTFILE Name og output file. optional arguments: -h, --help show this help message and exit --input-format, -f INPUT_FORMAT Inputformat. Default is to infer from input. --output-format, -F OUTPUT_FORMAT Default is to infer from output. --no-catalog, -n Do not read catalog even if it exists. --inferred, -i Add additional relations inferred by the FaCT++ reasoner to the converted ontology. Implies --squash. --base-iri BASE_IRI, -b BASE_IRI Base iri of inferred ontology. The default is the base iri of the input ontology with \"-inferred\" appended to it. Used together with --inferred. --recursive, -r The output is written to the directories matching the input. This requires Protege catalog files to be present. --squash, -s Squash imported ontologies into a single output file.","title":"Options"},{"location":"tools-instructions/#examples_4","text":"ontoconvert --recursive emmo.ttl owl/emmo.owl ontoconvert --inferred emmo.ttl emmo-inferred.owl Note, it is then required to add the argument only_local=True when loading the locally converted ontology in EMMO-python, e.g.: from ontopy import get_ontology emmo_ontology = get_ontology ( \"emmo.owl\" ) . load ( only_local = True ) Since the catalog file will be overwritten in the above example writing output to a separate directory is useful. ontoconvert --recursive emmo.ttl owl/emmo.owl","title":"Examples"},{"location":"api_reference/emmopy/emmocheck/","text":"emmocheck \u00b6 A module for testing an ontology against conventions defined for EMMO. A YAML file can be provided with additional test configurations. Example configuration file: test_unit_dimensions: exceptions: - myunits.MyUnitCategory1 - myunits.MyUnitCategory2 skip: - name_of_test_to_skip enable: - name_of_test_to_enable TestEMMOConventions \u00b6 Base class for testing an ontology against EMMO conventions. get_config ( self , string , default = None ) \u00b6 Returns the configuration specified by string . If configuration is not found in the configuration file, default is returned. Sub-configurations can be accessed by separating the components with dots, like \"test_namespace.exceptions\". Source code in emmopy/emmocheck.py def get_config ( self , string , default = None ): \"\"\"Returns the configuration specified by `string`. If configuration is not found in the configuration file, `default` is returned. Sub-configurations can be accessed by separating the components with dots, like \"test_namespace.exceptions\". \"\"\" c = self . config try : for token in string . split ( '.' ): c = c [ token ] except KeyError : return default return c TestFunctionalEMMOConventions \u00b6 Test functional EMMO conventions. test_namespace ( self ) \u00b6 Check that all IRIs are namespaced after their (sub)ontology. Configurations exceptions - full name of entities to ignore. Source code in emmopy/emmocheck.py def test_namespace ( self ): \"\"\"Check that all IRIs are namespaced after their (sub)ontology. Configurations: exceptions - full name of entities to ignore. \"\"\" exceptions = set (( 'owl.qualifiedCardinality' , 'owl.minQualifiedCardinality' , 'terms.creator' , 'terms.contributor' , 'terms.publisher' , 'terms.title' , 'terms.license' , 'terms.abstract' , 'core.prefLabel' , 'core.altLabel' , 'core.hiddenLabel' , 'mereotopology.Item' , 'manufacturing.EngineeredMaterial' , )) exceptions . update ( self . get_config ( 'test_namespace.exceptions' , ())) def checker ( onto , ignore_namespace ): if list ( filter ( onto . base_iri . strip ( '#' ) . endswith , self . ignore_namespace )) != []: print ( 'Skipping namespace: ' + onto . base_iri ) return entities = itertools . chain ( onto . classes (), onto . object_properties (), onto . data_properties (), onto . individuals (), onto . annotation_properties ()) for e in entities : if e not in visited and repr ( e ) not in exceptions : visited . add ( e ) with self . subTest ( iri = e . iri , base_iri = onto . base_iri , entity = repr ( e )): self . assertTrue ( e . iri . endswith ( e . name ), msg = 'the final part of entity IRIs must be their ' 'name' ) self . assertEqual ( e . iri , onto . base_iri + e . name , msg = 'IRI %r does not correspond to module ' 'namespace: %r ' % ( e . iri , onto . base_iri )) if self . check_imported : for imp_onto in onto . imported_ontologies : if imp_onto not in visited_onto : visited_onto . add ( imp_onto ) checker ( imp_onto , ignore_namespace ) visited = set () visited_onto = set () checker ( self . onto , self . ignore_namespace ) test_physical_quantity_dimension ( self ) \u00b6 Check that all physical quantities have hasPhysicalDimension . Note: this test will fail before isq is moved to emmo/domain. Configurations exceptions - full class names of classes to ignore. Source code in emmopy/emmocheck.py def test_physical_quantity_dimension ( self ): \"\"\"Check that all physical quantities have `hasPhysicalDimension`. Note: this test will fail before isq is moved to emmo/domain. Configurations: exceptions - full class names of classes to ignore. \"\"\" exceptions = set (( 'emmo.ModelledQuantitativeProperty' , 'emmo.MeasuredQuantitativeProperty' , 'emmo.ConventionalQuantitativeProperty' , 'emmo.QuantitativeProperty' , 'emmo.BaseQuantity' , 'emmo.PhysicalConstant' , 'emmo.PhysicalQuantity' , 'emmo.ExactConstant' , 'emmo.MeasuredConstant' , 'emmo.DerivedQuantity' , 'emmo.ISQBaseQuantity' , 'emmo.InternationalSystemOfQuantity' , 'emmo.ISQDerivedQuantity' , 'emmo.SIExactConstant' , 'emmo.NonSIUnits' , 'emmo.StandardizedPhysicalQuantity' , 'emmo.CategorizedPhysicalQuantity' , 'emmo.AtomicAndNuclearPhysicsQuantity' , 'emmo.ThermodynamicalQuantity' , 'emmo.LightAndRadiationQuantity' , 'emmo.SpaceAndTimeQuantity' , 'emmo.AcousticQuantity' , 'emmo.PhysioChememicalQuantity' , 'emmo.ElectromagneticQuantity' , 'emmo.MechanicalQuantity' , 'emmo.CondensedMatterPhysicsQuantity' , 'emmo.ChemicalCompositionQuantity' , 'emmo.Extensive' , 'emmo.Intensive' , )) if not hasattr ( self . onto , 'PhysicalQuantity' ): return exceptions . update ( self . get_config ( 'test_physical_quantity_dimension.exceptions' , ())) classes = set ( self . onto . classes ( self . check_imported )) for cls in self . onto . PhysicalQuantity . descendants (): if not self . check_imported and cls not in classes : continue if repr ( cls ) not in exceptions : with self . subTest ( cls = cls , label = get_label ( cls )): try : class_props = cls . INDIRECT_get_class_properties () except AttributeError : # The INDIRECT_get_class_properties() method # does not support inverse properties. Build # class_props manually... class_props = set () for c in cls . mro (): if hasattr ( c , 'is_a' ): class_props . update ( [ r . property for r in c . is_a if isinstance ( r , owlready2 . Restriction )]) self . assertIn ( self . onto . hasPhysicalDimension , class_props , msg = cls ) test_quantity_dimension ( self ) \u00b6 Check that all quantities have a physicalDimension annotation. Note: this test will be deprecated when isq is moved to emmo/domain. Configurations exceptions - full class names of classes to ignore. Source code in emmopy/emmocheck.py def test_quantity_dimension ( self ): \"\"\"Check that all quantities have a physicalDimension annotation. Note: this test will be deprecated when isq is moved to emmo/domain. Configurations: exceptions - full class names of classes to ignore. \"\"\" exceptions = set (( 'properties.ModelledQuantitativeProperty' , 'properties.MeasuredQuantitativeProperty' , 'properties.ConventionalQuantitativeProperty' , 'metrology.QuantitativeProperty' , 'metrology.Quantity' , 'metrology.OrdinalQuantity' , 'metrology.BaseQuantity' , 'metrology.PhysicalConstant' , 'metrology.PhysicalQuantity' , 'metrology.ExactConstant' , 'metrology.MeasuredConstant' , 'metrology.DerivedQuantity' , 'isq.ISQBaseQuantity' , 'isq.InternationalSystemOfQuantity' , 'isq.ISQDerivedQuantity' , 'isq.SIExactConstant' , 'emmo.ModelledQuantitativeProperty' , 'emmo.MeasuredQuantitativeProperty' , 'emmo.ConventionalQuantitativeProperty' , 'emmo.QuantitativeProperty' , 'emmo.Quantity' , 'emmo.OrdinalQuantity' , 'emmo.BaseQuantity' , 'emmo.PhysicalConstant' , 'emmo.PhysicalQuantity' , 'emmo.ExactConstant' , 'emmo.MeasuredConstant' , 'emmo.DerivedQuantity' , 'emmo.ISQBaseQuantity' , 'emmo.InternationalSystemOfQuantity' , 'emmo.ISQDerivedQuantity' , 'emmo.SIExactConstant' , 'emmo.NonSIUnits' , 'emmo.StandardizedPhysicalQuantity' , 'emmo.CategorizedPhysicalQuantity' , 'emmo.AtomicAndNuclear' , 'emmo.Defined' , 'emmo.Electromagnetic' , 'emmo.FrequentlyUsed' , 'emmo.PhysicoChemical' , 'emmo.ChemicalCompositionQuantity' , 'emmo.Universal' , )) if not hasattr ( self . onto , 'PhysicalQuantity' ): return exceptions . update ( self . get_config ( 'test_quantity_dimension.exceptions' , ())) regex = re . compile ( '^T([+-][1-9]|0) L([+-][1-9]|0) M([+-][1-9]|0) I([+-][1-9]|0) ' '(H|\u0398)([+-][1-9]|0) N([+-][1-9]|0) J([+-][1-9]|0)$' ) classes = set ( self . onto . classes ( self . check_imported )) for cls in self . onto . PhysicalQuantity . descendants (): if not self . check_imported and cls not in classes : continue if repr ( cls ) not in exceptions : with self . subTest ( cls = cls , label = get_label ( cls )): anno = cls . get_annotations () self . assertIn ( 'physicalDimension' , anno , msg = cls ) physdim = anno [ 'physicalDimension' ] . first () self . assertRegex ( physdim , regex , msg = cls ) test_unit_dimension ( self ) \u00b6 Check that all measurement units have a physical dimension. Configurations exceptions - full class names of classes to ignore. Source code in emmopy/emmocheck.py def test_unit_dimension ( self ): \"\"\"Check that all measurement units have a physical dimension. Configurations: exceptions - full class names of classes to ignore. \"\"\" exceptions = set (( 'metrology.MultipleUnit' , 'metrology.SubMultipleUnit' , 'metrology.OffSystemUnit' , 'metrology.PrefixedUnit' , 'metrology.NonPrefixedUnit' , 'metrology.SpecialUnit' , 'metrology.DerivedUnit' , 'metrology.BaseUnit' , 'metrology.UnitSymbol' , 'siunits.SICoherentDerivedUnit' , 'siunits.SINonCoherentDerivedUnit' , 'siunits.SISpecialUnit' , 'siunits.SICoherentUnit' , 'siunits.SIPrefixedUnit' , 'siunits.SIBaseUnit' , 'siunits.SIUnitSymbol' , 'siunits.SIUnit' , 'emmo.MultipleUnit' , 'emmo.SubMultipleUnit' , 'emmo.OffSystemUnit' , 'emmo.PrefixedUnit' , 'emmo.NonPrefixedUnit' , 'emmo.SpecialUnit' , 'emmo.DerivedUnit' , 'emmo.BaseUnit' , 'emmo.UnitSymbol' , 'emmo.SICoherentDerivedUnit' , 'emmo.SINonCoherentDerivedUnit' , 'emmo.SISpecialUnit' , 'emmo.SICoherentUnit' , 'emmo.SIPrefixedUnit' , 'emmo.SIBaseUnit' , 'emmo.SIUnitSymbol' , 'emmo.SIUnit' , )) if not hasattr ( self . onto , 'MeasurementUnit' ): return exceptions . update ( self . get_config ( 'test_unit_dimension.exceptions' , ())) regex = re . compile ( r '^(emmo|metrology).hasPhysicalDimension.some\\(.*\\)$' ) classes = set ( self . onto . classes ( self . check_imported )) for cls in self . onto . MeasurementUnit . descendants (): if not self . check_imported and cls not in classes : continue # Assume that actual units are not subclassed if not list ( cls . subclasses ()) and repr ( cls ) not in exceptions : with self . subTest ( cls = cls , label = get_label ( cls )): self . assertTrue ( any ( regex . match ( repr ( r )) for r in cls . get_indirect_is_a ()), msg = cls ) TestSyntacticEMMOConventions \u00b6 Test syntactic EMMO conventions. test_class_label ( self ) \u00b6 Check that class labels are CamelCase and valid identifiers. For CamelCase, we are currently only checking that the labels start with upper case. Source code in emmopy/emmocheck.py def test_class_label ( self ): \"\"\"Check that class labels are CamelCase and valid identifiers. For CamelCase, we are currently only checking that the labels start with upper case. \"\"\" exceptions = set (( '0-manifold' , # not needed in 1.0.0-beta '1-manifold' , '2-manifold' , '3-manifold' , 'C++' , )) exceptions . update ( self . get_config ( 'test_class_label.exceptions' , ())) for cls in self . onto . classes ( self . check_imported ): for label in cls . label + getattr ( cls , 'prefLabel' , []): if label not in exceptions : with self . subTest ( entity = cls , label = label ): self . assertTrue ( label . isidentifier ()) self . assertTrue ( label [ 0 ] . isupper ()) test_number_of_labels ( self ) \u00b6 Check that all entities have one and only one prefLabel. Use \"altLabel\" for synonyms. The only allowed exception is entities who's representation starts with \"owl.\". Source code in emmopy/emmocheck.py def test_number_of_labels ( self ): \"\"\"Check that all entities have one and only one prefLabel. Use \"altLabel\" for synonyms. The only allowed exception is entities who's representation starts with \"owl.\". \"\"\" exceptions = set (( 'terms.license' , 'terms.abstract' , 'terms.contributor' , 'terms.creator' , 'terms.publisher' , 'terms.title' , 'core.prefLabel' , 'core.altLabel' , 'core.hiddenLabel' , )) exceptions . update ( self . get_config ( 'test_number_of_labels.exceptions' , ())) if 'prefLabel' in self . onto . world . _props : for e in self . onto . get_entities (): if repr ( e ) not in exceptions : with self . subTest ( entity = e , label = get_label ( e ), prefLabels = e . prefLabel ): if not repr ( e ) . startswith ( 'owl.' ): self . assertTrue ( hasattr ( e , 'prefLabel' )) self . assertEqual ( 1 , len ( e . prefLabel )) else : self . fail ( 'ontology has no prefLabel' ) test_object_property_label ( self ) \u00b6 Check that object property labels are lowerCamelCase. Allowed exceptions: \"EMMORelation\" If they start with \"has\" or \"is\" they should be followed by a upper case letter. If they start with \"is\" they should also end with \"Of\". Source code in emmopy/emmocheck.py def test_object_property_label ( self ): \"\"\"Check that object property labels are lowerCamelCase. Allowed exceptions: \"EMMORelation\" If they start with \"has\" or \"is\" they should be followed by a upper case letter. If they start with \"is\" they should also end with \"Of\". \"\"\" exceptions = set (( 'EMMORelation' , )) exceptions . update ( self . get_config ( 'test_object_property_label.exceptions' , ())) for op in self . onto . object_properties (): if repr ( op ) not in exceptions : for label in op . label : with self . subTest ( entity = op , label = label ): self . assertTrue ( label [ 0 ] . islower (), 'label start with lowercase' ) if label . startswith ( 'has' ): self . assertTrue ( label [ 3 ] . isupper (), 'what follows \"has\" must be ' 'uppercase' ) if label . startswith ( 'is' ): self . assertTrue ( label [ 2 ] . isupper (), 'what follows \"is\" must be ' 'uppercase' ) self . assertTrue ( label . endswith (( 'Of' , 'With' )), 'should end with \"Of\" or \"With\"' ) main () \u00b6 Run all checks on ontology iri . Default is 'http://emmo.info/emmo'. Source code in emmopy/emmocheck.py def main (): \"\"\"Run all checks on ontology `iri`. Default is 'http://emmo.info/emmo'. \"\"\" parser = argparse . ArgumentParser ( description = __doc__ ) parser . add_argument ( 'iri' , help = 'File name or URI to the ontology to test.' ) parser . add_argument ( '--database' , '-d' , metavar = 'FILENAME' , default = ':memory:' , help = 'Load ontology from Owlready2 sqlite3 database. The `iri` ' 'argument should in this case be the IRI of the ontology you ' 'want to check.' ) parser . add_argument ( '--local' , '-l' , action = 'store_true' , help = 'Load imported ontologies locally. Their paths are specified ' 'in Prot\u00e8g\u00e8 catalog files or via the --path option. The IRI should ' 'be a file name.' ) parser . add_argument ( '--catalog-file' , default = 'catalog-v001.xml' , help = 'Name of Prot\u00e8g\u00e8 catalog file in the same folder as the ' 'ontology. This option is used together with --local and ' 'defaults to \"catalog-v001.xml\".' ) parser . add_argument ( '--path' , action = 'append' , default = [], help = 'Paths where imported ontologies can be found. May be provided ' 'as a comma-separated string and/or with multiple --path options.' ) parser . add_argument ( '--check-imported' , '-i' , action = 'store_true' , help = 'Whether to check imported ontologies.' ) parser . add_argument ( '--verbose' , '-v' , action = 'store_true' , help = 'Verbosity level.' ) parser . add_argument ( '--configfile' , '-c' , help = 'A yaml file with additional test configurations.' ) parser . add_argument ( '--skip' , '-s' , action = 'append' , default = [], help = ( 'Shell pattern matching tests to skip. This option may be ' 'provided multiple times.' )) parser . add_argument ( '--enable' , '-e' , action = 'append' , default = [], help = ( 'Shell pattern matching tests to enable that have been ' 'skipped by default or in the config file. This option may ' 'be provided multiple times.' )) parser . add_argument ( # deprecated, replaced by --no-catalog '--url-from-catalog' , '-u' , default = None , action = 'store_true' , help = ( 'Get url from catalog file' )) parser . add_argument ( '--no-catalog' , action = 'store_false' , dest = 'url_from_catalog' , default = None , help = 'Whether to not read catalog file even if it exists.' ) parser . add_argument ( '--ignore-namespace' , '-n' , action = 'append' , default = [], help = ( 'Namespace to be ignored. Can be given multiple ' 'times' )) # Options to pass forward to unittest parser . add_argument ( '--buffer' , '-b' , dest = 'unittest' , action = 'append_const' , const = '-b' , help = ( 'The standard output and standard error streams are buffered ' 'during the test run. Output during a passing test is ' 'discarded. Output is echoed normally on test fail or error ' 'and is added to the failure messages.' )) parser . add_argument ( '--catch' , dest = 'unittest' , action = 'append_const' , const = '-c' , help = ( 'Control-C during the test run waits for the current test to ' 'end and then reports all the results so far. A second ' 'control-C raises the normal KeyboardInterrupt exception' )) parser . add_argument ( '--failfast' , '-f' , dest = 'unittest' , action = 'append_const' , const = '-f' , help = ( 'Stop the test run on the first error or failure.' )) try : args = parser . parse_args () sys . argv [ 1 :] = args . unittest if args . unittest else [] if args . verbose : sys . argv . append ( '-v' ) except SystemExit as e : os . _exit ( e . code ) # Exit without traceback on invalid arguments # Append to onto_path for paths in args . path : for path in paths . split ( ',' ): if path not in onto_path : onto_path . append ( path ) # Load ontology world = World ( filename = args . database ) if args . database != ':memory:' and args . iri not in world . ontologies : parser . error ( 'The IRI argument should be one of the ontologies in ' 'the database: \\n ' + ' \\n ' . join ( world . ontologies . keys ())) onto = world . get_ontology ( args . iri ) onto . load ( only_local = args . local , url_from_catalog = args . url_from_catalog , catalog_file = args . catalog_file ) # Store settings TestEMMOConventions TestEMMOConventions . onto = onto TestEMMOConventions . check_imported = args . check_imported TestEMMOConventions . ignore_namespace = args . ignore_namespace # Configure tests verbosity = 2 if args . verbose else 1 if args . configfile : import yaml with open ( args . configfile , 'rt' ) as f : TestEMMOConventions . config . update ( yaml . load ( f , Loader = yaml . SafeLoader )) # Run all subclasses of TestEMMOConventions as test suites status = 0 for cls in TestEMMOConventions . __subclasses__ (): suite = unittest . TestLoader () . loadTestsFromTestCase ( cls ) # Mark tests to be skipped for test in suite : name = test . id () . split ( '.' )[ - 1 ] skipped = set ([ # skipped by default 'test_namespace' , 'test_physical_quantity_dimension' , ]) msg = { name : 'skipped by default' for name in skipped } # enable/skip tests from config file for pattern in test . get_config ( 'enable' , ()): if fnmatch . fnmatchcase ( name , pattern ): skipped . remove ( name ) for pattern in test . get_config ( 'skip' , ()): if fnmatch . fnmatchcase ( name , pattern ): skipped . add ( name ) msg [ name ] = 'skipped from config file' # enable/skip from command line for pattern in args . enable : if fnmatch . fnmatchcase ( name , pattern ): skipped . remove ( name ) for pattern in args . skip : if fnmatch . fnmatchcase ( name , pattern ): skipped . add ( name ) msg [ name ] = 'skipped from command line' if name in skipped : setattr ( test , 'setUp' , lambda : test . skipTest ( msg . get ( name , '' ))) runner = TextTestRunner ( verbosity = verbosity ) runner . resultclass . checkmode = True result = runner . run ( suite ) if result . failures : status = 1 return status","title":"emmocheck"},{"location":"api_reference/emmopy/emmocheck/#emmocheck","text":"A module for testing an ontology against conventions defined for EMMO. A YAML file can be provided with additional test configurations. Example configuration file: test_unit_dimensions: exceptions: - myunits.MyUnitCategory1 - myunits.MyUnitCategory2 skip: - name_of_test_to_skip enable: - name_of_test_to_enable","title":"emmocheck"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestEMMOConventions","text":"Base class for testing an ontology against EMMO conventions.","title":"TestEMMOConventions"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestEMMOConventions.get_config","text":"Returns the configuration specified by string . If configuration is not found in the configuration file, default is returned. Sub-configurations can be accessed by separating the components with dots, like \"test_namespace.exceptions\". Source code in emmopy/emmocheck.py def get_config ( self , string , default = None ): \"\"\"Returns the configuration specified by `string`. If configuration is not found in the configuration file, `default` is returned. Sub-configurations can be accessed by separating the components with dots, like \"test_namespace.exceptions\". \"\"\" c = self . config try : for token in string . split ( '.' ): c = c [ token ] except KeyError : return default return c","title":"get_config()"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestFunctionalEMMOConventions","text":"Test functional EMMO conventions.","title":"TestFunctionalEMMOConventions"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestFunctionalEMMOConventions.test_namespace","text":"Check that all IRIs are namespaced after their (sub)ontology. Configurations exceptions - full name of entities to ignore. Source code in emmopy/emmocheck.py def test_namespace ( self ): \"\"\"Check that all IRIs are namespaced after their (sub)ontology. Configurations: exceptions - full name of entities to ignore. \"\"\" exceptions = set (( 'owl.qualifiedCardinality' , 'owl.minQualifiedCardinality' , 'terms.creator' , 'terms.contributor' , 'terms.publisher' , 'terms.title' , 'terms.license' , 'terms.abstract' , 'core.prefLabel' , 'core.altLabel' , 'core.hiddenLabel' , 'mereotopology.Item' , 'manufacturing.EngineeredMaterial' , )) exceptions . update ( self . get_config ( 'test_namespace.exceptions' , ())) def checker ( onto , ignore_namespace ): if list ( filter ( onto . base_iri . strip ( '#' ) . endswith , self . ignore_namespace )) != []: print ( 'Skipping namespace: ' + onto . base_iri ) return entities = itertools . chain ( onto . classes (), onto . object_properties (), onto . data_properties (), onto . individuals (), onto . annotation_properties ()) for e in entities : if e not in visited and repr ( e ) not in exceptions : visited . add ( e ) with self . subTest ( iri = e . iri , base_iri = onto . base_iri , entity = repr ( e )): self . assertTrue ( e . iri . endswith ( e . name ), msg = 'the final part of entity IRIs must be their ' 'name' ) self . assertEqual ( e . iri , onto . base_iri + e . name , msg = 'IRI %r does not correspond to module ' 'namespace: %r ' % ( e . iri , onto . base_iri )) if self . check_imported : for imp_onto in onto . imported_ontologies : if imp_onto not in visited_onto : visited_onto . add ( imp_onto ) checker ( imp_onto , ignore_namespace ) visited = set () visited_onto = set () checker ( self . onto , self . ignore_namespace )","title":"test_namespace()"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestFunctionalEMMOConventions.test_physical_quantity_dimension","text":"Check that all physical quantities have hasPhysicalDimension . Note: this test will fail before isq is moved to emmo/domain. Configurations exceptions - full class names of classes to ignore. Source code in emmopy/emmocheck.py def test_physical_quantity_dimension ( self ): \"\"\"Check that all physical quantities have `hasPhysicalDimension`. Note: this test will fail before isq is moved to emmo/domain. Configurations: exceptions - full class names of classes to ignore. \"\"\" exceptions = set (( 'emmo.ModelledQuantitativeProperty' , 'emmo.MeasuredQuantitativeProperty' , 'emmo.ConventionalQuantitativeProperty' , 'emmo.QuantitativeProperty' , 'emmo.BaseQuantity' , 'emmo.PhysicalConstant' , 'emmo.PhysicalQuantity' , 'emmo.ExactConstant' , 'emmo.MeasuredConstant' , 'emmo.DerivedQuantity' , 'emmo.ISQBaseQuantity' , 'emmo.InternationalSystemOfQuantity' , 'emmo.ISQDerivedQuantity' , 'emmo.SIExactConstant' , 'emmo.NonSIUnits' , 'emmo.StandardizedPhysicalQuantity' , 'emmo.CategorizedPhysicalQuantity' , 'emmo.AtomicAndNuclearPhysicsQuantity' , 'emmo.ThermodynamicalQuantity' , 'emmo.LightAndRadiationQuantity' , 'emmo.SpaceAndTimeQuantity' , 'emmo.AcousticQuantity' , 'emmo.PhysioChememicalQuantity' , 'emmo.ElectromagneticQuantity' , 'emmo.MechanicalQuantity' , 'emmo.CondensedMatterPhysicsQuantity' , 'emmo.ChemicalCompositionQuantity' , 'emmo.Extensive' , 'emmo.Intensive' , )) if not hasattr ( self . onto , 'PhysicalQuantity' ): return exceptions . update ( self . get_config ( 'test_physical_quantity_dimension.exceptions' , ())) classes = set ( self . onto . classes ( self . check_imported )) for cls in self . onto . PhysicalQuantity . descendants (): if not self . check_imported and cls not in classes : continue if repr ( cls ) not in exceptions : with self . subTest ( cls = cls , label = get_label ( cls )): try : class_props = cls . INDIRECT_get_class_properties () except AttributeError : # The INDIRECT_get_class_properties() method # does not support inverse properties. Build # class_props manually... class_props = set () for c in cls . mro (): if hasattr ( c , 'is_a' ): class_props . update ( [ r . property for r in c . is_a if isinstance ( r , owlready2 . Restriction )]) self . assertIn ( self . onto . hasPhysicalDimension , class_props , msg = cls )","title":"test_physical_quantity_dimension()"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestFunctionalEMMOConventions.test_quantity_dimension","text":"Check that all quantities have a physicalDimension annotation. Note: this test will be deprecated when isq is moved to emmo/domain. Configurations exceptions - full class names of classes to ignore. Source code in emmopy/emmocheck.py def test_quantity_dimension ( self ): \"\"\"Check that all quantities have a physicalDimension annotation. Note: this test will be deprecated when isq is moved to emmo/domain. Configurations: exceptions - full class names of classes to ignore. \"\"\" exceptions = set (( 'properties.ModelledQuantitativeProperty' , 'properties.MeasuredQuantitativeProperty' , 'properties.ConventionalQuantitativeProperty' , 'metrology.QuantitativeProperty' , 'metrology.Quantity' , 'metrology.OrdinalQuantity' , 'metrology.BaseQuantity' , 'metrology.PhysicalConstant' , 'metrology.PhysicalQuantity' , 'metrology.ExactConstant' , 'metrology.MeasuredConstant' , 'metrology.DerivedQuantity' , 'isq.ISQBaseQuantity' , 'isq.InternationalSystemOfQuantity' , 'isq.ISQDerivedQuantity' , 'isq.SIExactConstant' , 'emmo.ModelledQuantitativeProperty' , 'emmo.MeasuredQuantitativeProperty' , 'emmo.ConventionalQuantitativeProperty' , 'emmo.QuantitativeProperty' , 'emmo.Quantity' , 'emmo.OrdinalQuantity' , 'emmo.BaseQuantity' , 'emmo.PhysicalConstant' , 'emmo.PhysicalQuantity' , 'emmo.ExactConstant' , 'emmo.MeasuredConstant' , 'emmo.DerivedQuantity' , 'emmo.ISQBaseQuantity' , 'emmo.InternationalSystemOfQuantity' , 'emmo.ISQDerivedQuantity' , 'emmo.SIExactConstant' , 'emmo.NonSIUnits' , 'emmo.StandardizedPhysicalQuantity' , 'emmo.CategorizedPhysicalQuantity' , 'emmo.AtomicAndNuclear' , 'emmo.Defined' , 'emmo.Electromagnetic' , 'emmo.FrequentlyUsed' , 'emmo.PhysicoChemical' , 'emmo.ChemicalCompositionQuantity' , 'emmo.Universal' , )) if not hasattr ( self . onto , 'PhysicalQuantity' ): return exceptions . update ( self . get_config ( 'test_quantity_dimension.exceptions' , ())) regex = re . compile ( '^T([+-][1-9]|0) L([+-][1-9]|0) M([+-][1-9]|0) I([+-][1-9]|0) ' '(H|\u0398)([+-][1-9]|0) N([+-][1-9]|0) J([+-][1-9]|0)$' ) classes = set ( self . onto . classes ( self . check_imported )) for cls in self . onto . PhysicalQuantity . descendants (): if not self . check_imported and cls not in classes : continue if repr ( cls ) not in exceptions : with self . subTest ( cls = cls , label = get_label ( cls )): anno = cls . get_annotations () self . assertIn ( 'physicalDimension' , anno , msg = cls ) physdim = anno [ 'physicalDimension' ] . first () self . assertRegex ( physdim , regex , msg = cls )","title":"test_quantity_dimension()"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestFunctionalEMMOConventions.test_unit_dimension","text":"Check that all measurement units have a physical dimension. Configurations exceptions - full class names of classes to ignore. Source code in emmopy/emmocheck.py def test_unit_dimension ( self ): \"\"\"Check that all measurement units have a physical dimension. Configurations: exceptions - full class names of classes to ignore. \"\"\" exceptions = set (( 'metrology.MultipleUnit' , 'metrology.SubMultipleUnit' , 'metrology.OffSystemUnit' , 'metrology.PrefixedUnit' , 'metrology.NonPrefixedUnit' , 'metrology.SpecialUnit' , 'metrology.DerivedUnit' , 'metrology.BaseUnit' , 'metrology.UnitSymbol' , 'siunits.SICoherentDerivedUnit' , 'siunits.SINonCoherentDerivedUnit' , 'siunits.SISpecialUnit' , 'siunits.SICoherentUnit' , 'siunits.SIPrefixedUnit' , 'siunits.SIBaseUnit' , 'siunits.SIUnitSymbol' , 'siunits.SIUnit' , 'emmo.MultipleUnit' , 'emmo.SubMultipleUnit' , 'emmo.OffSystemUnit' , 'emmo.PrefixedUnit' , 'emmo.NonPrefixedUnit' , 'emmo.SpecialUnit' , 'emmo.DerivedUnit' , 'emmo.BaseUnit' , 'emmo.UnitSymbol' , 'emmo.SICoherentDerivedUnit' , 'emmo.SINonCoherentDerivedUnit' , 'emmo.SISpecialUnit' , 'emmo.SICoherentUnit' , 'emmo.SIPrefixedUnit' , 'emmo.SIBaseUnit' , 'emmo.SIUnitSymbol' , 'emmo.SIUnit' , )) if not hasattr ( self . onto , 'MeasurementUnit' ): return exceptions . update ( self . get_config ( 'test_unit_dimension.exceptions' , ())) regex = re . compile ( r '^(emmo|metrology).hasPhysicalDimension.some\\(.*\\)$' ) classes = set ( self . onto . classes ( self . check_imported )) for cls in self . onto . MeasurementUnit . descendants (): if not self . check_imported and cls not in classes : continue # Assume that actual units are not subclassed if not list ( cls . subclasses ()) and repr ( cls ) not in exceptions : with self . subTest ( cls = cls , label = get_label ( cls )): self . assertTrue ( any ( regex . match ( repr ( r )) for r in cls . get_indirect_is_a ()), msg = cls )","title":"test_unit_dimension()"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestSyntacticEMMOConventions","text":"Test syntactic EMMO conventions.","title":"TestSyntacticEMMOConventions"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestSyntacticEMMOConventions.test_class_label","text":"Check that class labels are CamelCase and valid identifiers. For CamelCase, we are currently only checking that the labels start with upper case. Source code in emmopy/emmocheck.py def test_class_label ( self ): \"\"\"Check that class labels are CamelCase and valid identifiers. For CamelCase, we are currently only checking that the labels start with upper case. \"\"\" exceptions = set (( '0-manifold' , # not needed in 1.0.0-beta '1-manifold' , '2-manifold' , '3-manifold' , 'C++' , )) exceptions . update ( self . get_config ( 'test_class_label.exceptions' , ())) for cls in self . onto . classes ( self . check_imported ): for label in cls . label + getattr ( cls , 'prefLabel' , []): if label not in exceptions : with self . subTest ( entity = cls , label = label ): self . assertTrue ( label . isidentifier ()) self . assertTrue ( label [ 0 ] . isupper ())","title":"test_class_label()"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestSyntacticEMMOConventions.test_number_of_labels","text":"Check that all entities have one and only one prefLabel. Use \"altLabel\" for synonyms. The only allowed exception is entities who's representation starts with \"owl.\". Source code in emmopy/emmocheck.py def test_number_of_labels ( self ): \"\"\"Check that all entities have one and only one prefLabel. Use \"altLabel\" for synonyms. The only allowed exception is entities who's representation starts with \"owl.\". \"\"\" exceptions = set (( 'terms.license' , 'terms.abstract' , 'terms.contributor' , 'terms.creator' , 'terms.publisher' , 'terms.title' , 'core.prefLabel' , 'core.altLabel' , 'core.hiddenLabel' , )) exceptions . update ( self . get_config ( 'test_number_of_labels.exceptions' , ())) if 'prefLabel' in self . onto . world . _props : for e in self . onto . get_entities (): if repr ( e ) not in exceptions : with self . subTest ( entity = e , label = get_label ( e ), prefLabels = e . prefLabel ): if not repr ( e ) . startswith ( 'owl.' ): self . assertTrue ( hasattr ( e , 'prefLabel' )) self . assertEqual ( 1 , len ( e . prefLabel )) else : self . fail ( 'ontology has no prefLabel' )","title":"test_number_of_labels()"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.TestSyntacticEMMOConventions.test_object_property_label","text":"Check that object property labels are lowerCamelCase. Allowed exceptions: \"EMMORelation\" If they start with \"has\" or \"is\" they should be followed by a upper case letter. If they start with \"is\" they should also end with \"Of\". Source code in emmopy/emmocheck.py def test_object_property_label ( self ): \"\"\"Check that object property labels are lowerCamelCase. Allowed exceptions: \"EMMORelation\" If they start with \"has\" or \"is\" they should be followed by a upper case letter. If they start with \"is\" they should also end with \"Of\". \"\"\" exceptions = set (( 'EMMORelation' , )) exceptions . update ( self . get_config ( 'test_object_property_label.exceptions' , ())) for op in self . onto . object_properties (): if repr ( op ) not in exceptions : for label in op . label : with self . subTest ( entity = op , label = label ): self . assertTrue ( label [ 0 ] . islower (), 'label start with lowercase' ) if label . startswith ( 'has' ): self . assertTrue ( label [ 3 ] . isupper (), 'what follows \"has\" must be ' 'uppercase' ) if label . startswith ( 'is' ): self . assertTrue ( label [ 2 ] . isupper (), 'what follows \"is\" must be ' 'uppercase' ) self . assertTrue ( label . endswith (( 'Of' , 'With' )), 'should end with \"Of\" or \"With\"' )","title":"test_object_property_label()"},{"location":"api_reference/emmopy/emmocheck/#emmopy.emmocheck.main","text":"Run all checks on ontology iri . Default is 'http://emmo.info/emmo'. Source code in emmopy/emmocheck.py def main (): \"\"\"Run all checks on ontology `iri`. Default is 'http://emmo.info/emmo'. \"\"\" parser = argparse . ArgumentParser ( description = __doc__ ) parser . add_argument ( 'iri' , help = 'File name or URI to the ontology to test.' ) parser . add_argument ( '--database' , '-d' , metavar = 'FILENAME' , default = ':memory:' , help = 'Load ontology from Owlready2 sqlite3 database. The `iri` ' 'argument should in this case be the IRI of the ontology you ' 'want to check.' ) parser . add_argument ( '--local' , '-l' , action = 'store_true' , help = 'Load imported ontologies locally. Their paths are specified ' 'in Prot\u00e8g\u00e8 catalog files or via the --path option. The IRI should ' 'be a file name.' ) parser . add_argument ( '--catalog-file' , default = 'catalog-v001.xml' , help = 'Name of Prot\u00e8g\u00e8 catalog file in the same folder as the ' 'ontology. This option is used together with --local and ' 'defaults to \"catalog-v001.xml\".' ) parser . add_argument ( '--path' , action = 'append' , default = [], help = 'Paths where imported ontologies can be found. May be provided ' 'as a comma-separated string and/or with multiple --path options.' ) parser . add_argument ( '--check-imported' , '-i' , action = 'store_true' , help = 'Whether to check imported ontologies.' ) parser . add_argument ( '--verbose' , '-v' , action = 'store_true' , help = 'Verbosity level.' ) parser . add_argument ( '--configfile' , '-c' , help = 'A yaml file with additional test configurations.' ) parser . add_argument ( '--skip' , '-s' , action = 'append' , default = [], help = ( 'Shell pattern matching tests to skip. This option may be ' 'provided multiple times.' )) parser . add_argument ( '--enable' , '-e' , action = 'append' , default = [], help = ( 'Shell pattern matching tests to enable that have been ' 'skipped by default or in the config file. This option may ' 'be provided multiple times.' )) parser . add_argument ( # deprecated, replaced by --no-catalog '--url-from-catalog' , '-u' , default = None , action = 'store_true' , help = ( 'Get url from catalog file' )) parser . add_argument ( '--no-catalog' , action = 'store_false' , dest = 'url_from_catalog' , default = None , help = 'Whether to not read catalog file even if it exists.' ) parser . add_argument ( '--ignore-namespace' , '-n' , action = 'append' , default = [], help = ( 'Namespace to be ignored. Can be given multiple ' 'times' )) # Options to pass forward to unittest parser . add_argument ( '--buffer' , '-b' , dest = 'unittest' , action = 'append_const' , const = '-b' , help = ( 'The standard output and standard error streams are buffered ' 'during the test run. Output during a passing test is ' 'discarded. Output is echoed normally on test fail or error ' 'and is added to the failure messages.' )) parser . add_argument ( '--catch' , dest = 'unittest' , action = 'append_const' , const = '-c' , help = ( 'Control-C during the test run waits for the current test to ' 'end and then reports all the results so far. A second ' 'control-C raises the normal KeyboardInterrupt exception' )) parser . add_argument ( '--failfast' , '-f' , dest = 'unittest' , action = 'append_const' , const = '-f' , help = ( 'Stop the test run on the first error or failure.' )) try : args = parser . parse_args () sys . argv [ 1 :] = args . unittest if args . unittest else [] if args . verbose : sys . argv . append ( '-v' ) except SystemExit as e : os . _exit ( e . code ) # Exit without traceback on invalid arguments # Append to onto_path for paths in args . path : for path in paths . split ( ',' ): if path not in onto_path : onto_path . append ( path ) # Load ontology world = World ( filename = args . database ) if args . database != ':memory:' and args . iri not in world . ontologies : parser . error ( 'The IRI argument should be one of the ontologies in ' 'the database: \\n ' + ' \\n ' . join ( world . ontologies . keys ())) onto = world . get_ontology ( args . iri ) onto . load ( only_local = args . local , url_from_catalog = args . url_from_catalog , catalog_file = args . catalog_file ) # Store settings TestEMMOConventions TestEMMOConventions . onto = onto TestEMMOConventions . check_imported = args . check_imported TestEMMOConventions . ignore_namespace = args . ignore_namespace # Configure tests verbosity = 2 if args . verbose else 1 if args . configfile : import yaml with open ( args . configfile , 'rt' ) as f : TestEMMOConventions . config . update ( yaml . load ( f , Loader = yaml . SafeLoader )) # Run all subclasses of TestEMMOConventions as test suites status = 0 for cls in TestEMMOConventions . __subclasses__ (): suite = unittest . TestLoader () . loadTestsFromTestCase ( cls ) # Mark tests to be skipped for test in suite : name = test . id () . split ( '.' )[ - 1 ] skipped = set ([ # skipped by default 'test_namespace' , 'test_physical_quantity_dimension' , ]) msg = { name : 'skipped by default' for name in skipped } # enable/skip tests from config file for pattern in test . get_config ( 'enable' , ()): if fnmatch . fnmatchcase ( name , pattern ): skipped . remove ( name ) for pattern in test . get_config ( 'skip' , ()): if fnmatch . fnmatchcase ( name , pattern ): skipped . add ( name ) msg [ name ] = 'skipped from config file' # enable/skip from command line for pattern in args . enable : if fnmatch . fnmatchcase ( name , pattern ): skipped . remove ( name ) for pattern in args . skip : if fnmatch . fnmatchcase ( name , pattern ): skipped . add ( name ) msg [ name ] = 'skipped from command line' if name in skipped : setattr ( test , 'setUp' , lambda : test . skipTest ( msg . get ( name , '' ))) runner = TextTestRunner ( verbosity = verbosity ) runner . resultclass . checkmode = True result = runner . run ( suite ) if result . failures : status = 1 return status","title":"main()"},{"location":"api_reference/emmopy/emmopy/","text":"emmopy \u00b6 get_emmo ( inferred = True ) \u00b6 Returns the current version of emmo. Parameters: Name Type Description Default inferred Optional[bool] Whether to import the inferred version of emmo or not. Default is True. True Returns: Type Description Ontology The loaded emmo ontology. Source code in emmopy/emmopy.py def get_emmo ( inferred : Optional [ bool ] = True ) -> \"Ontology\" : \"\"\"Returns the current version of emmo. Args: inferred: Whether to import the inferred version of emmo or not. Default is True. Returns: The loaded emmo ontology. \"\"\" name = 'emmo-inferred' if inferred in [ True , None ] else 'emmo' return get_ontology ( name ) . load ()","title":"emmopy"},{"location":"api_reference/emmopy/emmopy/#emmopy","text":"","title":"emmopy"},{"location":"api_reference/emmopy/emmopy/#emmopy.emmopy.get_emmo","text":"Returns the current version of emmo. Parameters: Name Type Description Default inferred Optional[bool] Whether to import the inferred version of emmo or not. Default is True. True Returns: Type Description Ontology The loaded emmo ontology. Source code in emmopy/emmopy.py def get_emmo ( inferred : Optional [ bool ] = True ) -> \"Ontology\" : \"\"\"Returns the current version of emmo. Args: inferred: Whether to import the inferred version of emmo or not. Default is True. Returns: The loaded emmo ontology. \"\"\" name = 'emmo-inferred' if inferred in [ True , None ] else 'emmo' return get_ontology ( name ) . load ()","title":"get_emmo()"},{"location":"api_reference/ontopy/colortest/","text":"colortest \u00b6 ColourTextTestResult ( TestResult ) \u00b6 A test result class that prints colour formatted text results to a stream. Based on https://github.com/python/cpython/blob/3.3/Lib/unittest/runner.py addError ( self , test , err ) \u00b6 Called when an error has occurred. 'err' is a tuple of values as returned by sys.exc_info(). Source code in ontopy/colortest.py def addError ( self , test , err ): super ( ColourTextTestResult , self ) . addError ( test , err ) self . printResult ( 'E' , 'ERROR' , 'error' ) addExpectedFailure ( self , test , err ) \u00b6 Called when an expected failure/error occurred. Source code in ontopy/colortest.py def addExpectedFailure ( self , test , err ): super ( ColourTextTestResult , self ) . addExpectedFailure ( test , err ) self . printResult ( 'x' , 'expected failure' , 'expected' ) addFailure ( self , test , err ) \u00b6 Called when an error has occurred. 'err' is a tuple of values as returned by sys.exc_info(). Source code in ontopy/colortest.py def addFailure ( self , test , err ): super ( ColourTextTestResult , self ) . addFailure ( test , err ) self . printResult ( 'F' , 'FAIL' , 'fail' ) addSkip ( self , test , reason ) \u00b6 Called when a test is skipped. Source code in ontopy/colortest.py def addSkip ( self , test , reason ): super ( ColourTextTestResult , self ) . addSkip ( test , reason ) if self . checkmode : self . printResult ( 's' , 'skipped' , 'skip' ) else : self . printResult ( 's' , 'skipped {0!r} ' . format ( reason ), 'skip' ) addSuccess ( self , test ) \u00b6 Called when a test has completed successfully Source code in ontopy/colortest.py def addSuccess ( self , test ): super ( ColourTextTestResult , self ) . addSuccess ( test ) self . printResult ( '.' , 'ok' , 'success' ) addUnexpectedSuccess ( self , test ) \u00b6 Called when a test was expected to fail, but succeed. Source code in ontopy/colortest.py def addUnexpectedSuccess ( self , test ): super ( ColourTextTestResult , self ) . addUnexpectedSuccess ( test ) self . printResult ( 'u' , 'unexpected success' , 'unexpected' ) printErrors ( self ) \u00b6 Called by TestRunner after test run Source code in ontopy/colortest.py def printErrors ( self ): if self . dots or self . showAll : self . stream . writeln () self . printErrorList ( 'ERROR' , self . errors ) self . printErrorList ( 'FAIL' , self . failures ) startTest ( self , test ) \u00b6 Called when the given test is about to be run Source code in ontopy/colortest.py def startTest ( self , test ): super ( ColourTextTestResult , self ) . startTest ( test ) pos = 0 if self . showAll : if self . _test_class != test . __class__ : self . _test_class = test . __class__ title = self . getClassDescription ( test ) self . stream . writeln ( self . colours [ 'title' ]( title )) descr = self . getShortDescription ( test ) self . stream . write ( descr ) pos += len ( descr ) self . stream . write ( ' ' * ( 70 - pos )) # self.stream.write(' ' * (self._terminal.width - 10 - pos)) # self.stream.write(' ... ') self . stream . flush () ColourTextTestRunner ( TextTestRunner ) \u00b6 A test runner that uses colour in its output resultclass ( TestResult ) \u00b6 A test result class that prints colour formatted text results to a stream. Based on https://github.com/python/cpython/blob/3.3/Lib/unittest/runner.py addError ( self , test , err ) \u00b6 Called when an error has occurred. 'err' is a tuple of values as returned by sys.exc_info(). Source code in ontopy/colortest.py def addError ( self , test , err ): super ( ColourTextTestResult , self ) . addError ( test , err ) self . printResult ( 'E' , 'ERROR' , 'error' ) addExpectedFailure ( self , test , err ) \u00b6 Called when an expected failure/error occurred. Source code in ontopy/colortest.py def addExpectedFailure ( self , test , err ): super ( ColourTextTestResult , self ) . addExpectedFailure ( test , err ) self . printResult ( 'x' , 'expected failure' , 'expected' ) addFailure ( self , test , err ) \u00b6 Called when an error has occurred. 'err' is a tuple of values as returned by sys.exc_info(). Source code in ontopy/colortest.py def addFailure ( self , test , err ): super ( ColourTextTestResult , self ) . addFailure ( test , err ) self . printResult ( 'F' , 'FAIL' , 'fail' ) addSkip ( self , test , reason ) \u00b6 Called when a test is skipped. Source code in ontopy/colortest.py def addSkip ( self , test , reason ): super ( ColourTextTestResult , self ) . addSkip ( test , reason ) if self . checkmode : self . printResult ( 's' , 'skipped' , 'skip' ) else : self . printResult ( 's' , 'skipped {0!r} ' . format ( reason ), 'skip' ) addSuccess ( self , test ) \u00b6 Called when a test has completed successfully Source code in ontopy/colortest.py def addSuccess ( self , test ): super ( ColourTextTestResult , self ) . addSuccess ( test ) self . printResult ( '.' , 'ok' , 'success' ) addUnexpectedSuccess ( self , test ) \u00b6 Called when a test was expected to fail, but succeed. Source code in ontopy/colortest.py def addUnexpectedSuccess ( self , test ): super ( ColourTextTestResult , self ) . addUnexpectedSuccess ( test ) self . printResult ( 'u' , 'unexpected success' , 'unexpected' ) printErrors ( self ) \u00b6 Called by TestRunner after test run Source code in ontopy/colortest.py def printErrors ( self ): if self . dots or self . showAll : self . stream . writeln () self . printErrorList ( 'ERROR' , self . errors ) self . printErrorList ( 'FAIL' , self . failures ) startTest ( self , test ) \u00b6 Called when the given test is about to be run Source code in ontopy/colortest.py def startTest ( self , test ): super ( ColourTextTestResult , self ) . startTest ( test ) pos = 0 if self . showAll : if self . _test_class != test . __class__ : self . _test_class = test . __class__ title = self . getClassDescription ( test ) self . stream . writeln ( self . colours [ 'title' ]( title )) descr = self . getShortDescription ( test ) self . stream . write ( descr ) pos += len ( descr ) self . stream . write ( ' ' * ( 70 - pos )) # self.stream.write(' ' * (self._terminal.width - 10 - pos)) # self.stream.write(' ... ') self . stream . flush ()","title":"colortest"},{"location":"api_reference/ontopy/colortest/#colortest","text":"","title":"colortest"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestResult","text":"A test result class that prints colour formatted text results to a stream. Based on https://github.com/python/cpython/blob/3.3/Lib/unittest/runner.py","title":"ColourTextTestResult"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestResult.addError","text":"Called when an error has occurred. 'err' is a tuple of values as returned by sys.exc_info(). Source code in ontopy/colortest.py def addError ( self , test , err ): super ( ColourTextTestResult , self ) . addError ( test , err ) self . printResult ( 'E' , 'ERROR' , 'error' )","title":"addError()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestResult.addExpectedFailure","text":"Called when an expected failure/error occurred. Source code in ontopy/colortest.py def addExpectedFailure ( self , test , err ): super ( ColourTextTestResult , self ) . addExpectedFailure ( test , err ) self . printResult ( 'x' , 'expected failure' , 'expected' )","title":"addExpectedFailure()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestResult.addFailure","text":"Called when an error has occurred. 'err' is a tuple of values as returned by sys.exc_info(). Source code in ontopy/colortest.py def addFailure ( self , test , err ): super ( ColourTextTestResult , self ) . addFailure ( test , err ) self . printResult ( 'F' , 'FAIL' , 'fail' )","title":"addFailure()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestResult.addSkip","text":"Called when a test is skipped. Source code in ontopy/colortest.py def addSkip ( self , test , reason ): super ( ColourTextTestResult , self ) . addSkip ( test , reason ) if self . checkmode : self . printResult ( 's' , 'skipped' , 'skip' ) else : self . printResult ( 's' , 'skipped {0!r} ' . format ( reason ), 'skip' )","title":"addSkip()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestResult.addSuccess","text":"Called when a test has completed successfully Source code in ontopy/colortest.py def addSuccess ( self , test ): super ( ColourTextTestResult , self ) . addSuccess ( test ) self . printResult ( '.' , 'ok' , 'success' )","title":"addSuccess()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestResult.addUnexpectedSuccess","text":"Called when a test was expected to fail, but succeed. Source code in ontopy/colortest.py def addUnexpectedSuccess ( self , test ): super ( ColourTextTestResult , self ) . addUnexpectedSuccess ( test ) self . printResult ( 'u' , 'unexpected success' , 'unexpected' )","title":"addUnexpectedSuccess()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestResult.printErrors","text":"Called by TestRunner after test run Source code in ontopy/colortest.py def printErrors ( self ): if self . dots or self . showAll : self . stream . writeln () self . printErrorList ( 'ERROR' , self . errors ) self . printErrorList ( 'FAIL' , self . failures )","title":"printErrors()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestResult.startTest","text":"Called when the given test is about to be run Source code in ontopy/colortest.py def startTest ( self , test ): super ( ColourTextTestResult , self ) . startTest ( test ) pos = 0 if self . showAll : if self . _test_class != test . __class__ : self . _test_class = test . __class__ title = self . getClassDescription ( test ) self . stream . writeln ( self . colours [ 'title' ]( title )) descr = self . getShortDescription ( test ) self . stream . write ( descr ) pos += len ( descr ) self . stream . write ( ' ' * ( 70 - pos )) # self.stream.write(' ' * (self._terminal.width - 10 - pos)) # self.stream.write(' ... ') self . stream . flush ()","title":"startTest()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestRunner","text":"A test runner that uses colour in its output","title":"ColourTextTestRunner"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestRunner.resultclass","text":"A test result class that prints colour formatted text results to a stream. Based on https://github.com/python/cpython/blob/3.3/Lib/unittest/runner.py","title":"resultclass"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestRunner.resultclass.addError","text":"Called when an error has occurred. 'err' is a tuple of values as returned by sys.exc_info(). Source code in ontopy/colortest.py def addError ( self , test , err ): super ( ColourTextTestResult , self ) . addError ( test , err ) self . printResult ( 'E' , 'ERROR' , 'error' )","title":"addError()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestRunner.resultclass.addExpectedFailure","text":"Called when an expected failure/error occurred. Source code in ontopy/colortest.py def addExpectedFailure ( self , test , err ): super ( ColourTextTestResult , self ) . addExpectedFailure ( test , err ) self . printResult ( 'x' , 'expected failure' , 'expected' )","title":"addExpectedFailure()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestRunner.resultclass.addFailure","text":"Called when an error has occurred. 'err' is a tuple of values as returned by sys.exc_info(). Source code in ontopy/colortest.py def addFailure ( self , test , err ): super ( ColourTextTestResult , self ) . addFailure ( test , err ) self . printResult ( 'F' , 'FAIL' , 'fail' )","title":"addFailure()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestRunner.resultclass.addSkip","text":"Called when a test is skipped. Source code in ontopy/colortest.py def addSkip ( self , test , reason ): super ( ColourTextTestResult , self ) . addSkip ( test , reason ) if self . checkmode : self . printResult ( 's' , 'skipped' , 'skip' ) else : self . printResult ( 's' , 'skipped {0!r} ' . format ( reason ), 'skip' )","title":"addSkip()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestRunner.resultclass.addSuccess","text":"Called when a test has completed successfully Source code in ontopy/colortest.py def addSuccess ( self , test ): super ( ColourTextTestResult , self ) . addSuccess ( test ) self . printResult ( '.' , 'ok' , 'success' )","title":"addSuccess()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestRunner.resultclass.addUnexpectedSuccess","text":"Called when a test was expected to fail, but succeed. Source code in ontopy/colortest.py def addUnexpectedSuccess ( self , test ): super ( ColourTextTestResult , self ) . addUnexpectedSuccess ( test ) self . printResult ( 'u' , 'unexpected success' , 'unexpected' )","title":"addUnexpectedSuccess()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestRunner.resultclass.printErrors","text":"Called by TestRunner after test run Source code in ontopy/colortest.py def printErrors ( self ): if self . dots or self . showAll : self . stream . writeln () self . printErrorList ( 'ERROR' , self . errors ) self . printErrorList ( 'FAIL' , self . failures )","title":"printErrors()"},{"location":"api_reference/ontopy/colortest/#ontopy.colortest.ColourTextTestRunner.resultclass.startTest","text":"Called when the given test is about to be run Source code in ontopy/colortest.py def startTest ( self , test ): super ( ColourTextTestResult , self ) . startTest ( test ) pos = 0 if self . showAll : if self . _test_class != test . __class__ : self . _test_class = test . __class__ title = self . getClassDescription ( test ) self . stream . writeln ( self . colours [ 'title' ]( title )) descr = self . getShortDescription ( test ) self . stream . write ( descr ) pos += len ( descr ) self . stream . write ( ' ' * ( 70 - pos )) # self.stream.write(' ' * (self._terminal.width - 10 - pos)) # self.stream.write(' ... ') self . stream . flush ()","title":"startTest()"},{"location":"api_reference/ontopy/graph/","text":"graph \u00b6 A module for visualising ontologies using graphviz. OntoGraph \u00b6 Class for visualising an ontology. Parameters \u00b6 ontology : ontopy.Ontology instance Ontology to visualize. root : None | graph.ALL | string | owlready2.ThingClass instance Name or owlready2 entity of root node to plot subgraph below. If root is graph.ALL , all classes will be included in the subgraph. leafs : None | sequence A sequence of leaf node names for generating sub-graphs. entities : None | sequence A sequence of entities to add to the graph. relations : \"all\" | str | None | sequence Sequence of relations to visualise. If \"all\", means to include all relations. style : None | dict | \"default\" A dict mapping the name of the different graphical elements to dicts of dot graph attributes. Supported graphical elements include: - graphtype : \"Digraph\" | \"Graph\" - graph : graph attributes (G) - class : nodes for classes (N) - root : additional attributes for root nodes (N) - leaf : additional attributes for leaf nodes (N) - defined_class : nodes for defined classes (N) - class_construct : nodes for class constructs (N) - individual : nodes for invididuals (N) - object_property : nodes for object properties (N) - data_property : nodes for data properties (N) - annotation_property : nodes for annotation properties (N) - added_node : nodes added because addnodes is true (N) - isA : edges for isA relations (E) - not : edges for not class constructs (E) - equivalent_to : edges for equivalent_to relations (E) - disjoint_with : edges for disjoint_with relations (E) - inverse_of : edges for inverse_of relations (E) - default_relation : default edges relations and restrictions (E) - relations : dict of styles for different relations (E) - inverse : default edges for inverse relations (E) - default_dataprop : default edges for data properties (E) - nodes : attribute for individual nodes (N) - edges : attribute for individual edges (E) If style is None or \"default\", the default style is used. See https://www.graphviz.org/doc/info/attrs.html edgelabels : bool | dict Whether to add labels to the edges of the generated graph. It is also possible to provide a dict mapping the full labels (with cardinality stripped off for restrictions) to some abbriviations. addnodes : bool Whether to add missing target nodes in relations. addconstructs : bool Whether to add nodes representing class constructs. included_namespaces : sequence In combination with root , only include classes with one of the listed namespaces. If empty (the default), nothing is excluded. included_ontologies : sequence In combination with root , only include classes defined in one of the listed ontologies. If empty (default), nothing is excluded. parents : int Include parents levels of parents. excluded_nodes : None | sequence Sequence of labels of nodes to exclude. graph : None | pydot.Dot instance Graphviz Digraph object to plot into. If None, a new graph object is created using the keyword arguments. imported : bool Whether to include imported classes if entities is None. kwargs : Passed to graphviz.Digraph. add_branch ( self , root , leafs = None , include_leafs = True , strict_leafs = False , exclude = None , relations = 'isA' , edgelabels = True , addnodes = False , addconstructs = False , included_namespaces = (), included_ontologies = (), include_parents = 'closest' , ** attrs ) \u00b6 Adds branch under root ending at any entiry included in the sequence leafs . If include_leafs is true, leafs classes are also included. Source code in ontopy/graph.py def add_branch ( self , root , leafs = None , include_leafs = True , strict_leafs = False , exclude = None , relations = 'isA' , edgelabels = True , addnodes = False , addconstructs = False , included_namespaces = (), included_ontologies = (), include_parents = 'closest' , ** attrs ): \"\"\"Adds branch under `root` ending at any entiry included in the sequence `leafs`. If `include_leafs` is true, leafs classes are also included.\"\"\" if leafs is None : leafs = () classes = self . ontology . get_branch ( root = root , leafs = leafs , include_leafs = include_leafs , strict_leafs = strict_leafs , exclude = exclude ) classes = filter_classes ( classes , included_namespaces = included_namespaces , included_ontologies = included_ontologies ) nodeattrs = {} nodeattrs [ get_label ( root )] = self . style . get ( 'root' , {}) for leaf in leafs : nodeattrs [ get_label ( leaf )] = self . style . get ( 'leaf' , {}) self . add_entities ( entities = classes , relations = relations , edgelabels = edgelabels , addnodes = addnodes , addconstructs = addconstructs , nodeattrs = nodeattrs , ** attrs ) parents = self . ontology . get_ancestors ( classes , include = include_parents , strict = True ) if parents : for parent in parents : nodeattrs [ get_label ( parent )] = self . style . get ( 'parent_node' , {}) self . add_entities ( entities = parents , relations = relations , edgelabels = edgelabels , addnodes = addnodes , addconstructs = addconstructs , nodeattrs = nodeattrs , ** attrs ) add_class_construct ( self , c ) \u00b6 Adds class construct c and return its label. Source code in ontopy/graph.py def add_class_construct ( self , c ): \"\"\"Adds class construct `c` and return its label.\"\"\" self . add_node ( c , ** self . style . get ( 'class_construct' , {})) label = get_label ( c ) if isinstance ( c , owlready2 . Or ): for cls in c . Classes : clslabel = get_label ( cls ) if clslabel not in self . nodes and self . addnodes : self . add_node ( cls ) if clslabel in self . nodes : self . add_edge ( get_label ( cls ), 'isA' , label ) elif isinstance ( c , owlready2 . And ): for cls in c . Classes : clslabel = get_label ( cls ) if clslabel not in self . nodes and self . addnodes : self . add_node ( cls ) if clslabel in self . nodes : self . add_edge ( label , 'isA' , get_label ( cls )) elif isinstance ( c , owlready2 . Not ): clslabel = get_label ( c . Class ) if clslabel not in self . nodes and self . addnodes : self . add_node ( c . Class ) if clslabel in self . nodes : self . add_edge ( clslabel , 'not' , label ) # Neither and nor inverse constructs are return label add_edge ( self , subject , predicate , object , edgelabel = None , ** attrs ) \u00b6 Add edge corresponding for (subject, predicate, object) triplet. Source code in ontopy/graph.py def add_edge ( self , subject , predicate , object , edgelabel = None , ** attrs ): \"\"\"Add edge corresponding for ``(subject, predicate, object)`` triplet.\"\"\" subject = subject if isinstance ( subject , str ) else get_label ( subject ) predicate = predicate if isinstance ( predicate , str ) else get_label ( predicate ) object = object if isinstance ( object , str ) else get_label ( object ) if subject in self . excluded_nodes or object in self . excluded_nodes : return if not isinstance ( subject , str ) or not isinstance ( object , str ): raise TypeError ( '`subject` and `object` must be strings' ) if subject not in self . nodes : raise RuntimeError ( '`subject` \" %s \" must have been added' % subject ) if object not in self . nodes : raise RuntimeError ( '`object` \" %s \" must have been added' % object ) key = ( subject , predicate , object ) if key not in self . edges : if edgelabel is None : edgelabel = self . edgelabels if isinstance ( edgelabel , str ): label = edgelabel if isinstance ( edgelabel , dict ): label = edgelabel . get ( predicate , predicate ) elif edgelabel : label = predicate else : label = None kw = self . get_edge_attrs ( predicate , attrs = attrs ) self . dot . edge ( subject , object , label = label , ** kw ) self . edges . add ( key ) add_edges ( self , sources = None , relations = None , edgelabels = None , addnodes = None , addconstructs = None , ** attrs ) \u00b6 Adds all relations originating from entities sources who's type are listed in relations . If sources is None, edges are added between all current nodes. Source code in ontopy/graph.py def add_edges ( self , sources = None , relations = None , edgelabels = None , addnodes = None , addconstructs = None , ** attrs ): \"\"\"Adds all relations originating from entities `sources` who's type are listed in `relations`. If `sources` is None, edges are added between all current nodes.\"\"\" if sources is None : sources = self . nodes for source in sources . copy (): self . add_source_edges ( source , relations = relations , edgelabels = edgelabels , addnodes = addnodes , addconstructs = addconstructs , ** attrs ) add_entities ( self , entities = None , relations = 'isA' , edgelabels = True , addnodes = False , addconstructs = False , nodeattrs = None , ** attrs ) \u00b6 Adds a sequence of entities to the graph. If entities is None, all classes are added to the graph. nodeattrs is a dict mapping node names to are attributes for dedicated nodes. Source code in ontopy/graph.py def add_entities ( self , entities = None , relations = 'isA' , edgelabels = True , addnodes = False , addconstructs = False , nodeattrs = None , ** attrs ): \"\"\"Adds a sequence of entities to the graph. If `entities` is None, all classes are added to the graph. `nodeattrs` is a dict mapping node names to are attributes for dedicated nodes. \"\"\" if entities is None : entities = self . ontology . classes ( imported = self . imported ) self . add_nodes ( entities , nodeattrs = nodeattrs , ** attrs ) self . add_edges ( relations = relations , edgelabels = edgelabels , addnodes = addnodes , addconstructs = addconstructs , ** attrs ) add_legend ( self , relations = None ) \u00b6 Adds legend for specified relations to the graph. If relations is \"all\", the legend will contain all relations that are defined in the style. By default the legend will only contain relations that are currently included in the graph. Hence, you usually want to call add_legend() as the last method before saving or displaying. Source code in ontopy/graph.py def add_legend ( self , relations = None ): \"\"\"Adds legend for specified relations to the graph. If `relations` is \"all\", the legend will contain all relations that are defined in the style. By default the legend will only contain relations that are currently included in the graph. Hence, you usually want to call add_legend() as the last method before saving or displaying. \"\"\" rels = self . style . get ( 'relations' , {}) if relations is None : relations = self . get_relations ( sort = True ) elif relations == 'all' : relations = [ 'isA' ] + list ( rels . keys ()) + [ 'inverse' ] elif isinstance ( relations , str ): relations = relations . split ( ',' ) n = len ( relations ) if n == 0 : return t = ( '<<table border=\"0\" cellpadding=\"2\" cellspacing=\"0\" ' 'cellborder=\"0\">' ) label1 = [ t ] label2 = [ t ] for i , r in enumerate ( relations ): label1 . append ( '<tr><td align=\"right\" port=\"i %d \"> %s </td></tr>' % ( i , r )) label2 . append ( '<tr><td port=\"i %d \">&nbsp;</td></tr>' % i ) label1 . append ( '</table>>' ) label2 . append ( '</table>>' ) self . dot . node ( 'key1' , label = ' \\n ' . join ( label1 ), shape = 'plaintext' ) self . dot . node ( 'key2' , label = ' \\n ' . join ( label2 ), shape = 'plaintext' ) rankdir = self . dot . graph_attr . get ( 'rankdir' , 'TB' ) constraint = 'false' if rankdir in ( 'TB' , 'BT' ) else 'true' inv = True if rankdir in ( 'BT' , ) else False for i in range ( n ): r = relations [ n - 1 - i ] if inv else relations [ i ] if r == 'inverse' : kw = self . style . get ( 'inverse' , {}) . copy () else : kw = self . get_edge_attrs ( r , {}) . copy () kw [ 'constraint' ] = constraint with self . dot . subgraph ( name = 'sub %d ' % i ) as s : s . attr ( rank = 'same' ) if rankdir in ( 'BT' , 'LR' ): self . dot . edge ( 'key1:i %d :e' % i , 'key2:i %d :w' % i , ** kw ) else : self . dot . edge ( 'key2:i %d :w' % i , 'key1:i %d :e' % i , ** kw ) add_missing_node ( self , name , addnodes = None ) \u00b6 Checks if name corresponds to a missing node and add it if addnodes is true. Returns true if the node exists or is added, false otherwise. Source code in ontopy/graph.py def add_missing_node ( self , name , addnodes = None ): \"\"\"Checks if `name` corresponds to a missing node and add it if `addnodes` is true. Returns true if the node exists or is added, false otherwise.\"\"\" addnodes = self . addnodes if addnodes is None else addnodes e = self . ontology [ name ] if isinstance ( name , str ) else name label = get_label ( e ) if label not in self . nodes : if addnodes : self . add_node ( e , ** self . style . get ( 'added_node' , {})) else : return False return True add_node ( self , name , nodeattrs = None , ** attrs ) \u00b6 Add node with given name. attrs are graphviz node attributes. Source code in ontopy/graph.py def add_node ( self , name , nodeattrs = None , ** attrs ): \"\"\"Add node with given name. `attrs` are graphviz node attributes.\"\"\" e = self . ontology [ name ] if isinstance ( name , str ) else name label = get_label ( e ) if label not in self . nodes . union ( self . excluded_nodes ): kw = self . get_node_attrs ( e , nodeattrs = nodeattrs , attrs = attrs ) if hasattr ( e , 'iri' ): kw . setdefault ( 'URL' , e . iri ) self . dot . node ( label , label = label , ** kw ) self . nodes . add ( label ) add_nodes ( self , names , nodeattrs , ** attrs ) \u00b6 Add nodes with given names. attrs are graphviz node attributes. Source code in ontopy/graph.py def add_nodes ( self , names , nodeattrs , ** attrs ): \"\"\"Add nodes with given names. `attrs` are graphviz node attributes.\"\"\" for name in names : self . add_node ( name , nodeattrs = nodeattrs , ** attrs ) add_parents ( self , name , levels = 1 , relations = 'isA' , edgelabels = None , addnodes = False , addconstructs = False , ** attrs ) \u00b6 Add levels levels of strict parents of entity name . Source code in ontopy/graph.py def add_parents ( self , name , levels = 1 , relations = 'isA' , edgelabels = None , addnodes = False , addconstructs = False , ** attrs ): \"\"\"Add `levels` levels of strict parents of entity `name`.\"\"\" def addparents ( e , n , s ): if n > 0 : for p in e . get_parents ( strict = True ): s . add ( p ) addparents ( p , n - 1 , s ) e = self . ontology [ name ] if isinstance ( name , str ) else name parents = set () addparents ( e , levels , parents ) self . add_entities ( entities = parents , relations = relations , edgelabels = edgelabels , addnodes = addnodes , addconstructs = addconstructs , ** attrs ) add_source_edges ( self , source , relations = None , edgelabels = None , addnodes = None , addconstructs = None , ** attrs ) \u00b6 Adds all relations originating from entity source who's type are listed in relations . Source code in ontopy/graph.py def add_source_edges ( self , source , relations = None , edgelabels = None , addnodes = None , addconstructs = None , ** attrs ): \"\"\"Adds all relations originating from entity `source` who's type are listed in `relations`.\"\"\" if relations is None : relations = self . relations elif isinstance ( relations , str ): relations = set ([ relations ]) else : relations = set ( relations ) edgelabels = self . edgelabels if edgelabels is None else edgelabels addconstructs = ( self . addconstructs if addconstructs is None else addconstructs ) e = self . ontology [ source ] if isinstance ( source , str ) else source label = get_label ( e ) for r in e . is_a : # isA if isinstance ( r , ( owlready2 . ThingClass , owlready2 . ObjectPropertyClass )): if 'all' in relations or 'isA' in relations : rlabel = get_label ( r ) # FIXME - we actually want to include individuals... if isinstance ( e , owlready2 . Thing ): continue if r not in e . get_parents ( strict = True ): continue if not self . add_missing_node ( r , addnodes = addnodes ): continue self . add_edge ( subject = label , predicate = 'isA' , object = rlabel , edgelabel = edgelabels , ** attrs ) # restriction elif isinstance ( r , owlready2 . Restriction ): rname = get_label ( r . property ) if 'all' in relations or rname in relations : rlabel = ' %s %s ' % ( rname , typenames [ r . type ]) if isinstance ( r . value , owlready2 . ThingClass ): obj = get_label ( r . value ) if not self . add_missing_node ( r . value , addnodes ): continue elif ( isinstance ( r . value , owlready2 . ClassConstruct ) and self . addconstructs ): obj = self . add_class_construct ( r . value ) else : continue pred = asstring ( r , exclude_object = True ) self . add_edge ( label , pred , obj , edgelabel = edgelabels , ** attrs ) # inverse if isinstance ( r , owlready2 . Inverse ): if 'all' in relations or 'inverse' in relations : rlabel = get_label ( r ) if not self . add_missing_node ( r , addnodes = addnodes ): continue if r not in e . get_parents ( strict = True ): continue self . add_edge ( subject = label , predicate = 'inverse' , object = rlabel , edgelabel = edgelabels , ** attrs ) get_edge_attrs ( self , predicate , attrs ) \u00b6 Returns attributes for node or edge name . attrs overrides the default style. Source code in ontopy/graph.py def get_edge_attrs ( self , predicate , attrs ): \"\"\"Returns attributes for node or edge `name`. `attrs` overrides the default style.\"\"\" # given type types = ( 'isA' , 'equivalent_to' , 'disjoint_with' , 'inverse_of' ) if predicate in types : kw = self . style . get ( predicate , {}) . copy () else : kw = {} name = predicate . split ( None , 1 )[ 0 ] m = re . match ( r 'Inverse\\((.*)\\)' , name ) if m : name , = m . groups () attrs = attrs . copy () for k , v in self . style . get ( 'inverse' , {}) . items (): attrs . setdefault ( k , v ) if not isinstance ( name , str ) or name in self . ontology : e = self . ontology [ name ] if isinstance ( name , str ) else name relations = self . style . get ( 'relations' , {}) rels = set ( self . ontology [ r ] for r in relations . keys () if r in self . ontology ) for r in e . mro (): if r in rels : break rattrs = relations [ get_label ( r )] if r in rels else {} # object property if isinstance ( e , ( owlready2 . ObjectPropertyClass , owlready2 . ObjectProperty )): kw = self . style . get ( 'default_relation' , {}) . copy () kw . update ( rattrs ) # data property elif isinstance ( e , ( owlready2 . DataPropertyClass , owlready2 . DataProperty )): kw = self . style . get ( 'default_dataprop' , {}) . copy () kw . update ( rattrs ) else : raise TypeError ( 'Unknown entity type: %r ' % e ) kw . update ( self . style . get ( 'edges' , {}) . get ( predicate , {})) kw . update ( attrs ) return kw get_figsize ( self ) \u00b6 Returns the default figure size (width, height) in points. Source code in ontopy/graph.py def get_figsize ( self ): \"\"\"Returns the default figure size (width, height) in points.\"\"\" with tempfile . TemporaryDirectory () as tmpdir : tmpfile = os . path . join ( tmpdir , 'graph.svg' ) self . save ( tmpfile ) xml = ET . parse ( tmpfile ) svg = xml . getroot () width = svg . attrib [ 'width' ] height = svg . attrib [ 'height' ] assert width . endswith ( 'pt' ) # ensure that units are in points def asfloat ( s ): return float ( re . match ( r '^[\\d.]+' , s ) . group ()) return asfloat ( width ), asfloat ( height ) get_node_attrs ( self , name , nodeattrs , attrs ) \u00b6 Returns attributes for node or edge name . attrs overrides the default style. Source code in ontopy/graph.py def get_node_attrs ( self , name , nodeattrs , attrs ): \"\"\"Returns attributes for node or edge `name`. `attrs` overrides the default style.\"\"\" e = self . ontology [ name ] if isinstance ( name , str ) else name label = get_label ( e ) # class if isinstance ( e , owlready2 . ThingClass ): if self . ontology . is_defined ( e ): kw = self . style . get ( 'defined_class' , {}) else : kw = self . style . get ( 'class' , {}) # class construct elif isinstance ( e , owlready2 . ClassConstruct ): kw = self . style . get ( 'class_construct' , {}) # individual elif isinstance ( e , owlready2 . Thing ): kw = self . style . get ( 'individual' , {}) # object property elif isinstance ( e , owlready2 . ObjectPropertyClass ): kw = self . style . get ( 'object_property' , {}) # data property elif isinstance ( e , owlready2 . DataPropertyClass ): kw = self . style . get ( 'data_property' , {}) # annotation property elif isinstance ( e , owlready2 . AnnotationPropertyClass ): kw = self . style . get ( 'annotation_property' , {}) else : raise TypeError ( 'Unknown entity type: %r ' % e ) kw = kw . copy () kw . update ( self . style . get ( 'nodes' , {}) . get ( label , {})) if nodeattrs : kw . update ( nodeattrs . get ( label , {})) kw . update ( attrs ) return kw get_relations ( self , sort = True ) \u00b6 Returns a set of relations in current graph. If sort is true, a sorted list is returned. Source code in ontopy/graph.py def get_relations ( self , sort = True ): \"\"\"Returns a set of relations in current graph. If `sort` is true, a sorted list is returned.\"\"\" relations = set () for s , p , o in self . edges : if p . startswith ( 'Inverse' ): relations . add ( 'inverse' ) m = re . match ( r 'Inverse\\((.+)\\)' , p ) assert m relations . add ( m . groups ()[ 0 ]) else : relations . add ( p . split ( None , 1 )[ 0 ]) # Sort, but place 'isA' first and 'inverse' last if sort : start , end = [], [] if 'isA' in relations : relations . remove ( 'isA' ) start . append ( 'isA' ) if 'inverse' in relations : relations . remove ( 'inverse' ) end . append ( 'inverse' ) relations = start + sorted ( relations ) + end return relations save ( self , filename , format = None , ** kwargs ) \u00b6 Saves graph to filename . If format is not given, it is inferred from filename . Source code in ontopy/graph.py def save ( self , filename , format = None , ** kwargs ): \"\"\"Saves graph to `filename`. If format is not given, it is inferred from `filename`.\"\"\" base , ext = os . path . splitext ( filename ) if format is None : format = ext . lstrip ( '.' ) kwargs . setdefault ( 'cleanup' , True ) if format in ( 'graphviz' , 'gv' ): if 'dictionary' in kwargs : self . dot . save ( filename , dictionary = kwargs [ 'dictionary' ]) else : self . dot . save ( filename ) else : self . dot . render ( base , format = format , ** kwargs ) view ( self ) \u00b6 Shows the graph in a viewer. Source code in ontopy/graph.py def view ( self ): \"\"\"Shows the graph in a viewer.\"\"\" self . dot . view ( cleanup = True ) check_module_dependencies ( modules , verbose = True ) \u00b6 Check module dependencies and return a copy of modules with redundant dependencies removed. If verbose is true, warnings are printed for each module that If modules is given, it should be a dict returned by get_module_dependencies(). Source code in ontopy/graph.py def check_module_dependencies ( modules , verbose = True ): \"\"\"Check module dependencies and return a copy of modules with redundant dependencies removed. If `verbose` is true, warnings are printed for each module that If `modules` is given, it should be a dict returned by get_module_dependencies(). \"\"\" visited = set () def get_deps ( iri , excl = None ): \"\"\"Returns a set with all dependencies of `iri`, excluding `excl` and its dependencies.\"\"\" if iri in visited : return set () visited . add ( iri ) deps = set () for d in modules [ iri ]: if d != excl : deps . add ( d ) deps . update ( get_deps ( d )) return deps mods = {} redundant = [] for iri , deps in modules . items (): if not deps : mods [ iri ] = set () for dep in deps : if dep in get_deps ( iri , dep ): redundant . append (( iri , dep )) elif iri in mods : mods [ iri ] . add ( dep ) else : mods [ iri ] = set ([ dep ]) if redundant and verbose : print ( '** Warning: Redundant module dependency:' ) for iri , dep in redundant : print ( ' %s -> %s ' % ( iri , dep )) return mods cytoscapegraph ( graph , onto = None , infobox = None , style = None ) \u00b6 Returns and instance of icytoscape-figure for an instance Graph of OntoGraph, the accomanying ontology is required for mouse actions Source code in ontopy/graph.py def cytoscapegraph ( graph , onto = None , infobox = None , style = None ): \"\"\"Returns and instance of icytoscape-figure for an instance Graph of OntoGraph, the accomanying ontology is required for mouse actions\"\"\" from ipywidgets import Output , VBox , GridspecLayout from IPython.display import display , Image from pathlib import Path import networkx as nx import pydotplus import ipycytoscape from networkx.readwrite.json_graph import cytoscape_data # Define the styles, this has to be aligned with the graphviz values dotplus = pydotplus . graph_from_dot_data ( graph . dot . source ) # if graph doesn't have multiedges, use dotplus.set_strict(true) G = nx . nx_pydot . from_pydot ( dotplus ) colours , styles , fill = cytoscape_style () data = cytoscape_data ( G )[ 'elements' ] for d in data [ 'edges' ]: d [ 'data' ][ 'label' ] = d [ 'data' ][ 'label' ] . rsplit ( ' ' , 1 )[ 0 ] . lstrip ( '\"' ) lab = d [ 'data' ][ 'label' ] . replace ( 'Inverse(' , '' ) . rstrip ( ')' ) try : d [ 'data' ][ 'colour' ] = colours [ lab ] except KeyError : d [ 'data' ][ 'colour' ] = 'black' try : d [ 'data' ][ 'style' ] = styles [ lab ] except KeyError : d [ 'data' ][ 'style' ] = 'solid' if d [ 'data' ][ 'label' ] . startswith ( 'Inverse(' ): d [ 'data' ][ 'targetarrow' ] = 'diamond' d [ 'data' ][ 'sourcearrow' ] = 'none' else : d [ 'data' ][ 'targetarrow' ] = 'triangle' d [ 'data' ][ 'sourcearrow' ] = 'none' try : d [ 'data' ][ 'fill' ] = fill [ lab ] except KeyError : d [ 'data' ][ 'fill' ] = 'filled' cytofig = ipycytoscape . CytoscapeWidget () cytofig . graph . add_graph_from_json ( data , directed = True ) cytofig . set_style ([ { 'selector' : 'node' , 'css' : { 'content' : 'data(label)' , # 'text-valign': 'center', # 'color': 'white', # 'text-outline-width': 2, # 'text-outline-color': 'red', 'background-color' : 'blue' }, }, { 'selector' : 'node:parent' , 'css' : { 'background-opacity' : 0.333 } }, { 'selector' : 'edge' , 'style' : { 'width' : 2 , 'line-color' : 'data(colour)' , # 'content': 'data(label)', 'line-style' : 'data(style)' } }, { 'selector' : 'edge.directed' , 'style' : { 'curve-style' : 'bezier' , 'target-arrow-shape' : 'data(targetarrow)' , 'target-arrow-color' : 'data(colour)' , 'target-arrow-fill' : 'data(fill)' , 'mid-source-arrow-shape' : 'data(sourcearrow)' , 'mid-source-arrow-color' : 'data(colour)' }, }, { 'selector' : 'edge.multiple_edges' , 'style' : { 'curve-style' : 'bezier' } }, { 'selector' : ':selected' , 'css' : { 'background-color' : 'black' , 'line-color' : 'black' , 'target-arrow-color' : 'black' , 'source-arrow-color' : 'black' , 'text-outline-color' : 'black' }, }, ]) if onto is not None : out = Output ( layout = { 'border' : '1px solid black' }) def log_clicks ( node ): with out : print (( onto . get_by_label ( node [ \"data\" ][ \"label\" ]))) p = onto . get_by_label ( node [ \"data\" ][ \"label\" ]) . get_parents () print ( f 'parents: { p } ' ) try : elucidation = onto . get_by_label ( node [ \"data\" ][ \"label\" ]) . elucidation print ( f 'elucidation: { elucidation [ 0 ] } ' ) except ( AttributeError , IndexError ): pass try : annotations = onto . get_by_label ( node [ \"data\" ][ \"label\" ]) . annotations for e in annotations : print ( f 'annotation: { e } ' ) except AttributeError : pass # Try does not work... try : iri = onto . get_by_label ( node [ \"data\" ][ \"label\" ]) . iri print ( f 'iri: { iri } ' ) except Exception : pass try : fig = node [ \"data\" ][ \"label\" ] if os . path . exists ( Path ( fig + '.png' )): display ( Image ( fig + '.png' , width = 100 )) elif os . path . exists ( Path ( fig + '.jpg' )): display ( Image ( fig + '.jpg' , width = 100 )) except Exception : # FIXME: make this more specific pass out . clear_output ( wait = True ) def log_mouseovers ( node ): with out : print ( onto . get_by_label ( node [ \"data\" ][ \"label\" ])) # print(f'mouseover: {pformat(node)}') out . clear_output ( wait = True ) cytofig . on ( 'node' , 'click' , log_clicks ) cytofig . on ( 'node' , 'mouseover' , log_mouseovers ) # , remove=True) cytofig . on ( 'node' , 'mouseout' , out . clear_output ( wait = True )) grid = GridspecLayout ( 1 , 3 , height = '400px' ) if infobox == 'left' : grid [ 0 , 0 ] = out grid [ 0 , 1 :] = cytofig elif infobox == 'right' : grid [ 0 , 0 : - 1 ] = cytofig grid [ 0 , 2 ] = out else : return VBox ([ cytofig , out ]) return grid return cytofig filter_classes ( classes , included_namespaces = (), included_ontologies = ()) \u00b6 Filter out classes whos namespace is not in included_namespaces or whos ontology name is not in one of the ontologies in included_ontologies . classes should be a sequence of classes. Source code in ontopy/graph.py def filter_classes ( classes , included_namespaces = (), included_ontologies = ()): \"\"\"Filter out classes whos namespace is not in `included_namespaces` or whos ontology name is not in one of the ontologies in `included_ontologies`. `classes` should be a sequence of classes. \"\"\" filtered = set ( classes ) if included_namespaces : filtered = set ( c for c in filtered if c . namespace . name in included_namespaces ) if included_ontologies : filtered = set ( c for c in filtered if c . namespace . ontology . name in included_ontologies ) return filtered get_module_dependencies ( iri_or_onto , strip_base = None ) \u00b6 Reads iri_or_onto and returns a dict mapping ontology names to a list of ontologies that they depends on. If strip_base is true, the base IRI is stripped from ontology names. If it is a string, it lstrip'ped from the base iri. Source code in ontopy/graph.py def get_module_dependencies ( iri_or_onto , strip_base = None ): \"\"\"Reads `iri_or_onto` and returns a dict mapping ontology names to a list of ontologies that they depends on. If `strip_base` is true, the base IRI is stripped from ontology names. If it is a string, it lstrip'ped from the base iri. \"\"\" if isinstance ( iri_or_onto , str ): onto = get_ontology ( iri_or_onto ) onto . load () else : onto = iri_or_onto modules = { onto . base_iri : set ()} def strip ( base_iri ): if isinstance ( strip_base , str ): return base_iri . lstrip ( strip_base ) elif strip_base : return base_iri . strip ( onto . base_iri ) else : return base_iri visited = set () def setmodules ( onto ): for o in onto . imported_ontologies : if onto . base_iri in modules : modules [ strip ( onto . base_iri )] . add ( strip ( o . base_iri )) else : modules [ strip ( onto . base_iri )] = set ([ strip ( o . base_iri )]) if o . base_iri not in modules : modules [ strip ( o . base_iri )] = set () if o not in visited : visited . add ( o ) setmodules ( o ) setmodules ( onto ) return modules plot_modules ( src , filename = None , format = None , show = False , strip_base = None , ignore_redundant = True ) \u00b6 Plot module dependency graph for src and return a graph object. Here src may be an IRI, a path the the ontology or a dict returned by get_module_dependencies(). If filename is given, write the graph to this file. If format is None, the output format is inferred from filename . If show is true, the graph is displayed. strip_base is passed on to get_module_dependencies() if src is not a dict. If ignore_redundant is true, redundant dependencies are not plotted. Source code in ontopy/graph.py def plot_modules ( src , filename = None , format = None , show = False , strip_base = None , ignore_redundant = True ): \"\"\"Plot module dependency graph for `src` and return a graph object. Here `src` may be an IRI, a path the the ontology or a dict returned by get_module_dependencies(). If `filename` is given, write the graph to this file. If `format` is None, the output format is inferred from `filename`. If `show` is true, the graph is displayed. `strip_base` is passed on to get_module_dependencies() if `src` is not a dict. If `ignore_redundant` is true, redundant dependencies are not plotted. \"\"\" if isinstance ( src , dict ): modules = src else : modules = get_module_dependencies ( src , strip_base = strip_base ) if ignore_redundant : modules = check_module_dependencies ( modules , verbose = False ) dot = graphviz . Digraph ( comment = 'Module dependencies' ) dot . attr ( rankdir = 'TB' ) dot . node_attr . update ( style = 'filled' , fillcolor = 'lightblue' , shape = 'box' , edgecolor = 'blue' ) dot . edge_attr . update ( arrowtail = 'open' , dir = 'back' ) for iri in modules . keys (): iriname = iri . split ( ':' , 1 )[ 1 ] dot . node ( iriname , label = iri , URL = iri ) for iri , deps in modules . items (): for dep in deps : iriname = iri . split ( ':' , 1 )[ 1 ] depname = dep . split ( ':' , 1 )[ 1 ] dot . edge ( depname , iriname ) if filename : base , ext = os . path . splitext ( filename ) if format is None : format = ext . lstrip ( '.' ) dot . render ( base , format = format , view = False , cleanup = True ) if show : dot . view ( cleanup = True ) return dot","title":"graph"},{"location":"api_reference/ontopy/graph/#graph","text":"A module for visualising ontologies using graphviz.","title":"graph"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph","text":"Class for visualising an ontology.","title":"OntoGraph"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph--parameters","text":"ontology : ontopy.Ontology instance Ontology to visualize. root : None | graph.ALL | string | owlready2.ThingClass instance Name or owlready2 entity of root node to plot subgraph below. If root is graph.ALL , all classes will be included in the subgraph. leafs : None | sequence A sequence of leaf node names for generating sub-graphs. entities : None | sequence A sequence of entities to add to the graph. relations : \"all\" | str | None | sequence Sequence of relations to visualise. If \"all\", means to include all relations. style : None | dict | \"default\" A dict mapping the name of the different graphical elements to dicts of dot graph attributes. Supported graphical elements include: - graphtype : \"Digraph\" | \"Graph\" - graph : graph attributes (G) - class : nodes for classes (N) - root : additional attributes for root nodes (N) - leaf : additional attributes for leaf nodes (N) - defined_class : nodes for defined classes (N) - class_construct : nodes for class constructs (N) - individual : nodes for invididuals (N) - object_property : nodes for object properties (N) - data_property : nodes for data properties (N) - annotation_property : nodes for annotation properties (N) - added_node : nodes added because addnodes is true (N) - isA : edges for isA relations (E) - not : edges for not class constructs (E) - equivalent_to : edges for equivalent_to relations (E) - disjoint_with : edges for disjoint_with relations (E) - inverse_of : edges for inverse_of relations (E) - default_relation : default edges relations and restrictions (E) - relations : dict of styles for different relations (E) - inverse : default edges for inverse relations (E) - default_dataprop : default edges for data properties (E) - nodes : attribute for individual nodes (N) - edges : attribute for individual edges (E) If style is None or \"default\", the default style is used. See https://www.graphviz.org/doc/info/attrs.html edgelabels : bool | dict Whether to add labels to the edges of the generated graph. It is also possible to provide a dict mapping the full labels (with cardinality stripped off for restrictions) to some abbriviations. addnodes : bool Whether to add missing target nodes in relations. addconstructs : bool Whether to add nodes representing class constructs. included_namespaces : sequence In combination with root , only include classes with one of the listed namespaces. If empty (the default), nothing is excluded. included_ontologies : sequence In combination with root , only include classes defined in one of the listed ontologies. If empty (default), nothing is excluded. parents : int Include parents levels of parents. excluded_nodes : None | sequence Sequence of labels of nodes to exclude. graph : None | pydot.Dot instance Graphviz Digraph object to plot into. If None, a new graph object is created using the keyword arguments. imported : bool Whether to include imported classes if entities is None. kwargs : Passed to graphviz.Digraph.","title":"Parameters"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_branch","text":"Adds branch under root ending at any entiry included in the sequence leafs . If include_leafs is true, leafs classes are also included. Source code in ontopy/graph.py def add_branch ( self , root , leafs = None , include_leafs = True , strict_leafs = False , exclude = None , relations = 'isA' , edgelabels = True , addnodes = False , addconstructs = False , included_namespaces = (), included_ontologies = (), include_parents = 'closest' , ** attrs ): \"\"\"Adds branch under `root` ending at any entiry included in the sequence `leafs`. If `include_leafs` is true, leafs classes are also included.\"\"\" if leafs is None : leafs = () classes = self . ontology . get_branch ( root = root , leafs = leafs , include_leafs = include_leafs , strict_leafs = strict_leafs , exclude = exclude ) classes = filter_classes ( classes , included_namespaces = included_namespaces , included_ontologies = included_ontologies ) nodeattrs = {} nodeattrs [ get_label ( root )] = self . style . get ( 'root' , {}) for leaf in leafs : nodeattrs [ get_label ( leaf )] = self . style . get ( 'leaf' , {}) self . add_entities ( entities = classes , relations = relations , edgelabels = edgelabels , addnodes = addnodes , addconstructs = addconstructs , nodeattrs = nodeattrs , ** attrs ) parents = self . ontology . get_ancestors ( classes , include = include_parents , strict = True ) if parents : for parent in parents : nodeattrs [ get_label ( parent )] = self . style . get ( 'parent_node' , {}) self . add_entities ( entities = parents , relations = relations , edgelabels = edgelabels , addnodes = addnodes , addconstructs = addconstructs , nodeattrs = nodeattrs , ** attrs )","title":"add_branch()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_class_construct","text":"Adds class construct c and return its label. Source code in ontopy/graph.py def add_class_construct ( self , c ): \"\"\"Adds class construct `c` and return its label.\"\"\" self . add_node ( c , ** self . style . get ( 'class_construct' , {})) label = get_label ( c ) if isinstance ( c , owlready2 . Or ): for cls in c . Classes : clslabel = get_label ( cls ) if clslabel not in self . nodes and self . addnodes : self . add_node ( cls ) if clslabel in self . nodes : self . add_edge ( get_label ( cls ), 'isA' , label ) elif isinstance ( c , owlready2 . And ): for cls in c . Classes : clslabel = get_label ( cls ) if clslabel not in self . nodes and self . addnodes : self . add_node ( cls ) if clslabel in self . nodes : self . add_edge ( label , 'isA' , get_label ( cls )) elif isinstance ( c , owlready2 . Not ): clslabel = get_label ( c . Class ) if clslabel not in self . nodes and self . addnodes : self . add_node ( c . Class ) if clslabel in self . nodes : self . add_edge ( clslabel , 'not' , label ) # Neither and nor inverse constructs are return label","title":"add_class_construct()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_edge","text":"Add edge corresponding for (subject, predicate, object) triplet. Source code in ontopy/graph.py def add_edge ( self , subject , predicate , object , edgelabel = None , ** attrs ): \"\"\"Add edge corresponding for ``(subject, predicate, object)`` triplet.\"\"\" subject = subject if isinstance ( subject , str ) else get_label ( subject ) predicate = predicate if isinstance ( predicate , str ) else get_label ( predicate ) object = object if isinstance ( object , str ) else get_label ( object ) if subject in self . excluded_nodes or object in self . excluded_nodes : return if not isinstance ( subject , str ) or not isinstance ( object , str ): raise TypeError ( '`subject` and `object` must be strings' ) if subject not in self . nodes : raise RuntimeError ( '`subject` \" %s \" must have been added' % subject ) if object not in self . nodes : raise RuntimeError ( '`object` \" %s \" must have been added' % object ) key = ( subject , predicate , object ) if key not in self . edges : if edgelabel is None : edgelabel = self . edgelabels if isinstance ( edgelabel , str ): label = edgelabel if isinstance ( edgelabel , dict ): label = edgelabel . get ( predicate , predicate ) elif edgelabel : label = predicate else : label = None kw = self . get_edge_attrs ( predicate , attrs = attrs ) self . dot . edge ( subject , object , label = label , ** kw ) self . edges . add ( key )","title":"add_edge()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_edges","text":"Adds all relations originating from entities sources who's type are listed in relations . If sources is None, edges are added between all current nodes. Source code in ontopy/graph.py def add_edges ( self , sources = None , relations = None , edgelabels = None , addnodes = None , addconstructs = None , ** attrs ): \"\"\"Adds all relations originating from entities `sources` who's type are listed in `relations`. If `sources` is None, edges are added between all current nodes.\"\"\" if sources is None : sources = self . nodes for source in sources . copy (): self . add_source_edges ( source , relations = relations , edgelabels = edgelabels , addnodes = addnodes , addconstructs = addconstructs , ** attrs )","title":"add_edges()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_entities","text":"Adds a sequence of entities to the graph. If entities is None, all classes are added to the graph. nodeattrs is a dict mapping node names to are attributes for dedicated nodes. Source code in ontopy/graph.py def add_entities ( self , entities = None , relations = 'isA' , edgelabels = True , addnodes = False , addconstructs = False , nodeattrs = None , ** attrs ): \"\"\"Adds a sequence of entities to the graph. If `entities` is None, all classes are added to the graph. `nodeattrs` is a dict mapping node names to are attributes for dedicated nodes. \"\"\" if entities is None : entities = self . ontology . classes ( imported = self . imported ) self . add_nodes ( entities , nodeattrs = nodeattrs , ** attrs ) self . add_edges ( relations = relations , edgelabels = edgelabels , addnodes = addnodes , addconstructs = addconstructs , ** attrs )","title":"add_entities()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_legend","text":"Adds legend for specified relations to the graph. If relations is \"all\", the legend will contain all relations that are defined in the style. By default the legend will only contain relations that are currently included in the graph. Hence, you usually want to call add_legend() as the last method before saving or displaying. Source code in ontopy/graph.py def add_legend ( self , relations = None ): \"\"\"Adds legend for specified relations to the graph. If `relations` is \"all\", the legend will contain all relations that are defined in the style. By default the legend will only contain relations that are currently included in the graph. Hence, you usually want to call add_legend() as the last method before saving or displaying. \"\"\" rels = self . style . get ( 'relations' , {}) if relations is None : relations = self . get_relations ( sort = True ) elif relations == 'all' : relations = [ 'isA' ] + list ( rels . keys ()) + [ 'inverse' ] elif isinstance ( relations , str ): relations = relations . split ( ',' ) n = len ( relations ) if n == 0 : return t = ( '<<table border=\"0\" cellpadding=\"2\" cellspacing=\"0\" ' 'cellborder=\"0\">' ) label1 = [ t ] label2 = [ t ] for i , r in enumerate ( relations ): label1 . append ( '<tr><td align=\"right\" port=\"i %d \"> %s </td></tr>' % ( i , r )) label2 . append ( '<tr><td port=\"i %d \">&nbsp;</td></tr>' % i ) label1 . append ( '</table>>' ) label2 . append ( '</table>>' ) self . dot . node ( 'key1' , label = ' \\n ' . join ( label1 ), shape = 'plaintext' ) self . dot . node ( 'key2' , label = ' \\n ' . join ( label2 ), shape = 'plaintext' ) rankdir = self . dot . graph_attr . get ( 'rankdir' , 'TB' ) constraint = 'false' if rankdir in ( 'TB' , 'BT' ) else 'true' inv = True if rankdir in ( 'BT' , ) else False for i in range ( n ): r = relations [ n - 1 - i ] if inv else relations [ i ] if r == 'inverse' : kw = self . style . get ( 'inverse' , {}) . copy () else : kw = self . get_edge_attrs ( r , {}) . copy () kw [ 'constraint' ] = constraint with self . dot . subgraph ( name = 'sub %d ' % i ) as s : s . attr ( rank = 'same' ) if rankdir in ( 'BT' , 'LR' ): self . dot . edge ( 'key1:i %d :e' % i , 'key2:i %d :w' % i , ** kw ) else : self . dot . edge ( 'key2:i %d :w' % i , 'key1:i %d :e' % i , ** kw )","title":"add_legend()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_missing_node","text":"Checks if name corresponds to a missing node and add it if addnodes is true. Returns true if the node exists or is added, false otherwise. Source code in ontopy/graph.py def add_missing_node ( self , name , addnodes = None ): \"\"\"Checks if `name` corresponds to a missing node and add it if `addnodes` is true. Returns true if the node exists or is added, false otherwise.\"\"\" addnodes = self . addnodes if addnodes is None else addnodes e = self . ontology [ name ] if isinstance ( name , str ) else name label = get_label ( e ) if label not in self . nodes : if addnodes : self . add_node ( e , ** self . style . get ( 'added_node' , {})) else : return False return True","title":"add_missing_node()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_node","text":"Add node with given name. attrs are graphviz node attributes. Source code in ontopy/graph.py def add_node ( self , name , nodeattrs = None , ** attrs ): \"\"\"Add node with given name. `attrs` are graphviz node attributes.\"\"\" e = self . ontology [ name ] if isinstance ( name , str ) else name label = get_label ( e ) if label not in self . nodes . union ( self . excluded_nodes ): kw = self . get_node_attrs ( e , nodeattrs = nodeattrs , attrs = attrs ) if hasattr ( e , 'iri' ): kw . setdefault ( 'URL' , e . iri ) self . dot . node ( label , label = label , ** kw ) self . nodes . add ( label )","title":"add_node()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_nodes","text":"Add nodes with given names. attrs are graphviz node attributes. Source code in ontopy/graph.py def add_nodes ( self , names , nodeattrs , ** attrs ): \"\"\"Add nodes with given names. `attrs` are graphviz node attributes.\"\"\" for name in names : self . add_node ( name , nodeattrs = nodeattrs , ** attrs )","title":"add_nodes()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_parents","text":"Add levels levels of strict parents of entity name . Source code in ontopy/graph.py def add_parents ( self , name , levels = 1 , relations = 'isA' , edgelabels = None , addnodes = False , addconstructs = False , ** attrs ): \"\"\"Add `levels` levels of strict parents of entity `name`.\"\"\" def addparents ( e , n , s ): if n > 0 : for p in e . get_parents ( strict = True ): s . add ( p ) addparents ( p , n - 1 , s ) e = self . ontology [ name ] if isinstance ( name , str ) else name parents = set () addparents ( e , levels , parents ) self . add_entities ( entities = parents , relations = relations , edgelabels = edgelabels , addnodes = addnodes , addconstructs = addconstructs , ** attrs )","title":"add_parents()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.add_source_edges","text":"Adds all relations originating from entity source who's type are listed in relations . Source code in ontopy/graph.py def add_source_edges ( self , source , relations = None , edgelabels = None , addnodes = None , addconstructs = None , ** attrs ): \"\"\"Adds all relations originating from entity `source` who's type are listed in `relations`.\"\"\" if relations is None : relations = self . relations elif isinstance ( relations , str ): relations = set ([ relations ]) else : relations = set ( relations ) edgelabels = self . edgelabels if edgelabels is None else edgelabels addconstructs = ( self . addconstructs if addconstructs is None else addconstructs ) e = self . ontology [ source ] if isinstance ( source , str ) else source label = get_label ( e ) for r in e . is_a : # isA if isinstance ( r , ( owlready2 . ThingClass , owlready2 . ObjectPropertyClass )): if 'all' in relations or 'isA' in relations : rlabel = get_label ( r ) # FIXME - we actually want to include individuals... if isinstance ( e , owlready2 . Thing ): continue if r not in e . get_parents ( strict = True ): continue if not self . add_missing_node ( r , addnodes = addnodes ): continue self . add_edge ( subject = label , predicate = 'isA' , object = rlabel , edgelabel = edgelabels , ** attrs ) # restriction elif isinstance ( r , owlready2 . Restriction ): rname = get_label ( r . property ) if 'all' in relations or rname in relations : rlabel = ' %s %s ' % ( rname , typenames [ r . type ]) if isinstance ( r . value , owlready2 . ThingClass ): obj = get_label ( r . value ) if not self . add_missing_node ( r . value , addnodes ): continue elif ( isinstance ( r . value , owlready2 . ClassConstruct ) and self . addconstructs ): obj = self . add_class_construct ( r . value ) else : continue pred = asstring ( r , exclude_object = True ) self . add_edge ( label , pred , obj , edgelabel = edgelabels , ** attrs ) # inverse if isinstance ( r , owlready2 . Inverse ): if 'all' in relations or 'inverse' in relations : rlabel = get_label ( r ) if not self . add_missing_node ( r , addnodes = addnodes ): continue if r not in e . get_parents ( strict = True ): continue self . add_edge ( subject = label , predicate = 'inverse' , object = rlabel , edgelabel = edgelabels , ** attrs )","title":"add_source_edges()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.get_edge_attrs","text":"Returns attributes for node or edge name . attrs overrides the default style. Source code in ontopy/graph.py def get_edge_attrs ( self , predicate , attrs ): \"\"\"Returns attributes for node or edge `name`. `attrs` overrides the default style.\"\"\" # given type types = ( 'isA' , 'equivalent_to' , 'disjoint_with' , 'inverse_of' ) if predicate in types : kw = self . style . get ( predicate , {}) . copy () else : kw = {} name = predicate . split ( None , 1 )[ 0 ] m = re . match ( r 'Inverse\\((.*)\\)' , name ) if m : name , = m . groups () attrs = attrs . copy () for k , v in self . style . get ( 'inverse' , {}) . items (): attrs . setdefault ( k , v ) if not isinstance ( name , str ) or name in self . ontology : e = self . ontology [ name ] if isinstance ( name , str ) else name relations = self . style . get ( 'relations' , {}) rels = set ( self . ontology [ r ] for r in relations . keys () if r in self . ontology ) for r in e . mro (): if r in rels : break rattrs = relations [ get_label ( r )] if r in rels else {} # object property if isinstance ( e , ( owlready2 . ObjectPropertyClass , owlready2 . ObjectProperty )): kw = self . style . get ( 'default_relation' , {}) . copy () kw . update ( rattrs ) # data property elif isinstance ( e , ( owlready2 . DataPropertyClass , owlready2 . DataProperty )): kw = self . style . get ( 'default_dataprop' , {}) . copy () kw . update ( rattrs ) else : raise TypeError ( 'Unknown entity type: %r ' % e ) kw . update ( self . style . get ( 'edges' , {}) . get ( predicate , {})) kw . update ( attrs ) return kw","title":"get_edge_attrs()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.get_figsize","text":"Returns the default figure size (width, height) in points. Source code in ontopy/graph.py def get_figsize ( self ): \"\"\"Returns the default figure size (width, height) in points.\"\"\" with tempfile . TemporaryDirectory () as tmpdir : tmpfile = os . path . join ( tmpdir , 'graph.svg' ) self . save ( tmpfile ) xml = ET . parse ( tmpfile ) svg = xml . getroot () width = svg . attrib [ 'width' ] height = svg . attrib [ 'height' ] assert width . endswith ( 'pt' ) # ensure that units are in points def asfloat ( s ): return float ( re . match ( r '^[\\d.]+' , s ) . group ()) return asfloat ( width ), asfloat ( height )","title":"get_figsize()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.get_node_attrs","text":"Returns attributes for node or edge name . attrs overrides the default style. Source code in ontopy/graph.py def get_node_attrs ( self , name , nodeattrs , attrs ): \"\"\"Returns attributes for node or edge `name`. `attrs` overrides the default style.\"\"\" e = self . ontology [ name ] if isinstance ( name , str ) else name label = get_label ( e ) # class if isinstance ( e , owlready2 . ThingClass ): if self . ontology . is_defined ( e ): kw = self . style . get ( 'defined_class' , {}) else : kw = self . style . get ( 'class' , {}) # class construct elif isinstance ( e , owlready2 . ClassConstruct ): kw = self . style . get ( 'class_construct' , {}) # individual elif isinstance ( e , owlready2 . Thing ): kw = self . style . get ( 'individual' , {}) # object property elif isinstance ( e , owlready2 . ObjectPropertyClass ): kw = self . style . get ( 'object_property' , {}) # data property elif isinstance ( e , owlready2 . DataPropertyClass ): kw = self . style . get ( 'data_property' , {}) # annotation property elif isinstance ( e , owlready2 . AnnotationPropertyClass ): kw = self . style . get ( 'annotation_property' , {}) else : raise TypeError ( 'Unknown entity type: %r ' % e ) kw = kw . copy () kw . update ( self . style . get ( 'nodes' , {}) . get ( label , {})) if nodeattrs : kw . update ( nodeattrs . get ( label , {})) kw . update ( attrs ) return kw","title":"get_node_attrs()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.get_relations","text":"Returns a set of relations in current graph. If sort is true, a sorted list is returned. Source code in ontopy/graph.py def get_relations ( self , sort = True ): \"\"\"Returns a set of relations in current graph. If `sort` is true, a sorted list is returned.\"\"\" relations = set () for s , p , o in self . edges : if p . startswith ( 'Inverse' ): relations . add ( 'inverse' ) m = re . match ( r 'Inverse\\((.+)\\)' , p ) assert m relations . add ( m . groups ()[ 0 ]) else : relations . add ( p . split ( None , 1 )[ 0 ]) # Sort, but place 'isA' first and 'inverse' last if sort : start , end = [], [] if 'isA' in relations : relations . remove ( 'isA' ) start . append ( 'isA' ) if 'inverse' in relations : relations . remove ( 'inverse' ) end . append ( 'inverse' ) relations = start + sorted ( relations ) + end return relations","title":"get_relations()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.save","text":"Saves graph to filename . If format is not given, it is inferred from filename . Source code in ontopy/graph.py def save ( self , filename , format = None , ** kwargs ): \"\"\"Saves graph to `filename`. If format is not given, it is inferred from `filename`.\"\"\" base , ext = os . path . splitext ( filename ) if format is None : format = ext . lstrip ( '.' ) kwargs . setdefault ( 'cleanup' , True ) if format in ( 'graphviz' , 'gv' ): if 'dictionary' in kwargs : self . dot . save ( filename , dictionary = kwargs [ 'dictionary' ]) else : self . dot . save ( filename ) else : self . dot . render ( base , format = format , ** kwargs )","title":"save()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.OntoGraph.view","text":"Shows the graph in a viewer. Source code in ontopy/graph.py def view ( self ): \"\"\"Shows the graph in a viewer.\"\"\" self . dot . view ( cleanup = True )","title":"view()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.check_module_dependencies","text":"Check module dependencies and return a copy of modules with redundant dependencies removed. If verbose is true, warnings are printed for each module that If modules is given, it should be a dict returned by get_module_dependencies(). Source code in ontopy/graph.py def check_module_dependencies ( modules , verbose = True ): \"\"\"Check module dependencies and return a copy of modules with redundant dependencies removed. If `verbose` is true, warnings are printed for each module that If `modules` is given, it should be a dict returned by get_module_dependencies(). \"\"\" visited = set () def get_deps ( iri , excl = None ): \"\"\"Returns a set with all dependencies of `iri`, excluding `excl` and its dependencies.\"\"\" if iri in visited : return set () visited . add ( iri ) deps = set () for d in modules [ iri ]: if d != excl : deps . add ( d ) deps . update ( get_deps ( d )) return deps mods = {} redundant = [] for iri , deps in modules . items (): if not deps : mods [ iri ] = set () for dep in deps : if dep in get_deps ( iri , dep ): redundant . append (( iri , dep )) elif iri in mods : mods [ iri ] . add ( dep ) else : mods [ iri ] = set ([ dep ]) if redundant and verbose : print ( '** Warning: Redundant module dependency:' ) for iri , dep in redundant : print ( ' %s -> %s ' % ( iri , dep )) return mods","title":"check_module_dependencies()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.cytoscapegraph","text":"Returns and instance of icytoscape-figure for an instance Graph of OntoGraph, the accomanying ontology is required for mouse actions Source code in ontopy/graph.py def cytoscapegraph ( graph , onto = None , infobox = None , style = None ): \"\"\"Returns and instance of icytoscape-figure for an instance Graph of OntoGraph, the accomanying ontology is required for mouse actions\"\"\" from ipywidgets import Output , VBox , GridspecLayout from IPython.display import display , Image from pathlib import Path import networkx as nx import pydotplus import ipycytoscape from networkx.readwrite.json_graph import cytoscape_data # Define the styles, this has to be aligned with the graphviz values dotplus = pydotplus . graph_from_dot_data ( graph . dot . source ) # if graph doesn't have multiedges, use dotplus.set_strict(true) G = nx . nx_pydot . from_pydot ( dotplus ) colours , styles , fill = cytoscape_style () data = cytoscape_data ( G )[ 'elements' ] for d in data [ 'edges' ]: d [ 'data' ][ 'label' ] = d [ 'data' ][ 'label' ] . rsplit ( ' ' , 1 )[ 0 ] . lstrip ( '\"' ) lab = d [ 'data' ][ 'label' ] . replace ( 'Inverse(' , '' ) . rstrip ( ')' ) try : d [ 'data' ][ 'colour' ] = colours [ lab ] except KeyError : d [ 'data' ][ 'colour' ] = 'black' try : d [ 'data' ][ 'style' ] = styles [ lab ] except KeyError : d [ 'data' ][ 'style' ] = 'solid' if d [ 'data' ][ 'label' ] . startswith ( 'Inverse(' ): d [ 'data' ][ 'targetarrow' ] = 'diamond' d [ 'data' ][ 'sourcearrow' ] = 'none' else : d [ 'data' ][ 'targetarrow' ] = 'triangle' d [ 'data' ][ 'sourcearrow' ] = 'none' try : d [ 'data' ][ 'fill' ] = fill [ lab ] except KeyError : d [ 'data' ][ 'fill' ] = 'filled' cytofig = ipycytoscape . CytoscapeWidget () cytofig . graph . add_graph_from_json ( data , directed = True ) cytofig . set_style ([ { 'selector' : 'node' , 'css' : { 'content' : 'data(label)' , # 'text-valign': 'center', # 'color': 'white', # 'text-outline-width': 2, # 'text-outline-color': 'red', 'background-color' : 'blue' }, }, { 'selector' : 'node:parent' , 'css' : { 'background-opacity' : 0.333 } }, { 'selector' : 'edge' , 'style' : { 'width' : 2 , 'line-color' : 'data(colour)' , # 'content': 'data(label)', 'line-style' : 'data(style)' } }, { 'selector' : 'edge.directed' , 'style' : { 'curve-style' : 'bezier' , 'target-arrow-shape' : 'data(targetarrow)' , 'target-arrow-color' : 'data(colour)' , 'target-arrow-fill' : 'data(fill)' , 'mid-source-arrow-shape' : 'data(sourcearrow)' , 'mid-source-arrow-color' : 'data(colour)' }, }, { 'selector' : 'edge.multiple_edges' , 'style' : { 'curve-style' : 'bezier' } }, { 'selector' : ':selected' , 'css' : { 'background-color' : 'black' , 'line-color' : 'black' , 'target-arrow-color' : 'black' , 'source-arrow-color' : 'black' , 'text-outline-color' : 'black' }, }, ]) if onto is not None : out = Output ( layout = { 'border' : '1px solid black' }) def log_clicks ( node ): with out : print (( onto . get_by_label ( node [ \"data\" ][ \"label\" ]))) p = onto . get_by_label ( node [ \"data\" ][ \"label\" ]) . get_parents () print ( f 'parents: { p } ' ) try : elucidation = onto . get_by_label ( node [ \"data\" ][ \"label\" ]) . elucidation print ( f 'elucidation: { elucidation [ 0 ] } ' ) except ( AttributeError , IndexError ): pass try : annotations = onto . get_by_label ( node [ \"data\" ][ \"label\" ]) . annotations for e in annotations : print ( f 'annotation: { e } ' ) except AttributeError : pass # Try does not work... try : iri = onto . get_by_label ( node [ \"data\" ][ \"label\" ]) . iri print ( f 'iri: { iri } ' ) except Exception : pass try : fig = node [ \"data\" ][ \"label\" ] if os . path . exists ( Path ( fig + '.png' )): display ( Image ( fig + '.png' , width = 100 )) elif os . path . exists ( Path ( fig + '.jpg' )): display ( Image ( fig + '.jpg' , width = 100 )) except Exception : # FIXME: make this more specific pass out . clear_output ( wait = True ) def log_mouseovers ( node ): with out : print ( onto . get_by_label ( node [ \"data\" ][ \"label\" ])) # print(f'mouseover: {pformat(node)}') out . clear_output ( wait = True ) cytofig . on ( 'node' , 'click' , log_clicks ) cytofig . on ( 'node' , 'mouseover' , log_mouseovers ) # , remove=True) cytofig . on ( 'node' , 'mouseout' , out . clear_output ( wait = True )) grid = GridspecLayout ( 1 , 3 , height = '400px' ) if infobox == 'left' : grid [ 0 , 0 ] = out grid [ 0 , 1 :] = cytofig elif infobox == 'right' : grid [ 0 , 0 : - 1 ] = cytofig grid [ 0 , 2 ] = out else : return VBox ([ cytofig , out ]) return grid return cytofig","title":"cytoscapegraph()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.filter_classes","text":"Filter out classes whos namespace is not in included_namespaces or whos ontology name is not in one of the ontologies in included_ontologies . classes should be a sequence of classes. Source code in ontopy/graph.py def filter_classes ( classes , included_namespaces = (), included_ontologies = ()): \"\"\"Filter out classes whos namespace is not in `included_namespaces` or whos ontology name is not in one of the ontologies in `included_ontologies`. `classes` should be a sequence of classes. \"\"\" filtered = set ( classes ) if included_namespaces : filtered = set ( c for c in filtered if c . namespace . name in included_namespaces ) if included_ontologies : filtered = set ( c for c in filtered if c . namespace . ontology . name in included_ontologies ) return filtered","title":"filter_classes()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.get_module_dependencies","text":"Reads iri_or_onto and returns a dict mapping ontology names to a list of ontologies that they depends on. If strip_base is true, the base IRI is stripped from ontology names. If it is a string, it lstrip'ped from the base iri. Source code in ontopy/graph.py def get_module_dependencies ( iri_or_onto , strip_base = None ): \"\"\"Reads `iri_or_onto` and returns a dict mapping ontology names to a list of ontologies that they depends on. If `strip_base` is true, the base IRI is stripped from ontology names. If it is a string, it lstrip'ped from the base iri. \"\"\" if isinstance ( iri_or_onto , str ): onto = get_ontology ( iri_or_onto ) onto . load () else : onto = iri_or_onto modules = { onto . base_iri : set ()} def strip ( base_iri ): if isinstance ( strip_base , str ): return base_iri . lstrip ( strip_base ) elif strip_base : return base_iri . strip ( onto . base_iri ) else : return base_iri visited = set () def setmodules ( onto ): for o in onto . imported_ontologies : if onto . base_iri in modules : modules [ strip ( onto . base_iri )] . add ( strip ( o . base_iri )) else : modules [ strip ( onto . base_iri )] = set ([ strip ( o . base_iri )]) if o . base_iri not in modules : modules [ strip ( o . base_iri )] = set () if o not in visited : visited . add ( o ) setmodules ( o ) setmodules ( onto ) return modules","title":"get_module_dependencies()"},{"location":"api_reference/ontopy/graph/#ontopy.graph.plot_modules","text":"Plot module dependency graph for src and return a graph object. Here src may be an IRI, a path the the ontology or a dict returned by get_module_dependencies(). If filename is given, write the graph to this file. If format is None, the output format is inferred from filename . If show is true, the graph is displayed. strip_base is passed on to get_module_dependencies() if src is not a dict. If ignore_redundant is true, redundant dependencies are not plotted. Source code in ontopy/graph.py def plot_modules ( src , filename = None , format = None , show = False , strip_base = None , ignore_redundant = True ): \"\"\"Plot module dependency graph for `src` and return a graph object. Here `src` may be an IRI, a path the the ontology or a dict returned by get_module_dependencies(). If `filename` is given, write the graph to this file. If `format` is None, the output format is inferred from `filename`. If `show` is true, the graph is displayed. `strip_base` is passed on to get_module_dependencies() if `src` is not a dict. If `ignore_redundant` is true, redundant dependencies are not plotted. \"\"\" if isinstance ( src , dict ): modules = src else : modules = get_module_dependencies ( src , strip_base = strip_base ) if ignore_redundant : modules = check_module_dependencies ( modules , verbose = False ) dot = graphviz . Digraph ( comment = 'Module dependencies' ) dot . attr ( rankdir = 'TB' ) dot . node_attr . update ( style = 'filled' , fillcolor = 'lightblue' , shape = 'box' , edgecolor = 'blue' ) dot . edge_attr . update ( arrowtail = 'open' , dir = 'back' ) for iri in modules . keys (): iriname = iri . split ( ':' , 1 )[ 1 ] dot . node ( iriname , label = iri , URL = iri ) for iri , deps in modules . items (): for dep in deps : iriname = iri . split ( ':' , 1 )[ 1 ] depname = dep . split ( ':' , 1 )[ 1 ] dot . edge ( depname , iriname ) if filename : base , ext = os . path . splitext ( filename ) if format is None : format = ext . lstrip ( '.' ) dot . render ( base , format = format , view = False , cleanup = True ) if show : dot . view ( cleanup = True ) return dot","title":"plot_modules()"},{"location":"api_reference/ontopy/nadict/","text":"nadict \u00b6 A nested dict with both attribute and item access. NA stands for Nested and Attribute. NADict \u00b6 A nested dict with both attribute and item access. It is intended to be used with keys that are valid Python identifiers. However, except for string keys containing a dot, there are actually no hard limitations. If a key equals an existing attribute name, attribute access is of cause not possible. Nested items can be accessed via a dot notation, as shown in the example below. Examples \u00b6 n = NADict(a=1, b=NADict(c=3, d=4)) n['a'] 1 n.a 1 n['b.c'] 3 n.b.c 3 n['b.e'] = 5 n.b.e 5 Attributes \u00b6 _dict : dict Dictionary holding the actial items. clear ( self ) \u00b6 Clear all keys. Source code in ontopy/nadict.py def clear ( self ): \"\"\"Clear all keys.\"\"\" self . _dict . clear () copy ( self ) \u00b6 Returns a deep copy of self. Source code in ontopy/nadict.py def copy ( self ): \"\"\"Returns a deep copy of self.\"\"\" return copy . deepcopy ( self ) fromkeys ( self , iterable , value = None ) staticmethod \u00b6 Returns a new NADict with keys from iterable and values set to value . Source code in ontopy/nadict.py @staticmethod def fromkeys ( self , iterable , value = None ): \"\"\"Returns a new NADict with keys from `iterable` and values set to `value`.\"\"\" n = NADict () for key in iterable : n [ key ] = value return n get ( self , key , default = None ) \u00b6 Returns the value for key if key is in self, else return default . Source code in ontopy/nadict.py def get ( self , key , default = None ): \"\"\"Returns the value for `key` if `key` is in self, else return `default`.\"\"\" if '.' in key : k1 , k2 = key . split ( '.' , 1 ) return self . _dict [ k1 ] . get ( k2 , default ) else : return self . _dict . get ( key , default ) items ( self , prefix = '' ) \u00b6 Returns an iterator over all items as (key, value) pairs. Source code in ontopy/nadict.py def items ( self , prefix = '' ): \"\"\"Returns an iterator over all items as (key, value) pairs.\"\"\" for k , v in self . _dict . items (): key = ' %s . %s ' % ( prefix , k ) if prefix else k if isinstance ( v , NADict ): yield from v . items ( key ) else : yield ( key , v ) keys ( self , prefix = '' ) \u00b6 Returns an iterator over all keys. Source code in ontopy/nadict.py def keys ( self , prefix = '' ): \"\"\"Returns an iterator over all keys.\"\"\" for k , v in self . _dict . items (): key = ' %s . %s ' % ( prefix , k ) if prefix else k if isinstance ( v , NADict ): yield from v . keys ( key ) else : yield key pop ( self , key , default = None ) \u00b6 Removed key and returns corresponding value. If key is not found, default is returned if given, otherwise KeyError is raised. Source code in ontopy/nadict.py def pop ( self , key , default = None ): \"\"\"Removed `key` and returns corresponding value. If `key` is not found, `default` is returned if given, otherwise KeyError is raised.\"\"\" if '.' in key : k1 , k2 = key . split ( '.' , 1 ) return self . _dict [ k1 ] . pop ( k2 , default ) else : return self . _dict . pop ( key , default ) popitem ( self , prefix = '' ) \u00b6 Removes and returns some (key, value). Raises KeyError if empty. Source code in ontopy/nadict.py def popitem ( self , prefix = '' ): \"\"\"Removes and returns some (key, value). Raises KeyError if empty.\"\"\" item = self . _dict . popitem () if isinstance ( item , NADict ): k , v = item item2 = item . popitem ( k ) self . _dict [ k ] = v return item2 else : k , v = self . _dict . popitem () key = ' %s . %s ' % ( prefix , k ) if prefix else k return ( key , v ) setdefault ( self , key , value = None ) \u00b6 Inserts key and value pair if key is not found. Returns the new value for key . Source code in ontopy/nadict.py def setdefault ( self , key , value = None ): \"\"\"Inserts `key` and `value` pair if key is not found. Returns the new value for `key`.\"\"\" if '.' in key : k1 , k2 = key . split ( '.' , 1 ) return self . _dict [ k1 ] . setdefault ( k2 , value ) else : return self . _dict . setdefault ( key , value ) update ( self , * args , ** kw ) \u00b6 Updates self with dict/iterable from args and keyword arguments from kw . Source code in ontopy/nadict.py def update ( self , * args , ** kw ): \"\"\"Updates self with dict/iterable from `args` and keyword arguments from `kw`.\"\"\" for arg in args : if hasattr ( arg , 'keys' ): for k in arg : self [ k ] = arg [ k ] else : for k , v in arg : self [ k ] = v for k , v in kw . items (): self [ k ] = v values ( self ) \u00b6 Returns a set-like providing a view of all style values. Source code in ontopy/nadict.py def values ( self ): \"\"\"Returns a set-like providing a view of all style values.\"\"\" return self . _dict . values ()","title":"nadict"},{"location":"api_reference/ontopy/nadict/#nadict","text":"A nested dict with both attribute and item access. NA stands for Nested and Attribute.","title":"nadict"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict","text":"A nested dict with both attribute and item access. It is intended to be used with keys that are valid Python identifiers. However, except for string keys containing a dot, there are actually no hard limitations. If a key equals an existing attribute name, attribute access is of cause not possible. Nested items can be accessed via a dot notation, as shown in the example below.","title":"NADict"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict--examples","text":"n = NADict(a=1, b=NADict(c=3, d=4)) n['a'] 1 n.a 1 n['b.c'] 3 n.b.c 3 n['b.e'] = 5 n.b.e 5","title":"Examples"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict--attributes","text":"_dict : dict Dictionary holding the actial items.","title":"Attributes"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.clear","text":"Clear all keys. Source code in ontopy/nadict.py def clear ( self ): \"\"\"Clear all keys.\"\"\" self . _dict . clear ()","title":"clear()"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.copy","text":"Returns a deep copy of self. Source code in ontopy/nadict.py def copy ( self ): \"\"\"Returns a deep copy of self.\"\"\" return copy . deepcopy ( self )","title":"copy()"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.fromkeys","text":"Returns a new NADict with keys from iterable and values set to value . Source code in ontopy/nadict.py @staticmethod def fromkeys ( self , iterable , value = None ): \"\"\"Returns a new NADict with keys from `iterable` and values set to `value`.\"\"\" n = NADict () for key in iterable : n [ key ] = value return n","title":"fromkeys()"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.get","text":"Returns the value for key if key is in self, else return default . Source code in ontopy/nadict.py def get ( self , key , default = None ): \"\"\"Returns the value for `key` if `key` is in self, else return `default`.\"\"\" if '.' in key : k1 , k2 = key . split ( '.' , 1 ) return self . _dict [ k1 ] . get ( k2 , default ) else : return self . _dict . get ( key , default )","title":"get()"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.items","text":"Returns an iterator over all items as (key, value) pairs. Source code in ontopy/nadict.py def items ( self , prefix = '' ): \"\"\"Returns an iterator over all items as (key, value) pairs.\"\"\" for k , v in self . _dict . items (): key = ' %s . %s ' % ( prefix , k ) if prefix else k if isinstance ( v , NADict ): yield from v . items ( key ) else : yield ( key , v )","title":"items()"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.keys","text":"Returns an iterator over all keys. Source code in ontopy/nadict.py def keys ( self , prefix = '' ): \"\"\"Returns an iterator over all keys.\"\"\" for k , v in self . _dict . items (): key = ' %s . %s ' % ( prefix , k ) if prefix else k if isinstance ( v , NADict ): yield from v . keys ( key ) else : yield key","title":"keys()"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.pop","text":"Removed key and returns corresponding value. If key is not found, default is returned if given, otherwise KeyError is raised. Source code in ontopy/nadict.py def pop ( self , key , default = None ): \"\"\"Removed `key` and returns corresponding value. If `key` is not found, `default` is returned if given, otherwise KeyError is raised.\"\"\" if '.' in key : k1 , k2 = key . split ( '.' , 1 ) return self . _dict [ k1 ] . pop ( k2 , default ) else : return self . _dict . pop ( key , default )","title":"pop()"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.popitem","text":"Removes and returns some (key, value). Raises KeyError if empty. Source code in ontopy/nadict.py def popitem ( self , prefix = '' ): \"\"\"Removes and returns some (key, value). Raises KeyError if empty.\"\"\" item = self . _dict . popitem () if isinstance ( item , NADict ): k , v = item item2 = item . popitem ( k ) self . _dict [ k ] = v return item2 else : k , v = self . _dict . popitem () key = ' %s . %s ' % ( prefix , k ) if prefix else k return ( key , v )","title":"popitem()"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.setdefault","text":"Inserts key and value pair if key is not found. Returns the new value for key . Source code in ontopy/nadict.py def setdefault ( self , key , value = None ): \"\"\"Inserts `key` and `value` pair if key is not found. Returns the new value for `key`.\"\"\" if '.' in key : k1 , k2 = key . split ( '.' , 1 ) return self . _dict [ k1 ] . setdefault ( k2 , value ) else : return self . _dict . setdefault ( key , value )","title":"setdefault()"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.update","text":"Updates self with dict/iterable from args and keyword arguments from kw . Source code in ontopy/nadict.py def update ( self , * args , ** kw ): \"\"\"Updates self with dict/iterable from `args` and keyword arguments from `kw`.\"\"\" for arg in args : if hasattr ( arg , 'keys' ): for k in arg : self [ k ] = arg [ k ] else : for k , v in arg : self [ k ] = v for k , v in kw . items (): self [ k ] = v","title":"update()"},{"location":"api_reference/ontopy/nadict/#ontopy.nadict.NADict.values","text":"Returns a set-like providing a view of all style values. Source code in ontopy/nadict.py def values ( self ): \"\"\"Returns a set-like providing a view of all style values.\"\"\" return self . _dict . values ()","title":"values()"},{"location":"api_reference/ontopy/ontodoc/","text":"ontodoc \u00b6 A module for documenting ontologies. DocPP \u00b6 Documentation pre-processor. It supports the following features: Comment lines %% Comment line... Insert header with given level %HEADER label [level=1] Insert figure with optional caption and width. filepath should be relative to basedir . If width is 0, no width will be specified. %FIGURE filepath [caption='' width=0px] Include other markdown files. Header levels may be up or down with shift %INCLUDE filepath [shift=0] Insert generated documentation for ontology entity. The header level may be set with header_level . %ENTITY name [header_level=3] Insert generated documentation for ontology branch name . Options: header_level: Header level. terminated: Whether to branch should be terminated at all branch names in the final document. include_leafs: Whether to include leaf. %BRANCH name [header_level=3 terminated=1 include_leafs=0 namespaces='' ontologies=''] Insert generated figure of ontology branch name . The figure is written to path . The default path is figdir / name , where figdir is given at class initiation. It is recommended to exclude the file extension from path . In this case, the default figformat will be used (and easily adjusted to the correct format required by the backend). leafs may be a comma- separated list of leaf node names. %BRANCHFIG name [path='' caption='' terminated=1 include_leafs=1 strict_leafs=1, width=0px leafs='' relations=all edgelabels=0 namespaces='' ontologies=''] This is a combination of the %HEADER and %BRANCHFIG directives. %BRANCHHEAD name [level=2 path='' caption='' terminated=1 include_leafs=1 width=0px leafs=''] This is a combination of the %HEADER, %BRANCHFIG and %BRANCH directives. It inserts documentation of branch name , with a header followed by a figure and then documentation of each element. %BRANCHDOC name [level=2 path='' title='' caption='' terminated=1 strict_leafs=1 width=0px leafs='' relations='all' rankdir='BT' legend=1 namespaces='' ontologies=''] Insert generated documentation for all entities of the given type. Valid values of type are: \"classes\", \"individuals\", \"object_properties\", \"data_properties\", \"annotations_properties\" %ALL type [header_level=3, namespaces='', ontologies=''] Insert generated figure of all entities of the given type. Valid values of type are: \"classes\", \"object_properties\" and \"data_properties\". %ALLFIG type Parameters \u00b6 template : str Input template. ontodoc : OntoDoc instance Instance of OntoDoc basedir : str Base directory for including relative file paths. figdir : str Default directory to store generated figures. figformat : str Default format for generated figures. figscale : float Default scaling of generated figures. maxwidth : float Maximum figure width. Figures larger than this will be rescaled. imported : bool Whether to include imported entities. copy ( self ) \u00b6 Returns a copy of self. Source code in ontopy/ontodoc.py def copy ( self ): \"\"\"Returns a copy of self.\"\"\" docpp = DocPP ( '' , self . ontodoc , self . basedir , figformat = self . figformat , figscale = self . figscale , maxwidth = self . maxwidth ) docpp . lines [:] = self . lines docpp . figdir = self . figdir return docpp get_branches ( self ) \u00b6 Returns a list with all branch names as specified with %BRANCH (in current and all included documents). The returned value is cached for efficiency purposes and so that it is not lost after processing branches. Source code in ontopy/ontodoc.py def get_branches ( self ): \"\"\"Returns a list with all branch names as specified with %BRANCH (in current and all included documents). The returned value is cached for efficiency purposes and so that it is not lost after processing branches.\"\"\" if self . _branch_cache is None : names = [] docpp = self . copy () docpp . process_includes () for line in docpp . lines : if line . startswith ( '%BRANCH' ): names . append ( shlex . split ( line )[ 1 ]) self . _branch_cache = names return self . _branch_cache get_buffer ( self ) \u00b6 Returns the current buffer. Source code in ontopy/ontodoc.py def get_buffer ( self ): \"\"\"Returns the current buffer.\"\"\" return ' \\n ' . join ( self . lines ) process ( self ) \u00b6 Perform all pre-processing steps. Source code in ontopy/ontodoc.py def process ( self ): \"\"\"Perform all pre-processing steps.\"\"\" if not self . _processed : self . process_comments () self . process_headers () self . process_figures () self . process_entities () self . process_branches () self . process_branchfigs () self . process_branchdocs () self . process_alls () self . process_allfig () self . process_includes () self . _processed = True process_allfig ( self ) \u00b6 Process all %ALLFIG directives. Source code in ontopy/ontodoc.py def process_allfig ( self ): \"\"\"Process all %ALLFIG directives.\"\"\" onto = self . ontodoc . onto for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%ALLFIG ' ): tokens = shlex . split ( line ) type = tokens [ 1 ] opts = get_options ( tokens [ 2 :], path = '' , level = 3 , terminated = 0 , include_leafs = 1 , strict_leafs = 1 , width = 0 , leafs = '' , relations = 'isA' , edgelabels = 0 , rankdir = 'BT' , legend = 1 , namespaces = '' , ontologies = '' ) if type == 'classes' : roots = onto . get_root_classes ( imported = self . imported ) elif type in ( 'object_properties' , 'relations' ): roots = onto . get_root_object_properties ( imported = self . imported ) elif type == 'data_properties' : roots = onto . get_root_data_properties ( imported = self . imported ) else : raise InvalidTemplateError ( 'Invalid argument to %% ALLFIG: %s ' % type ) included_namespaces = opts . namespaces . split ( ',' ) if opts . namespaces else () included_ontologies = opts . ontologies . split ( ',' ) if opts . ontologies else () sec = [] for root in roots : name = asstring ( root ) filepath , leafs , width = self . _make_branchfig ( name , opts . path , opts . terminated , opts . include_leafs , opts . strict_leafs , opts . width , opts . leafs , opts . relations , opts . edgelabels , opts . rankdir , opts . legend , included_namespaces , included_ontologies ) title = 'Taxonomy of %s .' % name sec . append ( self . ontodoc . get_header ( title , int ( opts . level ))) caption = 'Taxonomy of %s .' % name sec . extend ( self . ontodoc . get_figure ( filepath , caption = caption , width = width ) . split ( ' \\n ' )) del self . lines [ i ] self . lines [ i : i ] = sec process_alls ( self ) \u00b6 Expand all %ALL specifications. Source code in ontopy/ontodoc.py def process_alls ( self ): \"\"\"Expand all %ALL specifications.\"\"\" onto = self . ontodoc . onto for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%ALL ' ): tokens = shlex . split ( line ) type = tokens [ 1 ] opts = get_options ( tokens [ 2 :], header_level = 3 ) if type == 'classes' : items = onto . classes ( imported = self . imported ) elif type in ( 'object_properties' , 'relations' ): items = onto . object_properties ( imported = self . imported ) elif type == 'data_properties' : items = onto . data_properties ( imported = self . imported ) elif type == 'annotation_properties' : items = onto . annotation_properties ( imported = self . imported ) elif type == 'individuals' : items = onto . individuals ( imported = self . imported ) else : raise InvalidTemplateError ( 'Invalid argument to %% ALL: %s ' % type ) items = sorted ( items , key = lambda x : asstring ( x )) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . itemsdoc ( items , int ( opts . header_level )) . split ( ' \\n ' ) process_branchdocs ( self ) \u00b6 Process all %BRANCHDOC and %BRANCHEAD directives. Source code in ontopy/ontodoc.py def process_branchdocs ( self ): \"\"\"Process all %BRANCHDOC and %BRANCHEAD directives.\"\"\" onto = self . ontodoc . onto for i , line in reversed ( list ( enumerate ( self . lines ))): if ( line . startswith ( '%BRANCHDOC ' ) or line . startswith ( '%BRANCHHEAD ' )): with_branch = True if line . startswith ( '%BRANCHDOC ' ) else False tokens = shlex . split ( line ) name = tokens [ 1 ] title = camelsplit ( name ) title = title [ 0 ] . upper () + title [ 1 :] + ' branch' opts = get_options ( tokens [ 2 :], level = 2 , path = '' , title = title , caption = title + '.' , terminated = 1 , strict_leafs = 1 , width = 0 , leafs = '' , relations = 'all' , edgelabels = 0 , rankdir = 'BT' , legend = 1 , namespaces = '' , ontologies = '' ) included_namespaces = opts . namespaces . split ( ',' ) if opts . namespaces else () included_ontologies = opts . ontologies . split ( ',' ) if opts . ontologies else () include_leafs = 1 filepath , leafs , width = self . _make_branchfig ( name , opts . path , opts . terminated , include_leafs , opts . strict_leafs , opts . width , opts . leafs , opts . relations , opts . edgelabels , opts . rankdir , opts . legend , included_namespaces , included_ontologies ) sec = [] sec . append ( self . ontodoc . get_header ( opts . title , int ( opts . level ))) sec . append ( self . ontodoc . get_figure ( filepath , caption = opts . caption , width = width )) if with_branch : include_leafs = 0 branch = filter_classes ( onto . get_branch ( name , leafs , include_leafs ), included_namespaces = included_namespaces , included_ontologies = included_ontologies ) sec . append ( self . ontodoc . itemsdoc ( branch , int ( opts . level + 1 ))) del self . lines [ i ] self . lines [ i : i ] = sec process_branches ( self ) \u00b6 Expand all %BRANCH specifications. Source code in ontopy/ontodoc.py def process_branches ( self ): \"\"\"Expand all %BRANCH specifications.\"\"\" onto = self . ontodoc . onto # Get all branch names in final document names = self . get_branches () for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%BRANCH ' ): tokens = shlex . split ( line ) name = tokens [ 1 ] opts = get_options ( tokens [ 2 :], header_level = 3 , terminated = 1 , include_leafs = 0 , namespaces = '' , ontologies = '' ) leafs = names if opts . terminated else () included_namespaces = opts . namespaces . split ( ',' ) if opts . namespaces else () included_ontologies = opts . ontologies . split ( ',' ) if opts . ontologies else () branch = filter_classes ( onto . get_branch ( name , leafs , opts . include_leafs ), included_namespaces = included_namespaces , included_ontologies = included_ontologies ) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . itemsdoc ( branch , int ( opts . header_level )) . split ( ' \\n ' ) process_branchfigs ( self ) \u00b6 Process all %BRANCHFIG directives. Source code in ontopy/ontodoc.py def process_branchfigs ( self ): \"\"\"Process all %BRANCHFIG directives.\"\"\" for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%BRANCHFIG ' ): tokens = shlex . split ( line ) name = tokens [ 1 ] opts = get_options ( tokens [ 2 :], path = '' , caption = '' , terminated = 1 , include_leafs = 1 , strict_leafs = 1 , width = 0 , leafs = '' , relations = 'all' , edgelabels = 0 , rankdir = 'BT' , legend = 1 , namespaces = '' , ontologies = '' ) included_namespaces = opts . namespaces . split ( ',' ) if opts . namespaces else () included_ontologies = opts . ontologies . split ( ',' ) if opts . ontologies else () filepath , leafs , width = self . _make_branchfig ( name , opts . path , opts . terminated , opts . include_leafs , opts . strict_leafs , opts . width , opts . leafs , opts . relations , opts . edgelabels , opts . rankdir , opts . legend , included_namespaces , included_ontologies ) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . get_figure ( filepath , caption = opts . caption , width = width ) . split ( ' \\n ' ) process_comments ( self ) \u00b6 Strips out comment lines starting with \"%%\". Source code in ontopy/ontodoc.py def process_comments ( self ): \"\"\"Strips out comment lines starting with \"%%\".\"\"\" self . lines = [ line for line in self . lines if not line . startswith ( ' %% ' )] process_entities ( self ) \u00b6 Expand all %ENTITY specifications. Source code in ontopy/ontodoc.py def process_entities ( self ): \"\"\"Expand all %ENTITY specifications.\"\"\" for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( ' %E NTITY ' ): tokens = shlex . split ( line ) name = tokens [ 1 ] opts = get_options ( tokens [ 2 :], header_level = 3 ) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . itemdoc ( name , int ( opts . header_level )) . split ( ' \\n ' ) process_figures ( self ) \u00b6 Expand all %FIGURE specifications. Source code in ontopy/ontodoc.py def process_figures ( self ): \"\"\"Expand all %FIGURE specifications.\"\"\" for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( ' %F IGURE ' ): tokens = shlex . split ( line ) path = tokens [ 1 ] opts = get_options ( tokens [ 2 :], caption = '' , width = 0 ) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . get_figure ( os . path . join ( self . basedir , path ), caption = opts . caption , width = opts . width ) . split ( ' \\n ' ) process_headers ( self ) \u00b6 Expand all %HEADER specifications. Source code in ontopy/ontodoc.py def process_headers ( self ): \"\"\"Expand all %HEADER specifications.\"\"\" for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%HEADER ' ): tokens = shlex . split ( line ) name = tokens [ 1 ] opts = get_options ( tokens [ 2 :], level = 1 ) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . get_header ( name , int ( opts . level )) . split ( ' \\n ' ) process_includes ( self ) \u00b6 Process all %INCLUDE directives. Source code in ontopy/ontodoc.py def process_includes ( self ): \"\"\"Process all %INCLUDE directives.\"\"\" for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%INCLUDE ' ): tokens = shlex . split ( line ) filepath = tokens [ 1 ] opts = get_options ( tokens [ 2 :], shift = 0 ) with open ( os . path . join ( self . basedir , filepath ), 'rt' ) as f : docpp = DocPP ( f . read (), self . ontodoc , basedir = os . path . dirname ( filepath ), figformat = self . figformat , figscale = self . figscale , maxwidth = self . maxwidth ) docpp . figdir = self . figdir if opts . shift : docpp . shift_header_levels ( int ( opts . shift )) docpp . process () del self . lines [ i ] self . lines [ i : i ] = docpp . lines shift_header_levels ( self , shift ) \u00b6 Shift header level of all hashtag-headers in buffer. Underline headers are ignored. Source code in ontopy/ontodoc.py def shift_header_levels ( self , shift ): \"\"\"Shift header level of all hashtag-headers in buffer. Underline headers are ignored.\"\"\" if not shift : return pat = re . compile ( '^#+ ' ) for i , line in enumerate ( self . lines ): m = pat . match ( line ) if m : if shift > 0 : self . lines [ i ] = '#' * shift + line elif shift < 0 : n = m . end () if shift > n : self . lines [ i ] = line . lstrip ( '# ' ) else : self . lines [ i ] = line [ n :] write ( self , outfile , format = None , pandoc_option_files = (), pandoc_options = (), genfile = None , verbose = True ) \u00b6 Writes documentation to outfile . Parameters \u00b6 outfile : str File that the documentation is written to. format : str Output format. If it is \"md\" or \"simple-html\", the built-in template generator is used. Otherwise pandoc is used. If not given, the format is inferred from the outfile name extension. pandoc_option_files : sequence Sequence with command line arguments provided to pandoc. pandoc_options : sequence Additional pandoc options overriding options read from pandoc_option_files . genfile : str Store temporary generated markdown input file to pandoc to this file (for debugging). verbose : bool Whether to show some messages when running pandoc. Source code in ontopy/ontodoc.py def write ( self , outfile , format = None , pandoc_option_files = (), pandoc_options = (), genfile = None , verbose = True ): \"\"\"Writes documentation to `outfile`. Parameters ---------- outfile : str File that the documentation is written to. format : str Output format. If it is \"md\" or \"simple-html\", the built-in template generator is used. Otherwise pandoc is used. If not given, the format is inferred from the `outfile` name extension. pandoc_option_files : sequence Sequence with command line arguments provided to pandoc. pandoc_options : sequence Additional pandoc options overriding options read from `pandoc_option_files`. genfile : str Store temporary generated markdown input file to pandoc to this file (for debugging). verbose : bool Whether to show some messages when running pandoc. \"\"\" self . process () content = self . get_buffer () substitutions = self . ontodoc . style . get ( 'substitutions' , []) for reg , sub in substitutions : content = re . sub ( reg , sub , content ) format = get_format ( outfile , format ) if format not in ( 'simple-html' , 'markdown' , 'md' ): # Run pandoc if not genfile : f = NamedTemporaryFile ( mode = 'w+t' , suffix = '.md' ) f . write ( content ) f . flush () genfile = f . name else : with open ( genfile , 'wt' ) as f : f . write ( content ) run_pandoc ( genfile , outfile , format , pandoc_option_files = pandoc_option_files , pandoc_options = pandoc_options , verbose = verbose ) else : if verbose : print ( 'Writing:' , outfile ) with open ( outfile , 'wt' ) as f : f . write ( content ) InvalidTemplateError ( NameError ) \u00b6 Raised on errors in template files. OntoDoc \u00b6 A class for helping documentating ontologies. Parameters \u00b6 onto : Ontology instance The ontology that should be documented. style : dict | \"html\" | \"markdown\" | \"markdown_tex\" A dict defining the following template strings (and substitutions): :header: Formats an header. Substitutions: {level}, {label} :link: Formats a link. Substitutions: {name} :point: Formats a point (list item). Substitutions: {point}, {ontology} :points: Formats a list of points. Used within annotations. Substitutions: {points}, {ontology} :annotation: Formats an annotation. Substitutions: {key}, {value}, {ontology} :substitutions: list of ``(regex, sub)`` pairs for substituting annotation values. get_default_template ( self ) \u00b6 Returns default template. Source code in ontopy/ontodoc.py def get_default_template ( self ): \"\"\"Returns default template.\"\"\" title = os . path . splitext ( os . path . basename ( self . onto . base_iri . rstrip ( '/#' )))[ 0 ] irilink = self . style . get ( 'link' , ' {name} ' ) . format ( name = self . onto . base_iri , url = self . onto . base_iri , lowerurl = self . onto . base_iri ) s = dedent ( ''' \\ %HEADER {title} Documentation of {irilink} %HEADER Relations level=2 %ALL object_properties %HEADER Classes level=2 %ALL classes %HEADER Individuals level=2 %ALL individuals %HEADER Appendix level=1 %HEADER \"Relation taxonomies\" level=2 %ALLFIG object_properties %HEADER \"Class taxonomies\" level=2 %ALLFIG classes ''' ) . format ( ontology = self . onto , title = title , irilink = irilink ) return s get_figure ( self , path , caption = '' , width = None ) \u00b6 Returns a formatted insert-figure-directive. Source code in ontopy/ontodoc.py def get_figure ( self , path , caption = '' , width = None ): \"\"\"Returns a formatted insert-figure-directive.\"\"\" figwidth_style = self . style . get ( 'figwidth' , '' ) figure_style = self . style . get ( 'figure' , '' ) figwidth = figwidth_style . format ( width = width ) if width else '' return figure_style . format ( path = path , caption = caption , figwidth = figwidth ) get_header ( self , label , header_level = 1 ) \u00b6 Returns label formatted as a header of given level. Source code in ontopy/ontodoc.py def get_header ( self , label , header_level = 1 ): \"\"\"Returns `label` formatted as a header of given level.\"\"\" header_style = self . style . get ( 'header' , ' {label} \\n ' ) return header_style . format ( '' , level = header_level , label = label , lowerlabel = label . lower ()) itemdoc ( self , item , header_level = 3 , show_disjoints = False ) \u00b6 Returns documentation of item . Parameters \u00b6 item : obj | label The class, individual or relation to document. header_level : int Header level. Defaults to 3. show_disjoints : Bool Whether to show disjoint_with relations. Source code in ontopy/ontodoc.py def itemdoc ( self , item , header_level = 3 , show_disjoints = False ): \"\"\"Returns documentation of `item`. Parameters ---------- item : obj | label The class, individual or relation to document. header_level : int Header level. Defaults to 3. show_disjoints : Bool Whether to show `disjoint_with` relations. \"\"\" onto = self . onto if isinstance ( item , str ): item = self . onto . get_by_label ( item ) header_style = self . style . get ( 'header' , ' {label} \\n ' ) link_style = self . style . get ( 'link' , ' {name} ' ) point_style = self . style . get ( 'point' , ' {point} ' ) points_style = self . style . get ( 'points' , ' {points} ' ) annotation_style = self . style . get ( 'annotation' , ' {key} : {value} \\n ' ) substitutions = self . style . get ( 'substitutions' , []) # Logical \"sorting\" of annotations order = dict ( definition = '00' , axiom = '01' , theorem = '02' , elucidation = '03' , domain = '04' , range = '05' , example = '06' ) doc = [] # Header label = get_label ( item ) doc . append ( header_style . format ( '' , level = header_level , label = label , lowerlabel = label . lower ())) # Add warning about missing prefLabel if not hasattr ( item , 'prefLabel' ) or not item . prefLabel . first (): doc . append ( annotation_style . format ( key = 'Warning' , value = 'Missing prefLabel' )) # Add iri doc . append ( annotation_style . format ( key = 'IRI' , value = asstring ( item . iri , link_style ), ontology = onto )) # Add annotations if isinstance ( item , owlready2 . Thing ): annotations = item . get_individual_annotations () else : annotations = item . get_annotations () for key in sorted ( annotations . keys (), key = lambda key : order . get ( key , key )): for value in annotations [ key ]: if self . url_regex . match ( value ): doc . append ( annotation_style . format ( key = key , value = asstring ( value , link_style ))) else : for reg , sub in substitutions : value = re . sub ( reg , sub , value ) doc . append ( annotation_style . format ( key = key , value = value )) # ...add relations from is_a points = [] nonProp = ( owlready2 . ThingClass , # owlready2.Restriction, owlready2 . And , owlready2 . Or , owlready2 . Not ) for p in item . is_a : if ( isinstance ( p , nonProp ) or ( isinstance ( item , owlready2 . PropertyClass ) and isinstance ( p , owlready2 . PropertyClass ))): points . append ( point_style . format ( point = 'is_a ' + asstring ( p , link_style ), ontology = onto )) else : points . append ( point_style . format ( point = asstring ( p , link_style ), ontology = onto )) # ...add equivalent_to relations for e in item . equivalent_to : points . append ( point_style . format ( point = 'equivalent_to ' + asstring ( e , link_style ))) # ...add disjoint_with relations if show_disjoints and hasattr ( item , 'disjoint_with' ): s = set ( item . disjoint_with ( reduce = True )) points . append ( point_style . format ( point = 'disjoint_with ' + ', ' . join ( asstring ( e , link_style ) for e in s ), ontology = onto )) # ...add disjoint_unions if hasattr ( item , 'disjoint_unions' ): for u in item . disjoint_unions : s = ', ' . join ( asstring ( e , link_style ) for e in u ) points . append ( point_style . format ( point = 'disjoint_union_of ' + s , ontology = onto )) # ...add inverse_of relations if hasattr ( item , 'inverse_property' ) and item . inverse_property : points . append ( point_style . format ( point = 'inverse_of ' + asstring ( item . inverse_property , link_style ))) # ...add domain restrictions for d in getattr ( item , 'domain' , ()): points . append ( point_style . format ( point = 'domain ' + asstring ( d , link_style ))) # ...add range restrictions for d in getattr ( item , 'range' , ()): points . append ( point_style . format ( point = 'range ' + asstring ( d , link_style ))) # Add points (from is_a) if points : value = points_style . format ( points = '' . join ( points ), ontology = onto ) doc . append ( annotation_style . format ( key = 'Subclass of' , value = value , ontology = onto )) # Instances (individuals) if hasattr ( item , 'instances' ): points = [] for e in [ i for i in item . instances () if item in i . is_instance_of ]: points . append ( point_style . format ( point = asstring ( e , link_style ), ontology = onto )) if points : value = points_style . format ( points = '' . join ( points ), ontology = onto ) doc . append ( annotation_style . format ( key = 'Individuals' , value = value , ontology = onto )) return ' \\n ' . join ( doc ) itemsdoc ( self , items , header_level = 3 ) \u00b6 Returns documentation of items . Source code in ontopy/ontodoc.py def itemsdoc ( self , items , header_level = 3 ): \"\"\"Returns documentation of `items`.\"\"\" sep_style = self . style . get ( 'sep' , ' \\n ' ) doc = [] for item in items : doc . append ( self . itemdoc ( item , header_level )) doc . append ( sep_style . format ( ontology = self . onto )) return ' \\n ' . join ( doc ) attrdict ( dict ) \u00b6 A dict with attribute access. Note that methods like key() and update() may be overridden. append_pandoc_options ( options , updates ) \u00b6 Append updates to pandoc options options . Parameters \u00b6 options : sequence Sequence with initial Pandoc options. updates : sequence of str Sequence of strings of the form \"--longoption=value\", where longoption is a valid pandoc long option and value is the new value. The \"=value\" part is optional. Strings of the form \"no-longoption\" will filter out \"--longoption\" from `options`. Returns \u00b6 new_options : list Updated pandoc options. Source code in ontopy/ontodoc.py def append_pandoc_options ( options , updates ): \"\"\"Append `updates` to pandoc options `options`. Parameters ---------- options : sequence Sequence with initial Pandoc options. updates : sequence of str Sequence of strings of the form \"--longoption=value\", where ``longoption`` is a valid pandoc long option and ``value`` is the new value. The \"=value\" part is optional. Strings of the form \"no-longoption\" will filter out \"--longoption\" from `options`. Returns ------- new_options : list Updated pandoc options. \"\"\" # Valid pandoc options starting with \"--no-XXX\" no_options = set ( 'no-highlight' ) if not updates : return list ( options ) u = {} for s in updates : k , sep , v = s . partition ( '=' ) u [ k . lstrip ( '-' )] = v if sep else None filter_out = set ( k for k , v in u . items () if k . startswith ( 'no-' ) and k not in no_options ) _filter_out = set ( '--' + k [ 3 :] for k in filter_out ) new_options = [ opt for opt in options if opt . partition ( '=' )[ 0 ] not in _filter_out ] new_options . extend ([ '-- %s ' % k if v is None else '-- %s = %s ' % ( k , v ) for k , v in u . items () if k not in filter_out ]) return new_options get_docpp ( ontodoc , infile , figdir = 'genfigs' , figformat = 'png' , maxwidth = None , imported = False ) \u00b6 Read infile and return a new docpp instance. Source code in ontopy/ontodoc.py def get_docpp ( ontodoc , infile , figdir = 'genfigs' , figformat = 'png' , maxwidth = None , imported = False ): \"\"\"Read `infile` and return a new docpp instance.\"\"\" if infile : with open ( infile , 'rt' ) as f : template = f . read () basedir = os . path . dirname ( infile ) else : template = ontodoc . get_default_template () basedir = '.' docpp = DocPP ( template , ontodoc , basedir = basedir , figdir = figdir , figformat = figformat , maxwidth = maxwidth , imported = imported ) return docpp get_figformat ( format ) \u00b6 Infer preferred figure format from output format. Source code in ontopy/ontodoc.py def get_figformat ( format ): \"\"\"Infer preferred figure format from output format.\"\"\" if format == 'pdf' : figformat = 'pdf' # XXX elif 'html' in format : figformat = 'svg' else : figformat = 'png' return figformat get_format ( outfile , format = None ) \u00b6 Infer format from outfile and format. Source code in ontopy/ontodoc.py def get_format ( outfile , format = None ): \"\"\"Infer format from outfile and format.\"\"\" if format is None : format = os . path . splitext ( outfile )[ 1 ] if not format : format = 'html' if format . startswith ( '.' ): format = format [ 1 :] return format get_maxwidth ( format ) \u00b6 Infer preferred max figure width from output format. Source code in ontopy/ontodoc.py def get_maxwidth ( format ): \"\"\"Infer preferred max figure width from output format.\"\"\" if format == 'pdf' : maxwidth = 668 else : maxwidth = 1024 return maxwidth get_options ( opts , ** kw ) \u00b6 Returns a dict with options from the sequence opts with \"name=value\" pairs. Valid option names and default values are provided with the keyword arguments. Source code in ontopy/ontodoc.py def get_options ( opts , ** kw ): \"\"\"Returns a dict with options from the sequence `opts` with \"name=value\" pairs. Valid option names and default values are provided with the keyword arguments.\"\"\" d = attrdict ( kw ) for opt in opts : if '=' not in opt : raise InvalidTemplateError ( 'Missing \"=\" in template option: %r ' % opt ) name , value = opt . split ( '=' , 1 ) if name not in d : raise InvalidTemplateError ( 'Invalid template option: %r ' % name ) t = type ( d [ name ]) d [ name ] = t ( value ) return d get_style ( format ) \u00b6 Infer style from output format. Source code in ontopy/ontodoc.py def get_style ( format ): \"\"\"Infer style from output format.\"\"\" if format == 'simple-html' : style = 'html' elif format in ( 'tex' , 'latex' , 'pdf' ): style = 'markdown_tex' else : style = 'markdown' return style load_pandoc_option_file ( yamlfile ) \u00b6 Loads pandoc options from yamlfile and return a list with corresponding pandoc command line arguments. Source code in ontopy/ontodoc.py def load_pandoc_option_file ( yamlfile ): \"\"\"Loads pandoc options from `yamlfile` and return a list with corresponding pandoc command line arguments.\"\"\" with open ( yamlfile ) as f : d = yaml . safe_load ( f ) options = d . pop ( 'input-files' , []) variables = d . pop ( 'variables' , {}) for k , v in d . items (): if isinstance ( v , bool ): if v : options . append ( '-- %s ' % k ) else : options . append ( '-- %s = %s ' % ( k , v )) for k , v in variables . items (): if k == 'date' and v == 'now' : v = time . strftime ( '%B %d , %Y' ) options . append ( '--variable= %s : %s ' % ( k , v )) return options run_pandoc ( genfile , outfile , format , pandoc_option_files = (), pandoc_options = (), verbose = True ) \u00b6 Runs pandoc. Parameters \u00b6 genfile : str Name of markdown input file. outfile : str Output file name. format : str Output format. pandoc_option_files : sequence List of files with additional pandoc options. Default is to read \"pandoc-options.yaml\" and \"pandoc-FORMAT-options.yml\", where FORMAT is the output format. pandoc_options : sequence Additional pandoc options overriding options read from pandoc_option_files . verbose : bool Whether to print the pandoc command before execution. Raises \u00b6 subprocess.CalledProcessError If the pandoc process returns with non-zero status. The returncode attribute will hold the exit code. Source code in ontopy/ontodoc.py def run_pandoc ( genfile , outfile , format , pandoc_option_files = (), pandoc_options = (), verbose = True ): \"\"\"Runs pandoc. Parameters ---------- genfile : str Name of markdown input file. outfile : str Output file name. format : str Output format. pandoc_option_files : sequence List of files with additional pandoc options. Default is to read \"pandoc-options.yaml\" and \"pandoc-FORMAT-options.yml\", where `FORMAT` is the output format. pandoc_options : sequence Additional pandoc options overriding options read from `pandoc_option_files`. verbose : bool Whether to print the pandoc command before execution. Raises ------ subprocess.CalledProcessError If the pandoc process returns with non-zero status. The `returncode` attribute will hold the exit code. \"\"\" # Create pandoc argument list args = [ genfile ] files = [ 'pandoc-options.yaml' , 'pandoc- %s -options.yaml' % format ] if pandoc_option_files : files = pandoc_option_files for fname in files : if os . path . exists ( fname ): args . extend ( load_pandoc_option_file ( fname )) else : warnings . warn ( 'missing pandoc option file: %s ' % fname ) # Update pandoc argument list args = append_pandoc_options ( args , pandoc_options ) # pdf output requires a special attention... if format == 'pdf' : pdf_engine = 'pdflatex' for arg in args : if arg . startswith ( '--pdf-engine' ): pdf_engine = arg . split ( '=' , 1 )[ 1 ] break with TemporaryDirectory () as tmpdir : run_pandoc_pdf ( tmpdir , pdf_engine , outfile , args , verbose = verbose ) else : args . append ( '--output= %s ' % outfile ) cmd = [ 'pandoc' ] + args if verbose : print () print ( '* Executing command:' ) print ( ' ' . join ( shlex . quote ( s ) for s in cmd )) subprocess . check_call ( cmd ) run_pandoc_pdf ( latex_dir , pdf_engine , outfile , args , verbose = True ) \u00b6 Run pandoc for pdf generation. Source code in ontopy/ontodoc.py def run_pandoc_pdf ( latex_dir , pdf_engine , outfile , args , verbose = True ): \"\"\"Run pandoc for pdf generation.\"\"\" basename = os . path . join ( latex_dir , os . path . splitext ( os . path . basename ( outfile ))[ 0 ]) # Run pandoc texfile = basename + '.tex' args . append ( '--output= %s ' % texfile ) cmd = [ 'pandoc' ] + args if verbose : print () print ( '* Executing commands:' ) print ( ' ' . join ( shlex . quote ( s ) for s in cmd )) subprocess . check_call ( cmd ) # Fixing tex output texfile2 = basename + '2.tex' with open ( texfile , 'rt' ) as f : content = f . read () . replace ( r '\\$\\Uptheta\\$' , r '$\\Uptheta$' ) with open ( texfile2 , 'wt' ) as f : f . write ( content ) # Run latex pdffile = basename + '2.pdf' cmd = [ pdf_engine , texfile2 , '-halt-on-error' , '-output-directory= %s ' % latex_dir ] if verbose : print () print ( ' ' . join ( shlex . quote ( s ) for s in cmd )) output = subprocess . check_output ( cmd , timeout = 60 ) output = subprocess . check_output ( cmd , timeout = 60 ) # Workaround for non-working \"-output-directory\" latex option if not os . path . exists ( pdffile ): if os . path . exists ( os . path . basename ( pdffile )): pdffile = os . path . basename ( pdffile ) for ext in 'aux' , 'out' , 'toc' , 'log' : filename = os . path . splitext ( pdffile )[ 0 ] + '.' + ext if os . path . exists ( filename ): os . remove ( filename ) else : print () print ( output ) print () raise RuntimeError ( 'latex did not produce pdf file: ' + pdffile ) # Copy pdffile if not os . path . exists ( outfile ) or not os . path . samefile ( pdffile , outfile ): if verbose : print () print ( 'move %s to %s ' % ( pdffile , outfile )) shutil . move ( pdffile , outfile )","title":"ontodoc"},{"location":"api_reference/ontopy/ontodoc/#ontodoc","text":"A module for documenting ontologies.","title":"ontodoc"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP","text":"Documentation pre-processor. It supports the following features: Comment lines %% Comment line... Insert header with given level %HEADER label [level=1] Insert figure with optional caption and width. filepath should be relative to basedir . If width is 0, no width will be specified. %FIGURE filepath [caption='' width=0px] Include other markdown files. Header levels may be up or down with shift %INCLUDE filepath [shift=0] Insert generated documentation for ontology entity. The header level may be set with header_level . %ENTITY name [header_level=3] Insert generated documentation for ontology branch name . Options: header_level: Header level. terminated: Whether to branch should be terminated at all branch names in the final document. include_leafs: Whether to include leaf. %BRANCH name [header_level=3 terminated=1 include_leafs=0 namespaces='' ontologies=''] Insert generated figure of ontology branch name . The figure is written to path . The default path is figdir / name , where figdir is given at class initiation. It is recommended to exclude the file extension from path . In this case, the default figformat will be used (and easily adjusted to the correct format required by the backend). leafs may be a comma- separated list of leaf node names. %BRANCHFIG name [path='' caption='' terminated=1 include_leafs=1 strict_leafs=1, width=0px leafs='' relations=all edgelabels=0 namespaces='' ontologies=''] This is a combination of the %HEADER and %BRANCHFIG directives. %BRANCHHEAD name [level=2 path='' caption='' terminated=1 include_leafs=1 width=0px leafs=''] This is a combination of the %HEADER, %BRANCHFIG and %BRANCH directives. It inserts documentation of branch name , with a header followed by a figure and then documentation of each element. %BRANCHDOC name [level=2 path='' title='' caption='' terminated=1 strict_leafs=1 width=0px leafs='' relations='all' rankdir='BT' legend=1 namespaces='' ontologies=''] Insert generated documentation for all entities of the given type. Valid values of type are: \"classes\", \"individuals\", \"object_properties\", \"data_properties\", \"annotations_properties\" %ALL type [header_level=3, namespaces='', ontologies=''] Insert generated figure of all entities of the given type. Valid values of type are: \"classes\", \"object_properties\" and \"data_properties\". %ALLFIG type","title":"DocPP"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP--parameters","text":"template : str Input template. ontodoc : OntoDoc instance Instance of OntoDoc basedir : str Base directory for including relative file paths. figdir : str Default directory to store generated figures. figformat : str Default format for generated figures. figscale : float Default scaling of generated figures. maxwidth : float Maximum figure width. Figures larger than this will be rescaled. imported : bool Whether to include imported entities.","title":"Parameters"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.copy","text":"Returns a copy of self. Source code in ontopy/ontodoc.py def copy ( self ): \"\"\"Returns a copy of self.\"\"\" docpp = DocPP ( '' , self . ontodoc , self . basedir , figformat = self . figformat , figscale = self . figscale , maxwidth = self . maxwidth ) docpp . lines [:] = self . lines docpp . figdir = self . figdir return docpp","title":"copy()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.get_branches","text":"Returns a list with all branch names as specified with %BRANCH (in current and all included documents). The returned value is cached for efficiency purposes and so that it is not lost after processing branches. Source code in ontopy/ontodoc.py def get_branches ( self ): \"\"\"Returns a list with all branch names as specified with %BRANCH (in current and all included documents). The returned value is cached for efficiency purposes and so that it is not lost after processing branches.\"\"\" if self . _branch_cache is None : names = [] docpp = self . copy () docpp . process_includes () for line in docpp . lines : if line . startswith ( '%BRANCH' ): names . append ( shlex . split ( line )[ 1 ]) self . _branch_cache = names return self . _branch_cache","title":"get_branches()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.get_buffer","text":"Returns the current buffer. Source code in ontopy/ontodoc.py def get_buffer ( self ): \"\"\"Returns the current buffer.\"\"\" return ' \\n ' . join ( self . lines )","title":"get_buffer()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process","text":"Perform all pre-processing steps. Source code in ontopy/ontodoc.py def process ( self ): \"\"\"Perform all pre-processing steps.\"\"\" if not self . _processed : self . process_comments () self . process_headers () self . process_figures () self . process_entities () self . process_branches () self . process_branchfigs () self . process_branchdocs () self . process_alls () self . process_allfig () self . process_includes () self . _processed = True","title":"process()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process_allfig","text":"Process all %ALLFIG directives. Source code in ontopy/ontodoc.py def process_allfig ( self ): \"\"\"Process all %ALLFIG directives.\"\"\" onto = self . ontodoc . onto for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%ALLFIG ' ): tokens = shlex . split ( line ) type = tokens [ 1 ] opts = get_options ( tokens [ 2 :], path = '' , level = 3 , terminated = 0 , include_leafs = 1 , strict_leafs = 1 , width = 0 , leafs = '' , relations = 'isA' , edgelabels = 0 , rankdir = 'BT' , legend = 1 , namespaces = '' , ontologies = '' ) if type == 'classes' : roots = onto . get_root_classes ( imported = self . imported ) elif type in ( 'object_properties' , 'relations' ): roots = onto . get_root_object_properties ( imported = self . imported ) elif type == 'data_properties' : roots = onto . get_root_data_properties ( imported = self . imported ) else : raise InvalidTemplateError ( 'Invalid argument to %% ALLFIG: %s ' % type ) included_namespaces = opts . namespaces . split ( ',' ) if opts . namespaces else () included_ontologies = opts . ontologies . split ( ',' ) if opts . ontologies else () sec = [] for root in roots : name = asstring ( root ) filepath , leafs , width = self . _make_branchfig ( name , opts . path , opts . terminated , opts . include_leafs , opts . strict_leafs , opts . width , opts . leafs , opts . relations , opts . edgelabels , opts . rankdir , opts . legend , included_namespaces , included_ontologies ) title = 'Taxonomy of %s .' % name sec . append ( self . ontodoc . get_header ( title , int ( opts . level ))) caption = 'Taxonomy of %s .' % name sec . extend ( self . ontodoc . get_figure ( filepath , caption = caption , width = width ) . split ( ' \\n ' )) del self . lines [ i ] self . lines [ i : i ] = sec","title":"process_allfig()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process_alls","text":"Expand all %ALL specifications. Source code in ontopy/ontodoc.py def process_alls ( self ): \"\"\"Expand all %ALL specifications.\"\"\" onto = self . ontodoc . onto for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%ALL ' ): tokens = shlex . split ( line ) type = tokens [ 1 ] opts = get_options ( tokens [ 2 :], header_level = 3 ) if type == 'classes' : items = onto . classes ( imported = self . imported ) elif type in ( 'object_properties' , 'relations' ): items = onto . object_properties ( imported = self . imported ) elif type == 'data_properties' : items = onto . data_properties ( imported = self . imported ) elif type == 'annotation_properties' : items = onto . annotation_properties ( imported = self . imported ) elif type == 'individuals' : items = onto . individuals ( imported = self . imported ) else : raise InvalidTemplateError ( 'Invalid argument to %% ALL: %s ' % type ) items = sorted ( items , key = lambda x : asstring ( x )) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . itemsdoc ( items , int ( opts . header_level )) . split ( ' \\n ' )","title":"process_alls()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process_branchdocs","text":"Process all %BRANCHDOC and %BRANCHEAD directives. Source code in ontopy/ontodoc.py def process_branchdocs ( self ): \"\"\"Process all %BRANCHDOC and %BRANCHEAD directives.\"\"\" onto = self . ontodoc . onto for i , line in reversed ( list ( enumerate ( self . lines ))): if ( line . startswith ( '%BRANCHDOC ' ) or line . startswith ( '%BRANCHHEAD ' )): with_branch = True if line . startswith ( '%BRANCHDOC ' ) else False tokens = shlex . split ( line ) name = tokens [ 1 ] title = camelsplit ( name ) title = title [ 0 ] . upper () + title [ 1 :] + ' branch' opts = get_options ( tokens [ 2 :], level = 2 , path = '' , title = title , caption = title + '.' , terminated = 1 , strict_leafs = 1 , width = 0 , leafs = '' , relations = 'all' , edgelabels = 0 , rankdir = 'BT' , legend = 1 , namespaces = '' , ontologies = '' ) included_namespaces = opts . namespaces . split ( ',' ) if opts . namespaces else () included_ontologies = opts . ontologies . split ( ',' ) if opts . ontologies else () include_leafs = 1 filepath , leafs , width = self . _make_branchfig ( name , opts . path , opts . terminated , include_leafs , opts . strict_leafs , opts . width , opts . leafs , opts . relations , opts . edgelabels , opts . rankdir , opts . legend , included_namespaces , included_ontologies ) sec = [] sec . append ( self . ontodoc . get_header ( opts . title , int ( opts . level ))) sec . append ( self . ontodoc . get_figure ( filepath , caption = opts . caption , width = width )) if with_branch : include_leafs = 0 branch = filter_classes ( onto . get_branch ( name , leafs , include_leafs ), included_namespaces = included_namespaces , included_ontologies = included_ontologies ) sec . append ( self . ontodoc . itemsdoc ( branch , int ( opts . level + 1 ))) del self . lines [ i ] self . lines [ i : i ] = sec","title":"process_branchdocs()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process_branches","text":"Expand all %BRANCH specifications. Source code in ontopy/ontodoc.py def process_branches ( self ): \"\"\"Expand all %BRANCH specifications.\"\"\" onto = self . ontodoc . onto # Get all branch names in final document names = self . get_branches () for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%BRANCH ' ): tokens = shlex . split ( line ) name = tokens [ 1 ] opts = get_options ( tokens [ 2 :], header_level = 3 , terminated = 1 , include_leafs = 0 , namespaces = '' , ontologies = '' ) leafs = names if opts . terminated else () included_namespaces = opts . namespaces . split ( ',' ) if opts . namespaces else () included_ontologies = opts . ontologies . split ( ',' ) if opts . ontologies else () branch = filter_classes ( onto . get_branch ( name , leafs , opts . include_leafs ), included_namespaces = included_namespaces , included_ontologies = included_ontologies ) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . itemsdoc ( branch , int ( opts . header_level )) . split ( ' \\n ' )","title":"process_branches()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process_branchfigs","text":"Process all %BRANCHFIG directives. Source code in ontopy/ontodoc.py def process_branchfigs ( self ): \"\"\"Process all %BRANCHFIG directives.\"\"\" for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%BRANCHFIG ' ): tokens = shlex . split ( line ) name = tokens [ 1 ] opts = get_options ( tokens [ 2 :], path = '' , caption = '' , terminated = 1 , include_leafs = 1 , strict_leafs = 1 , width = 0 , leafs = '' , relations = 'all' , edgelabels = 0 , rankdir = 'BT' , legend = 1 , namespaces = '' , ontologies = '' ) included_namespaces = opts . namespaces . split ( ',' ) if opts . namespaces else () included_ontologies = opts . ontologies . split ( ',' ) if opts . ontologies else () filepath , leafs , width = self . _make_branchfig ( name , opts . path , opts . terminated , opts . include_leafs , opts . strict_leafs , opts . width , opts . leafs , opts . relations , opts . edgelabels , opts . rankdir , opts . legend , included_namespaces , included_ontologies ) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . get_figure ( filepath , caption = opts . caption , width = width ) . split ( ' \\n ' )","title":"process_branchfigs()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process_comments","text":"Strips out comment lines starting with \"%%\". Source code in ontopy/ontodoc.py def process_comments ( self ): \"\"\"Strips out comment lines starting with \"%%\".\"\"\" self . lines = [ line for line in self . lines if not line . startswith ( ' %% ' )]","title":"process_comments()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process_entities","text":"Expand all %ENTITY specifications. Source code in ontopy/ontodoc.py def process_entities ( self ): \"\"\"Expand all %ENTITY specifications.\"\"\" for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( ' %E NTITY ' ): tokens = shlex . split ( line ) name = tokens [ 1 ] opts = get_options ( tokens [ 2 :], header_level = 3 ) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . itemdoc ( name , int ( opts . header_level )) . split ( ' \\n ' )","title":"process_entities()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process_figures","text":"Expand all %FIGURE specifications. Source code in ontopy/ontodoc.py def process_figures ( self ): \"\"\"Expand all %FIGURE specifications.\"\"\" for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( ' %F IGURE ' ): tokens = shlex . split ( line ) path = tokens [ 1 ] opts = get_options ( tokens [ 2 :], caption = '' , width = 0 ) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . get_figure ( os . path . join ( self . basedir , path ), caption = opts . caption , width = opts . width ) . split ( ' \\n ' )","title":"process_figures()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process_headers","text":"Expand all %HEADER specifications. Source code in ontopy/ontodoc.py def process_headers ( self ): \"\"\"Expand all %HEADER specifications.\"\"\" for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%HEADER ' ): tokens = shlex . split ( line ) name = tokens [ 1 ] opts = get_options ( tokens [ 2 :], level = 1 ) del self . lines [ i ] self . lines [ i : i ] = self . ontodoc . get_header ( name , int ( opts . level )) . split ( ' \\n ' )","title":"process_headers()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.process_includes","text":"Process all %INCLUDE directives. Source code in ontopy/ontodoc.py def process_includes ( self ): \"\"\"Process all %INCLUDE directives.\"\"\" for i , line in reversed ( list ( enumerate ( self . lines ))): if line . startswith ( '%INCLUDE ' ): tokens = shlex . split ( line ) filepath = tokens [ 1 ] opts = get_options ( tokens [ 2 :], shift = 0 ) with open ( os . path . join ( self . basedir , filepath ), 'rt' ) as f : docpp = DocPP ( f . read (), self . ontodoc , basedir = os . path . dirname ( filepath ), figformat = self . figformat , figscale = self . figscale , maxwidth = self . maxwidth ) docpp . figdir = self . figdir if opts . shift : docpp . shift_header_levels ( int ( opts . shift )) docpp . process () del self . lines [ i ] self . lines [ i : i ] = docpp . lines","title":"process_includes()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.shift_header_levels","text":"Shift header level of all hashtag-headers in buffer. Underline headers are ignored. Source code in ontopy/ontodoc.py def shift_header_levels ( self , shift ): \"\"\"Shift header level of all hashtag-headers in buffer. Underline headers are ignored.\"\"\" if not shift : return pat = re . compile ( '^#+ ' ) for i , line in enumerate ( self . lines ): m = pat . match ( line ) if m : if shift > 0 : self . lines [ i ] = '#' * shift + line elif shift < 0 : n = m . end () if shift > n : self . lines [ i ] = line . lstrip ( '# ' ) else : self . lines [ i ] = line [ n :]","title":"shift_header_levels()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.write","text":"Writes documentation to outfile .","title":"write()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.DocPP.write--parameters","text":"outfile : str File that the documentation is written to. format : str Output format. If it is \"md\" or \"simple-html\", the built-in template generator is used. Otherwise pandoc is used. If not given, the format is inferred from the outfile name extension. pandoc_option_files : sequence Sequence with command line arguments provided to pandoc. pandoc_options : sequence Additional pandoc options overriding options read from pandoc_option_files . genfile : str Store temporary generated markdown input file to pandoc to this file (for debugging). verbose : bool Whether to show some messages when running pandoc. Source code in ontopy/ontodoc.py def write ( self , outfile , format = None , pandoc_option_files = (), pandoc_options = (), genfile = None , verbose = True ): \"\"\"Writes documentation to `outfile`. Parameters ---------- outfile : str File that the documentation is written to. format : str Output format. If it is \"md\" or \"simple-html\", the built-in template generator is used. Otherwise pandoc is used. If not given, the format is inferred from the `outfile` name extension. pandoc_option_files : sequence Sequence with command line arguments provided to pandoc. pandoc_options : sequence Additional pandoc options overriding options read from `pandoc_option_files`. genfile : str Store temporary generated markdown input file to pandoc to this file (for debugging). verbose : bool Whether to show some messages when running pandoc. \"\"\" self . process () content = self . get_buffer () substitutions = self . ontodoc . style . get ( 'substitutions' , []) for reg , sub in substitutions : content = re . sub ( reg , sub , content ) format = get_format ( outfile , format ) if format not in ( 'simple-html' , 'markdown' , 'md' ): # Run pandoc if not genfile : f = NamedTemporaryFile ( mode = 'w+t' , suffix = '.md' ) f . write ( content ) f . flush () genfile = f . name else : with open ( genfile , 'wt' ) as f : f . write ( content ) run_pandoc ( genfile , outfile , format , pandoc_option_files = pandoc_option_files , pandoc_options = pandoc_options , verbose = verbose ) else : if verbose : print ( 'Writing:' , outfile ) with open ( outfile , 'wt' ) as f : f . write ( content )","title":"Parameters"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.InvalidTemplateError","text":"Raised on errors in template files.","title":"InvalidTemplateError"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.OntoDoc","text":"A class for helping documentating ontologies.","title":"OntoDoc"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.OntoDoc--parameters","text":"onto : Ontology instance The ontology that should be documented. style : dict | \"html\" | \"markdown\" | \"markdown_tex\" A dict defining the following template strings (and substitutions): :header: Formats an header. Substitutions: {level}, {label} :link: Formats a link. Substitutions: {name} :point: Formats a point (list item). Substitutions: {point}, {ontology} :points: Formats a list of points. Used within annotations. Substitutions: {points}, {ontology} :annotation: Formats an annotation. Substitutions: {key}, {value}, {ontology} :substitutions: list of ``(regex, sub)`` pairs for substituting annotation values.","title":"Parameters"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.OntoDoc.get_default_template","text":"Returns default template. Source code in ontopy/ontodoc.py def get_default_template ( self ): \"\"\"Returns default template.\"\"\" title = os . path . splitext ( os . path . basename ( self . onto . base_iri . rstrip ( '/#' )))[ 0 ] irilink = self . style . get ( 'link' , ' {name} ' ) . format ( name = self . onto . base_iri , url = self . onto . base_iri , lowerurl = self . onto . base_iri ) s = dedent ( ''' \\ %HEADER {title} Documentation of {irilink} %HEADER Relations level=2 %ALL object_properties %HEADER Classes level=2 %ALL classes %HEADER Individuals level=2 %ALL individuals %HEADER Appendix level=1 %HEADER \"Relation taxonomies\" level=2 %ALLFIG object_properties %HEADER \"Class taxonomies\" level=2 %ALLFIG classes ''' ) . format ( ontology = self . onto , title = title , irilink = irilink ) return s","title":"get_default_template()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.OntoDoc.get_figure","text":"Returns a formatted insert-figure-directive. Source code in ontopy/ontodoc.py def get_figure ( self , path , caption = '' , width = None ): \"\"\"Returns a formatted insert-figure-directive.\"\"\" figwidth_style = self . style . get ( 'figwidth' , '' ) figure_style = self . style . get ( 'figure' , '' ) figwidth = figwidth_style . format ( width = width ) if width else '' return figure_style . format ( path = path , caption = caption , figwidth = figwidth )","title":"get_figure()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.OntoDoc.get_header","text":"Returns label formatted as a header of given level. Source code in ontopy/ontodoc.py def get_header ( self , label , header_level = 1 ): \"\"\"Returns `label` formatted as a header of given level.\"\"\" header_style = self . style . get ( 'header' , ' {label} \\n ' ) return header_style . format ( '' , level = header_level , label = label , lowerlabel = label . lower ())","title":"get_header()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.OntoDoc.itemdoc","text":"Returns documentation of item .","title":"itemdoc()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.OntoDoc.itemdoc--parameters","text":"item : obj | label The class, individual or relation to document. header_level : int Header level. Defaults to 3. show_disjoints : Bool Whether to show disjoint_with relations. Source code in ontopy/ontodoc.py def itemdoc ( self , item , header_level = 3 , show_disjoints = False ): \"\"\"Returns documentation of `item`. Parameters ---------- item : obj | label The class, individual or relation to document. header_level : int Header level. Defaults to 3. show_disjoints : Bool Whether to show `disjoint_with` relations. \"\"\" onto = self . onto if isinstance ( item , str ): item = self . onto . get_by_label ( item ) header_style = self . style . get ( 'header' , ' {label} \\n ' ) link_style = self . style . get ( 'link' , ' {name} ' ) point_style = self . style . get ( 'point' , ' {point} ' ) points_style = self . style . get ( 'points' , ' {points} ' ) annotation_style = self . style . get ( 'annotation' , ' {key} : {value} \\n ' ) substitutions = self . style . get ( 'substitutions' , []) # Logical \"sorting\" of annotations order = dict ( definition = '00' , axiom = '01' , theorem = '02' , elucidation = '03' , domain = '04' , range = '05' , example = '06' ) doc = [] # Header label = get_label ( item ) doc . append ( header_style . format ( '' , level = header_level , label = label , lowerlabel = label . lower ())) # Add warning about missing prefLabel if not hasattr ( item , 'prefLabel' ) or not item . prefLabel . first (): doc . append ( annotation_style . format ( key = 'Warning' , value = 'Missing prefLabel' )) # Add iri doc . append ( annotation_style . format ( key = 'IRI' , value = asstring ( item . iri , link_style ), ontology = onto )) # Add annotations if isinstance ( item , owlready2 . Thing ): annotations = item . get_individual_annotations () else : annotations = item . get_annotations () for key in sorted ( annotations . keys (), key = lambda key : order . get ( key , key )): for value in annotations [ key ]: if self . url_regex . match ( value ): doc . append ( annotation_style . format ( key = key , value = asstring ( value , link_style ))) else : for reg , sub in substitutions : value = re . sub ( reg , sub , value ) doc . append ( annotation_style . format ( key = key , value = value )) # ...add relations from is_a points = [] nonProp = ( owlready2 . ThingClass , # owlready2.Restriction, owlready2 . And , owlready2 . Or , owlready2 . Not ) for p in item . is_a : if ( isinstance ( p , nonProp ) or ( isinstance ( item , owlready2 . PropertyClass ) and isinstance ( p , owlready2 . PropertyClass ))): points . append ( point_style . format ( point = 'is_a ' + asstring ( p , link_style ), ontology = onto )) else : points . append ( point_style . format ( point = asstring ( p , link_style ), ontology = onto )) # ...add equivalent_to relations for e in item . equivalent_to : points . append ( point_style . format ( point = 'equivalent_to ' + asstring ( e , link_style ))) # ...add disjoint_with relations if show_disjoints and hasattr ( item , 'disjoint_with' ): s = set ( item . disjoint_with ( reduce = True )) points . append ( point_style . format ( point = 'disjoint_with ' + ', ' . join ( asstring ( e , link_style ) for e in s ), ontology = onto )) # ...add disjoint_unions if hasattr ( item , 'disjoint_unions' ): for u in item . disjoint_unions : s = ', ' . join ( asstring ( e , link_style ) for e in u ) points . append ( point_style . format ( point = 'disjoint_union_of ' + s , ontology = onto )) # ...add inverse_of relations if hasattr ( item , 'inverse_property' ) and item . inverse_property : points . append ( point_style . format ( point = 'inverse_of ' + asstring ( item . inverse_property , link_style ))) # ...add domain restrictions for d in getattr ( item , 'domain' , ()): points . append ( point_style . format ( point = 'domain ' + asstring ( d , link_style ))) # ...add range restrictions for d in getattr ( item , 'range' , ()): points . append ( point_style . format ( point = 'range ' + asstring ( d , link_style ))) # Add points (from is_a) if points : value = points_style . format ( points = '' . join ( points ), ontology = onto ) doc . append ( annotation_style . format ( key = 'Subclass of' , value = value , ontology = onto )) # Instances (individuals) if hasattr ( item , 'instances' ): points = [] for e in [ i for i in item . instances () if item in i . is_instance_of ]: points . append ( point_style . format ( point = asstring ( e , link_style ), ontology = onto )) if points : value = points_style . format ( points = '' . join ( points ), ontology = onto ) doc . append ( annotation_style . format ( key = 'Individuals' , value = value , ontology = onto )) return ' \\n ' . join ( doc )","title":"Parameters"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.OntoDoc.itemsdoc","text":"Returns documentation of items . Source code in ontopy/ontodoc.py def itemsdoc ( self , items , header_level = 3 ): \"\"\"Returns documentation of `items`.\"\"\" sep_style = self . style . get ( 'sep' , ' \\n ' ) doc = [] for item in items : doc . append ( self . itemdoc ( item , header_level )) doc . append ( sep_style . format ( ontology = self . onto )) return ' \\n ' . join ( doc )","title":"itemsdoc()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.attrdict","text":"A dict with attribute access. Note that methods like key() and update() may be overridden.","title":"attrdict"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.append_pandoc_options","text":"Append updates to pandoc options options .","title":"append_pandoc_options()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.append_pandoc_options--parameters","text":"options : sequence Sequence with initial Pandoc options. updates : sequence of str Sequence of strings of the form \"--longoption=value\", where longoption is a valid pandoc long option and value is the new value. The \"=value\" part is optional. Strings of the form \"no-longoption\" will filter out \"--longoption\" from `options`.","title":"Parameters"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.append_pandoc_options--returns","text":"new_options : list Updated pandoc options. Source code in ontopy/ontodoc.py def append_pandoc_options ( options , updates ): \"\"\"Append `updates` to pandoc options `options`. Parameters ---------- options : sequence Sequence with initial Pandoc options. updates : sequence of str Sequence of strings of the form \"--longoption=value\", where ``longoption`` is a valid pandoc long option and ``value`` is the new value. The \"=value\" part is optional. Strings of the form \"no-longoption\" will filter out \"--longoption\" from `options`. Returns ------- new_options : list Updated pandoc options. \"\"\" # Valid pandoc options starting with \"--no-XXX\" no_options = set ( 'no-highlight' ) if not updates : return list ( options ) u = {} for s in updates : k , sep , v = s . partition ( '=' ) u [ k . lstrip ( '-' )] = v if sep else None filter_out = set ( k for k , v in u . items () if k . startswith ( 'no-' ) and k not in no_options ) _filter_out = set ( '--' + k [ 3 :] for k in filter_out ) new_options = [ opt for opt in options if opt . partition ( '=' )[ 0 ] not in _filter_out ] new_options . extend ([ '-- %s ' % k if v is None else '-- %s = %s ' % ( k , v ) for k , v in u . items () if k not in filter_out ]) return new_options","title":"Returns"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.get_docpp","text":"Read infile and return a new docpp instance. Source code in ontopy/ontodoc.py def get_docpp ( ontodoc , infile , figdir = 'genfigs' , figformat = 'png' , maxwidth = None , imported = False ): \"\"\"Read `infile` and return a new docpp instance.\"\"\" if infile : with open ( infile , 'rt' ) as f : template = f . read () basedir = os . path . dirname ( infile ) else : template = ontodoc . get_default_template () basedir = '.' docpp = DocPP ( template , ontodoc , basedir = basedir , figdir = figdir , figformat = figformat , maxwidth = maxwidth , imported = imported ) return docpp","title":"get_docpp()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.get_figformat","text":"Infer preferred figure format from output format. Source code in ontopy/ontodoc.py def get_figformat ( format ): \"\"\"Infer preferred figure format from output format.\"\"\" if format == 'pdf' : figformat = 'pdf' # XXX elif 'html' in format : figformat = 'svg' else : figformat = 'png' return figformat","title":"get_figformat()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.get_format","text":"Infer format from outfile and format. Source code in ontopy/ontodoc.py def get_format ( outfile , format = None ): \"\"\"Infer format from outfile and format.\"\"\" if format is None : format = os . path . splitext ( outfile )[ 1 ] if not format : format = 'html' if format . startswith ( '.' ): format = format [ 1 :] return format","title":"get_format()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.get_maxwidth","text":"Infer preferred max figure width from output format. Source code in ontopy/ontodoc.py def get_maxwidth ( format ): \"\"\"Infer preferred max figure width from output format.\"\"\" if format == 'pdf' : maxwidth = 668 else : maxwidth = 1024 return maxwidth","title":"get_maxwidth()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.get_options","text":"Returns a dict with options from the sequence opts with \"name=value\" pairs. Valid option names and default values are provided with the keyword arguments. Source code in ontopy/ontodoc.py def get_options ( opts , ** kw ): \"\"\"Returns a dict with options from the sequence `opts` with \"name=value\" pairs. Valid option names and default values are provided with the keyword arguments.\"\"\" d = attrdict ( kw ) for opt in opts : if '=' not in opt : raise InvalidTemplateError ( 'Missing \"=\" in template option: %r ' % opt ) name , value = opt . split ( '=' , 1 ) if name not in d : raise InvalidTemplateError ( 'Invalid template option: %r ' % name ) t = type ( d [ name ]) d [ name ] = t ( value ) return d","title":"get_options()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.get_style","text":"Infer style from output format. Source code in ontopy/ontodoc.py def get_style ( format ): \"\"\"Infer style from output format.\"\"\" if format == 'simple-html' : style = 'html' elif format in ( 'tex' , 'latex' , 'pdf' ): style = 'markdown_tex' else : style = 'markdown' return style","title":"get_style()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.load_pandoc_option_file","text":"Loads pandoc options from yamlfile and return a list with corresponding pandoc command line arguments. Source code in ontopy/ontodoc.py def load_pandoc_option_file ( yamlfile ): \"\"\"Loads pandoc options from `yamlfile` and return a list with corresponding pandoc command line arguments.\"\"\" with open ( yamlfile ) as f : d = yaml . safe_load ( f ) options = d . pop ( 'input-files' , []) variables = d . pop ( 'variables' , {}) for k , v in d . items (): if isinstance ( v , bool ): if v : options . append ( '-- %s ' % k ) else : options . append ( '-- %s = %s ' % ( k , v )) for k , v in variables . items (): if k == 'date' and v == 'now' : v = time . strftime ( '%B %d , %Y' ) options . append ( '--variable= %s : %s ' % ( k , v )) return options","title":"load_pandoc_option_file()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.run_pandoc","text":"Runs pandoc.","title":"run_pandoc()"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.run_pandoc--parameters","text":"genfile : str Name of markdown input file. outfile : str Output file name. format : str Output format. pandoc_option_files : sequence List of files with additional pandoc options. Default is to read \"pandoc-options.yaml\" and \"pandoc-FORMAT-options.yml\", where FORMAT is the output format. pandoc_options : sequence Additional pandoc options overriding options read from pandoc_option_files . verbose : bool Whether to print the pandoc command before execution.","title":"Parameters"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.run_pandoc--raises","text":"subprocess.CalledProcessError If the pandoc process returns with non-zero status. The returncode attribute will hold the exit code. Source code in ontopy/ontodoc.py def run_pandoc ( genfile , outfile , format , pandoc_option_files = (), pandoc_options = (), verbose = True ): \"\"\"Runs pandoc. Parameters ---------- genfile : str Name of markdown input file. outfile : str Output file name. format : str Output format. pandoc_option_files : sequence List of files with additional pandoc options. Default is to read \"pandoc-options.yaml\" and \"pandoc-FORMAT-options.yml\", where `FORMAT` is the output format. pandoc_options : sequence Additional pandoc options overriding options read from `pandoc_option_files`. verbose : bool Whether to print the pandoc command before execution. Raises ------ subprocess.CalledProcessError If the pandoc process returns with non-zero status. The `returncode` attribute will hold the exit code. \"\"\" # Create pandoc argument list args = [ genfile ] files = [ 'pandoc-options.yaml' , 'pandoc- %s -options.yaml' % format ] if pandoc_option_files : files = pandoc_option_files for fname in files : if os . path . exists ( fname ): args . extend ( load_pandoc_option_file ( fname )) else : warnings . warn ( 'missing pandoc option file: %s ' % fname ) # Update pandoc argument list args = append_pandoc_options ( args , pandoc_options ) # pdf output requires a special attention... if format == 'pdf' : pdf_engine = 'pdflatex' for arg in args : if arg . startswith ( '--pdf-engine' ): pdf_engine = arg . split ( '=' , 1 )[ 1 ] break with TemporaryDirectory () as tmpdir : run_pandoc_pdf ( tmpdir , pdf_engine , outfile , args , verbose = verbose ) else : args . append ( '--output= %s ' % outfile ) cmd = [ 'pandoc' ] + args if verbose : print () print ( '* Executing command:' ) print ( ' ' . join ( shlex . quote ( s ) for s in cmd )) subprocess . check_call ( cmd )","title":"Raises"},{"location":"api_reference/ontopy/ontodoc/#ontopy.ontodoc.run_pandoc_pdf","text":"Run pandoc for pdf generation. Source code in ontopy/ontodoc.py def run_pandoc_pdf ( latex_dir , pdf_engine , outfile , args , verbose = True ): \"\"\"Run pandoc for pdf generation.\"\"\" basename = os . path . join ( latex_dir , os . path . splitext ( os . path . basename ( outfile ))[ 0 ]) # Run pandoc texfile = basename + '.tex' args . append ( '--output= %s ' % texfile ) cmd = [ 'pandoc' ] + args if verbose : print () print ( '* Executing commands:' ) print ( ' ' . join ( shlex . quote ( s ) for s in cmd )) subprocess . check_call ( cmd ) # Fixing tex output texfile2 = basename + '2.tex' with open ( texfile , 'rt' ) as f : content = f . read () . replace ( r '\\$\\Uptheta\\$' , r '$\\Uptheta$' ) with open ( texfile2 , 'wt' ) as f : f . write ( content ) # Run latex pdffile = basename + '2.pdf' cmd = [ pdf_engine , texfile2 , '-halt-on-error' , '-output-directory= %s ' % latex_dir ] if verbose : print () print ( ' ' . join ( shlex . quote ( s ) for s in cmd )) output = subprocess . check_output ( cmd , timeout = 60 ) output = subprocess . check_output ( cmd , timeout = 60 ) # Workaround for non-working \"-output-directory\" latex option if not os . path . exists ( pdffile ): if os . path . exists ( os . path . basename ( pdffile )): pdffile = os . path . basename ( pdffile ) for ext in 'aux' , 'out' , 'toc' , 'log' : filename = os . path . splitext ( pdffile )[ 0 ] + '.' + ext if os . path . exists ( filename ): os . remove ( filename ) else : print () print ( output ) print () raise RuntimeError ( 'latex did not produce pdf file: ' + pdffile ) # Copy pdffile if not os . path . exists ( outfile ) or not os . path . samefile ( pdffile , outfile ): if verbose : print () print ( 'move %s to %s ' % ( pdffile , outfile )) shutil . move ( pdffile , outfile )","title":"run_pandoc_pdf()"},{"location":"api_reference/ontopy/ontograph/","text":"ontograph \u00b6 A module adding graphing functionality to ontopy.ontology OntoGraph \u00b6 A mixin class used by ontopy.ontology.Ontology that adds functionality for generating graph representations of the ontology. get_dot_graph ( self , root = None , graph = None , relations = 'is_a' , leafs = None , parents = False , style = None , edgelabels = True , constraint = False ) \u00b6 Returns a pydot graph object for visualising the ontology. Parameters \u00b6 root : None | string | owlready2.ThingClass instance Name or owlready2 entity of root node to plot subgraph below. If root is None, all classes will be included in the subgraph. graph : None | pydot.Dot instance Pydot graph object to plot into. If None, a new graph object is created using the keyword arguments. relations : True | str | sequence Sequence of relations to visualise. If True, all relations are included. leafs : None | sequence A sequence of leaf node names for generating sub-graphs. parents : bool | str Whether to include parent nodes. If parents is a string, only parent nodes down to the given name will included. style : None | dict | \"uml\" A dict mapping the name of the different graphical elements to dicts of pydot style settings. Supported graphical elements include: - graph : overall settings pydot graph - class : nodes for classes - individual : nodes for invididuals - is_a : edges for is_a relations - equivalent_to : edges for equivalent_to relations - disjoint_with : edges for disjoint_with relations - inverse_of : edges for inverse_of relations - relations : with relation names XXX - other : edges for other relations and restrictions If style is None, a very simple default style is used. Some pre-defined styles can be selected by name (currently only \"uml\"). edgelabels : bool | dict Whether to add labels to the edges of the generated graph. It is also possible to provide a dict mapping the full labels (with cardinality stripped off for restrictions) to some abbriviations. constraint : None | bool Note: This method requires pydot. Source code in ontopy/ontograph.py def get_dot_graph ( self , root = None , graph = None , relations = 'is_a' , leafs = None , parents = False , style = None , edgelabels = True , constraint = False ): \"\"\"Returns a pydot graph object for visualising the ontology. Parameters ---------- root : None | string | owlready2.ThingClass instance Name or owlready2 entity of root node to plot subgraph below. If `root` is None, all classes will be included in the subgraph. graph : None | pydot.Dot instance Pydot graph object to plot into. If None, a new graph object is created using the keyword arguments. relations : True | str | sequence Sequence of relations to visualise. If True, all relations are included. leafs : None | sequence A sequence of leaf node names for generating sub-graphs. parents : bool | str Whether to include parent nodes. If `parents` is a string, only parent nodes down to the given name will included. style : None | dict | \"uml\" A dict mapping the name of the different graphical elements to dicts of pydot style settings. Supported graphical elements include: - graph : overall settings pydot graph - class : nodes for classes - individual : nodes for invididuals - is_a : edges for is_a relations - equivalent_to : edges for equivalent_to relations - disjoint_with : edges for disjoint_with relations - inverse_of : edges for inverse_of relations - relations : with relation names XXX - other : edges for other relations and restrictions If style is None, a very simple default style is used. Some pre-defined styles can be selected by name (currently only \"uml\"). edgelabels : bool | dict Whether to add labels to the edges of the generated graph. It is also possible to provide a dict mapping the full labels (with cardinality stripped off for restrictions) to some abbriviations. constraint : None | bool Note: This method requires pydot. \"\"\" warnings . warn ( \"\"\"The ontopy.ontology.get_dot_graph() method is deprecated. Use ontopy.ontology.get_graph() instead. This requires that you install graphviz instead of the old pydot package.\"\"\" , DeprecationWarning ) # FIXME - double inheritance leads to dublicated nodes. Make sure # to only add a node once! import pydot from ontopy.ontology import NoSuchLabelError if style is None or style == 'default' : style = self . _default_style elif style == 'uml' : style = self . _uml_style graph = self . _get_dot_graph ( root = root , graph = graph , relations = relations , leafs = leafs , style = style , edgelabels = edgelabels ) # Add parents # FIXME - facture out into an recursive function to support # multiple inheritance if parents and root : r = self . get_by_label ( root ) if isinstance ( root , str ) else root while True : parent = r . is_a . first () if ( parent is None or parent is owlready2 . Thing ): break label = asstring ( parent ) if self . is_defined ( label ): node = pydot . Node ( label , ** style . get ( 'defined_class' , {})) # If label contains a hyphen, the node name will # be quoted (bug in pydot?). To work around, set # the name explicitly... node . set_name ( label ) else : node = pydot . Node ( label , ** style . get ( 'class' , {})) node . set_name ( label ) graph . add_node ( node ) if relations is True or 'is_a' in relations : kw = style . get ( 'is_a' , {}) . copy () if isinstance ( edgelabels , dict ): kw [ 'label' ] = edgelabels . get ( 'is_a' , 'is_a' ) elif edgelabels : kw [ 'label' ] = 'is_a' rootnode = graph . get_node ( asstring ( r ))[ 0 ] edge = pydot . Edge ( rootnode , node , ** kw ) graph . add_edge ( edge ) if ( isinstance ( parents , str ) and label == parents ): break r = parent # Add edges for node in graph . get_nodes (): try : entity = self . get_by_label ( node . get_name ()) except ( KeyError , NoSuchLabelError ): continue # Add is_a edges targets = [ e for e in entity . is_a if not isinstance ( e , ( owlready2 . ThingClass , owlready2 . ObjectPropertyClass , owlready2 . PropertyClass ))] self . _get_dot_add_edges ( graph , entity , targets , 'relations' , relations , # style=style.get('relations', style.get('other', {})), style = style . get ( 'other' , {}), edgelabels = edgelabels , constraint = constraint , ) # Add equivalent_to edges if relations is True or 'equivalent_to' in relations : self . _get_dot_add_edges ( graph , entity , entity . equivalent_to , 'equivalent_to' , relations , style . get ( 'equivalent_to' , {}), edgelabels = edgelabels , constraint = constraint , ) # disjoint_with if hasattr ( entity , 'disjoints' ) and ( relations is True or 'disjoint_with' in relations ): self . _get_dot_add_edges ( graph , entity , entity . disjoints (), 'disjoint_with' , relations , style . get ( 'disjoint_with' , {}), edgelabels = edgelabels , constraint = constraint , ) # Add inverse_of if ( hasattr ( entity , 'inverse_property' ) and ( relations is True or 'inverse_of' in relations ) and entity . inverse_property not in ( None , entity )): self . _get_dot_add_edges ( graph , entity , [ entity . inverse_property ], 'inverse_of' , relations , style . get ( 'inverse_of' , {}), edgelabels = edgelabels , constraint = constraint , ) return graph get_dot_relations_graph ( self , graph = None , relations = 'is_a' , style = None ) \u00b6 Returns a disjoined graph of all relations. This method simply calls get_dot_graph() with all root relations. All arguments are passed on. Source code in ontopy/ontograph.py def get_dot_relations_graph ( self , graph = None , relations = 'is_a' , style = None ): \"\"\"Returns a disjoined graph of all relations. This method simply calls get_dot_graph() with all root relations. All arguments are passed on. \"\"\" rels = tuple ( self . get_relations ()) roots = [ relation for relation in rels if not any ([ r in rels for r in relation . is_a ])] return self . get_dot_graph ( root = roots , graph = graph , relations = relations , style = style ) get_figsize ( graph ) \u00b6 Returns figure size (width, height) in points of figures for the current pydot graph object graph . Source code in ontopy/ontograph.py def get_figsize ( graph ): \"\"\"Returns figure size (width, height) in points of figures for the current pydot graph object `graph`.\"\"\" with tempfile . TemporaryDirectory () as tmpdir : tmpfile = os . path . join ( tmpdir , 'graph.svg' ) graph . write_svg ( tmpfile ) xml = ET . parse ( tmpfile ) svg = xml . getroot () width = svg . attrib [ 'width' ] height = svg . attrib [ 'height' ] assert width . endswith ( 'pt' ) # ensure that units are in points def asfloat ( s ): return float ( re . match ( r '^[\\d.]+' , s ) . group ()) return asfloat ( width ), asfloat ( height )","title":"ontograph"},{"location":"api_reference/ontopy/ontograph/#ontograph","text":"A module adding graphing functionality to ontopy.ontology","title":"ontograph"},{"location":"api_reference/ontopy/ontograph/#ontopy.ontograph.OntoGraph","text":"A mixin class used by ontopy.ontology.Ontology that adds functionality for generating graph representations of the ontology.","title":"OntoGraph"},{"location":"api_reference/ontopy/ontograph/#ontopy.ontograph.OntoGraph.get_dot_graph","text":"Returns a pydot graph object for visualising the ontology.","title":"get_dot_graph()"},{"location":"api_reference/ontopy/ontograph/#ontopy.ontograph.OntoGraph.get_dot_graph--parameters","text":"root : None | string | owlready2.ThingClass instance Name or owlready2 entity of root node to plot subgraph below. If root is None, all classes will be included in the subgraph. graph : None | pydot.Dot instance Pydot graph object to plot into. If None, a new graph object is created using the keyword arguments. relations : True | str | sequence Sequence of relations to visualise. If True, all relations are included. leafs : None | sequence A sequence of leaf node names for generating sub-graphs. parents : bool | str Whether to include parent nodes. If parents is a string, only parent nodes down to the given name will included. style : None | dict | \"uml\" A dict mapping the name of the different graphical elements to dicts of pydot style settings. Supported graphical elements include: - graph : overall settings pydot graph - class : nodes for classes - individual : nodes for invididuals - is_a : edges for is_a relations - equivalent_to : edges for equivalent_to relations - disjoint_with : edges for disjoint_with relations - inverse_of : edges for inverse_of relations - relations : with relation names XXX - other : edges for other relations and restrictions If style is None, a very simple default style is used. Some pre-defined styles can be selected by name (currently only \"uml\"). edgelabels : bool | dict Whether to add labels to the edges of the generated graph. It is also possible to provide a dict mapping the full labels (with cardinality stripped off for restrictions) to some abbriviations. constraint : None | bool Note: This method requires pydot. Source code in ontopy/ontograph.py def get_dot_graph ( self , root = None , graph = None , relations = 'is_a' , leafs = None , parents = False , style = None , edgelabels = True , constraint = False ): \"\"\"Returns a pydot graph object for visualising the ontology. Parameters ---------- root : None | string | owlready2.ThingClass instance Name or owlready2 entity of root node to plot subgraph below. If `root` is None, all classes will be included in the subgraph. graph : None | pydot.Dot instance Pydot graph object to plot into. If None, a new graph object is created using the keyword arguments. relations : True | str | sequence Sequence of relations to visualise. If True, all relations are included. leafs : None | sequence A sequence of leaf node names for generating sub-graphs. parents : bool | str Whether to include parent nodes. If `parents` is a string, only parent nodes down to the given name will included. style : None | dict | \"uml\" A dict mapping the name of the different graphical elements to dicts of pydot style settings. Supported graphical elements include: - graph : overall settings pydot graph - class : nodes for classes - individual : nodes for invididuals - is_a : edges for is_a relations - equivalent_to : edges for equivalent_to relations - disjoint_with : edges for disjoint_with relations - inverse_of : edges for inverse_of relations - relations : with relation names XXX - other : edges for other relations and restrictions If style is None, a very simple default style is used. Some pre-defined styles can be selected by name (currently only \"uml\"). edgelabels : bool | dict Whether to add labels to the edges of the generated graph. It is also possible to provide a dict mapping the full labels (with cardinality stripped off for restrictions) to some abbriviations. constraint : None | bool Note: This method requires pydot. \"\"\" warnings . warn ( \"\"\"The ontopy.ontology.get_dot_graph() method is deprecated. Use ontopy.ontology.get_graph() instead. This requires that you install graphviz instead of the old pydot package.\"\"\" , DeprecationWarning ) # FIXME - double inheritance leads to dublicated nodes. Make sure # to only add a node once! import pydot from ontopy.ontology import NoSuchLabelError if style is None or style == 'default' : style = self . _default_style elif style == 'uml' : style = self . _uml_style graph = self . _get_dot_graph ( root = root , graph = graph , relations = relations , leafs = leafs , style = style , edgelabels = edgelabels ) # Add parents # FIXME - facture out into an recursive function to support # multiple inheritance if parents and root : r = self . get_by_label ( root ) if isinstance ( root , str ) else root while True : parent = r . is_a . first () if ( parent is None or parent is owlready2 . Thing ): break label = asstring ( parent ) if self . is_defined ( label ): node = pydot . Node ( label , ** style . get ( 'defined_class' , {})) # If label contains a hyphen, the node name will # be quoted (bug in pydot?). To work around, set # the name explicitly... node . set_name ( label ) else : node = pydot . Node ( label , ** style . get ( 'class' , {})) node . set_name ( label ) graph . add_node ( node ) if relations is True or 'is_a' in relations : kw = style . get ( 'is_a' , {}) . copy () if isinstance ( edgelabels , dict ): kw [ 'label' ] = edgelabels . get ( 'is_a' , 'is_a' ) elif edgelabels : kw [ 'label' ] = 'is_a' rootnode = graph . get_node ( asstring ( r ))[ 0 ] edge = pydot . Edge ( rootnode , node , ** kw ) graph . add_edge ( edge ) if ( isinstance ( parents , str ) and label == parents ): break r = parent # Add edges for node in graph . get_nodes (): try : entity = self . get_by_label ( node . get_name ()) except ( KeyError , NoSuchLabelError ): continue # Add is_a edges targets = [ e for e in entity . is_a if not isinstance ( e , ( owlready2 . ThingClass , owlready2 . ObjectPropertyClass , owlready2 . PropertyClass ))] self . _get_dot_add_edges ( graph , entity , targets , 'relations' , relations , # style=style.get('relations', style.get('other', {})), style = style . get ( 'other' , {}), edgelabels = edgelabels , constraint = constraint , ) # Add equivalent_to edges if relations is True or 'equivalent_to' in relations : self . _get_dot_add_edges ( graph , entity , entity . equivalent_to , 'equivalent_to' , relations , style . get ( 'equivalent_to' , {}), edgelabels = edgelabels , constraint = constraint , ) # disjoint_with if hasattr ( entity , 'disjoints' ) and ( relations is True or 'disjoint_with' in relations ): self . _get_dot_add_edges ( graph , entity , entity . disjoints (), 'disjoint_with' , relations , style . get ( 'disjoint_with' , {}), edgelabels = edgelabels , constraint = constraint , ) # Add inverse_of if ( hasattr ( entity , 'inverse_property' ) and ( relations is True or 'inverse_of' in relations ) and entity . inverse_property not in ( None , entity )): self . _get_dot_add_edges ( graph , entity , [ entity . inverse_property ], 'inverse_of' , relations , style . get ( 'inverse_of' , {}), edgelabels = edgelabels , constraint = constraint , ) return graph","title":"Parameters"},{"location":"api_reference/ontopy/ontograph/#ontopy.ontograph.OntoGraph.get_dot_relations_graph","text":"Returns a disjoined graph of all relations. This method simply calls get_dot_graph() with all root relations. All arguments are passed on. Source code in ontopy/ontograph.py def get_dot_relations_graph ( self , graph = None , relations = 'is_a' , style = None ): \"\"\"Returns a disjoined graph of all relations. This method simply calls get_dot_graph() with all root relations. All arguments are passed on. \"\"\" rels = tuple ( self . get_relations ()) roots = [ relation for relation in rels if not any ([ r in rels for r in relation . is_a ])] return self . get_dot_graph ( root = roots , graph = graph , relations = relations , style = style )","title":"get_dot_relations_graph()"},{"location":"api_reference/ontopy/ontograph/#ontopy.ontograph.get_figsize","text":"Returns figure size (width, height) in points of figures for the current pydot graph object graph . Source code in ontopy/ontograph.py def get_figsize ( graph ): \"\"\"Returns figure size (width, height) in points of figures for the current pydot graph object `graph`.\"\"\" with tempfile . TemporaryDirectory () as tmpdir : tmpfile = os . path . join ( tmpdir , 'graph.svg' ) graph . write_svg ( tmpfile ) xml = ET . parse ( tmpfile ) svg = xml . getroot () width = svg . attrib [ 'width' ] height = svg . attrib [ 'height' ] assert width . endswith ( 'pt' ) # ensure that units are in points def asfloat ( s ): return float ( re . match ( r '^[\\d.]+' , s ) . group ()) return asfloat ( width ), asfloat ( height )","title":"get_figsize()"},{"location":"api_reference/ontopy/ontology/","text":"ontology \u00b6 A module adding additional functionality to owlready2. The main additions includes: - Visualisation of taxonomy and ontology as graphs (using pydot, see ontograph.py). The class extension is defined within. If desirable some of this may be moved back into owlready2. NoSuchLabelError ( LookupError , AttributeError ) \u00b6 Error raised when a label cannot be found. Ontology ( Ontology , OntoGraph ) \u00b6 A generic class extending owlready2.Ontology. dir_imported property writable \u00b6 Whether to include imported ontologies in dir() listing. dir_label property writable \u00b6 Whether to include entity label in dir() listing. dir_name property writable \u00b6 Whether to include entity name in dir() listing. dir_preflabel property writable \u00b6 Whether to include entity prefLabel in dir() listing. label_annotations property readonly \u00b6 List of label annotation searched for by get_by_label(). add_label_annotation ( self , iri ) \u00b6 Adds label annotation used by get_by_label(). May be provided either as an IRI or as its owlready2 representation. Source code in ontopy/ontology.py def add_label_annotation ( self , iri ): \"\"\"Adds label annotation used by get_by_label(). May be provided either as an IRI or as its owlready2 representation. \"\"\" la = iri if hasattr ( iri , 'storid' ) else self . world [ iri ] if not la : raise ValueError ( 'IRI not in ontology: %s ' % iri ) if la not in self . _label_annotations : self . _label_annotations . append ( la ) annotation_properties ( self , imported = False ) \u00b6 Returns a generator iterating over all annotation properties defined in the current ontology. If imported is true, annotation properties in imported ontologies will also be included. Source code in ontopy/ontology.py def annotation_properties ( self , imported = False ): \"\"\"Returns a generator iterating over all annotation properties defined in the current ontology. If `imported` is true, annotation properties in imported ontologies will also be included. \"\"\" if imported : return self . world . annotation_properties () else : return super () . annotation_properties () classes ( self , imported = False ) \u00b6 Returns an generator over all classes. If imported is true, will imported classes are also returned. Source code in ontopy/ontology.py def classes ( self , imported = False ): \"\"\"Returns an generator over all classes. If `imported` is true, will imported classes are also returned. \"\"\" if imported : return self . world . classes () else : return super () . classes () closest_common_ancestor ( self , * classes ) \u00b6 Returns closest_common_ancestor for the given classes. Source code in ontopy/ontology.py def closest_common_ancestor ( self , * classes ): \"\"\"Returns closest_common_ancestor for the given classes.\"\"\" mros = [ cls . mro () for cls in classes ] track = defaultdict ( int ) while mros : for mro in mros : cur = mro . pop ( 0 ) track [ cur ] += 1 if track [ cur ] == len ( classes ): return cur if len ( mro ) == 0 : mros . remove ( mro ) assert ( 0 ) # should never be reached... closest_common_ancestors ( self , cls1 , cls2 ) \u00b6 Returns a list with closest_common_ancestor for cls1 and cls2 Source code in ontopy/ontology.py def closest_common_ancestors ( self , cls1 , cls2 ): \"\"\"Returns a list with closest_common_ancestor for cls1 and cls2\"\"\" distances = {} for ancestor in self . common_ancestors ( cls1 , cls2 ): distances [ ancestor ] = ( self . number_of_generations ( cls1 , ancestor ) + self . number_of_generations ( cls2 , ancestor )) return [ ancestor for ancestor , distance in distances . items () if distance == min ( distances . values ())] common_ancestors ( self , cls1 , cls2 ) \u00b6 Return a list of common ancestors for cls1 and cls2 . Source code in ontopy/ontology.py def common_ancestors ( self , cls1 , cls2 ): \"\"\"Return a list of common ancestors for `cls1` and `cls2`.\"\"\" return set ( cls1 . ancestors ()) . intersection ( cls2 . ancestors ()) data_properties ( self , imported = False ) \u00b6 Returns an generator over all data properties. If imported is true, will imported data properties are also returned. Source code in ontopy/ontology.py def data_properties ( self , imported = False ): \"\"\"Returns an generator over all data properties. If `imported` is true, will imported data properties are also returned. \"\"\" if imported : return self . world . data_properties () else : return super () . data_properties () get_ancestors ( self , classes , include = 'all' , strict = True ) \u00b6 Return ancestors of all classes in classes . classes to be provided as list The values of include may be: - None: ignore this argument - \"all\": Include all ancestors. - \"closest\": Include all ancestors up to the closest common ancestor of all classes. - int: Include this number of ancestor levels. Here include may be an integer or a string that can be converted to int. Source code in ontopy/ontology.py def get_ancestors ( self , classes , include = 'all' , strict = True ): \"\"\"Return ancestors of all classes in `classes`. classes to be provided as list The values of `include` may be: - None: ignore this argument - \"all\": Include all ancestors. - \"closest\": Include all ancestors up to the closest common ancestor of all classes. - int: Include this number of ancestor levels. Here `include` may be an integer or a string that can be converted to int. \"\"\" ancestors = set () if not classes : return ancestors def addancestors ( e , n , s ): if n > 0 : for p in e . get_parents ( strict = True ): s . add ( p ) addancestors ( p , n - 1 , s ) if isinstance ( include , str ) and include . isdigit (): include = int ( include ) if include == 'all' : ancestors . update ( * ( c . ancestors () for c in classes )) elif include == 'closest' : closest = self . closest_common_ancestor ( * classes ) for c in classes : ancestors . update ( a for a in c . ancestors () if closest in a . ancestors ()) elif isinstance ( include , int ): for e in classes : addancestors ( e , int ( include ), ancestors ) elif include not in ( None , 'None' , 'none' , '' ): raise ValueError ( 'include must be \"all\", \"closest\" or None' ) if strict : return ancestors . difference ( classes ) else : return ancestors get_annotations ( self , entity ) \u00b6 Returns a dict with annotations for entity . Entity may be given either as a ThingClass object or as a label. Source code in ontopy/ontology.py def get_annotations ( self , entity ): \"\"\"Returns a dict with annotations for `entity`. Entity may be given either as a ThingClass object or as a label.\"\"\" warnings . warn ( 'Ontology.get_annotations(entity) is deprecated. ' 'Use entity.get_annotations() instead.' , DeprecationWarning ) if isinstance ( entity , str ): entity = self . get_by_label ( entity ) d = { 'comment' : getattr ( entity , 'comment' , '' )} for a in self . annotation_properties (): d [ a . label . first ()] = [ o . strip ( '\"' ) for s , p , o in self . get_triples ( entity . storid , a . storid , None )] return d get_branch ( self , root , leafs = (), include_leafs = True , strict_leafs = False , exclude = None , sort = False ) \u00b6 Returns a set with all direct and indirect subclasses of root . Any subclass found in the sequence leafs will be included in the returned list, but its subclasses will not. The elements of leafs may be ThingClass objects or labels. Subclasses of any subclass found in the sequence leafs will be excluded from the returned list, where the elements of leafs may be ThingClass objects or labels. If include_leafs is true, the leafs are included in the returned list, otherwise they are not. If strict_leafs is true, any descendant of a leaf will be excluded in the returned set. If given, exclude may be a sequence of classes, including their subclasses, to exclude from the output. If sort is True, a list sorted according to depth and label will be returned instead of a set. Source code in ontopy/ontology.py def get_branch ( self , root , leafs = (), include_leafs = True , strict_leafs = False , exclude = None , sort = False ): \"\"\"Returns a set with all direct and indirect subclasses of `root`. Any subclass found in the sequence `leafs` will be included in the returned list, but its subclasses will not. The elements of `leafs` may be ThingClass objects or labels. Subclasses of any subclass found in the sequence `leafs` will be excluded from the returned list, where the elements of `leafs` may be ThingClass objects or labels. If `include_leafs` is true, the leafs are included in the returned list, otherwise they are not. If `strict_leafs` is true, any descendant of a leaf will be excluded in the returned set. If given, `exclude` may be a sequence of classes, including their subclasses, to exclude from the output. If `sort` is True, a list sorted according to depth and label will be returned instead of a set. \"\"\" def _branch ( root , leafs ): if root not in leafs : branch = { root , } for c in root . subclasses (): # Defining a branch is actually quite tricky. Consider # the case: # # L isA R # A isA L # A isA R # # where R is the root, L is a leaf and A is a direct # child of both. Logically, since A is a child of the # leaf we want to skip A. But a strait forward imple- # mentation will see that A is a child of the root and # include it. Requireing that the R should be a strict # parent of A solves this. if root in c . get_parents ( strict = True ): branch . update ( _branch ( c , leafs )) else : branch = { root , } if include_leafs else set () return branch if isinstance ( root , str ): root = self . get_by_label ( root ) leafs = set ( self . get_by_label ( leaf ) if isinstance ( leaf , str ) else leaf for leaf in leafs ) leafs . discard ( root ) if exclude : exclude = set ( self . get_by_label ( e ) if isinstance ( e , str ) else e for e in exclude ) leafs . update ( exclude ) branch = _branch ( root , leafs ) # Exclude all descendants of any leaf if strict_leafs : descendants = root . descendants () for leaf in leafs : if leaf in descendants : branch . difference_update ( leaf . descendants ( include_self = False )) if exclude : branch . difference_update ( exclude ) # Sort according to depth, then by label if sort : branch = sorted ( sorted ( branch , key = lambda x : asstring ( x )), key = lambda x : len ( x . mro ())) return branch get_by_label ( self , label , label_annotations = None , namespace = None ) \u00b6 Returns entity with label annotation label . label_annotations is a sequence of label annotation names to look up. Defaults to the label_annotations property. If namespace is provided, it should be the last component of the base iri of an ontology (with trailing slash (/) or hash (#) stripped off). The search for a matching label will be limited to this namespace. If several entities have the same label, only the one which is found first is returned.Use get_by_label_all() to get all matches. A NoSuchLabelError is raised if label cannot be found. Note \u00b6 The current implementation also supports \"*\" as a wildcard matching any number of characters. This may change in the future. Source code in ontopy/ontology.py def get_by_label ( self , label , label_annotations = None , namespace = None ): \"\"\"Returns entity with label annotation `label`. `label_annotations` is a sequence of label annotation names to look up. Defaults to the `label_annotations` property. If `namespace` is provided, it should be the last component of the base iri of an ontology (with trailing slash (/) or hash (#) stripped off). The search for a matching label will be limited to this namespace. If several entities have the same label, only the one which is found first is returned.Use get_by_label_all() to get all matches. A NoSuchLabelError is raised if `label` cannot be found. Note ---- The current implementation also supports \"*\" as a wildcard matching any number of characters. This may change in the future. \"\"\" if 'namespaces' in self . __dict__ : if namespace : if namespace in self . namespaces : for e in self . get_by_label_all ( label , label_annotations = label_annotations ): if e . namespace == self . namespaces [ namespace ]: return e raise NoSuchLabelError ( 'No label annotations matches \" %s \" in ' 'namespace \" %s \"' % ( label , namespace )) elif label in self . namespaces : return self . namespaces [ label ] if label_annotations is None : annotations = ( la . name for la in self . label_annotations ) else : annotations = ( s . name if hasattr ( s , 'storid' ) else s for s in label_annotations ) for key in annotations : e = self . search_one ( ** { key : label }) if e : return e if self . _special_labels and label in self . _special_labels : return self . _special_labels [ label ] e = self . world [ self . base_iri + label ] if e : return e raise NoSuchLabelError ( 'No label annotations matches %s ' % label ) get_by_label_all ( self , label , label_annotations = None , namespace = None ) \u00b6 Like get_by_label(), but returns a list with all matching labels. Returns an empty list if no matches could be found. Source code in ontopy/ontology.py def get_by_label_all ( self , label , label_annotations = None , namespace = None ): \"\"\"Like get_by_label(), but returns a list with all matching labels. Returns an empty list if no matches could be found. \"\"\" if label_annotations is None : annotations = ( la . name for la in self . label_annotations ) else : annotations = ( s . name if hasattr ( s , 'storid' ) else s for s in label_annotations ) e = self . world . search ( ** { annotations . __next__ (): label }) for key in annotations : e . extend ( self . world . search ( ** { key : label })) if self . _special_labels and label in self . _special_labels : e . append ( self . _special_labels [ label ]) if namespace : return [ ns for ns in e if ns . namespace . name == namespace ] return e get_entities ( self , imported = True , classes = True , individuals = True , object_properties = True , data_properties = True , annotation_properties = True ) \u00b6 Return a generator over (optionally) all classes, individuals, object_properties, data_properties and annotation_properties. If imported is true, entities in imported ontologies will also be included. Source code in ontopy/ontology.py def get_entities ( self , imported = True , classes = True , individuals = True , object_properties = True , data_properties = True , annotation_properties = True ): \"\"\"Return a generator over (optionally) all classes, individuals, object_properties, data_properties and annotation_properties. If `imported` is true, entities in imported ontologies will also be included. \"\"\" g = [] if classes : g . append ( self . classes ( imported )) if individuals : g . append ( self . individuals ( imported )) if object_properties : g . append ( self . object_properties ( imported )) if data_properties : g . append ( self . data_properties ( imported )) if annotation_properties : g . append ( self . annotation_properties ( imported )) for e in itertools . chain ( * g ): yield e get_graph ( self , ** kwargs ) \u00b6 Returns a new graph object. See emmo.graph.OntoGraph. Note that this method requires the Python graphviz package. Source code in ontopy/ontology.py def get_graph ( self , ** kwargs ): \"\"\"Returns a new graph object. See emmo.graph.OntoGraph. Note that this method requires the Python graphviz package. \"\"\" from ontopy.graph import OntoGraph return OntoGraph ( self , ** kwargs ) get_imported_ontologies ( self , recursive = False ) \u00b6 Return a list with imported ontologies. If recursive is true, ontologies imported by imported ontologies are also returned. Source code in ontopy/ontology.py def get_imported_ontologies ( self , recursive = False ): \"\"\"Return a list with imported ontologies. If `recursive` is true, ontologies imported by imported ontologies are also returned. \"\"\" def rec_imported ( onto ): for o in onto . imported_ontologies : if o not in imported : imported . add ( o ) rec_imported ( o ) if recursive : imported = set () rec_imported ( self ) return list ( imported ) else : return self . imported_ontologies get_relations ( self ) \u00b6 Returns a generator for all relations. Source code in ontopy/ontology.py def get_relations ( self ): \"\"\"Returns a generator for all relations.\"\"\" warnings . warn ( 'Ontology.get_relations() is deprecated. ' 'Use onto.object_properties() instead.' , DeprecationWarning ) return self . object_properties () get_root_classes ( self , imported = False ) \u00b6 Returns a list or root classes. Source code in ontopy/ontology.py def get_root_classes ( self , imported = False ): \"\"\"Returns a list or root classes.\"\"\" return [ cls for cls in self . classes ( imported = imported ) if not cls . ancestors () . difference ( set ([ cls , owlready2 . Thing ]))] get_root_data_properties ( self , imported = False ) \u00b6 Returns a list of root object properties. Source code in ontopy/ontology.py def get_root_data_properties ( self , imported = False ): \"\"\"Returns a list of root object properties.\"\"\" props = set ( self . data_properties ( imported = imported )) return [ p for p in props if not props . intersection ( p . is_a )] get_root_object_properties ( self , imported = False ) \u00b6 Returns a list of root object properties. Source code in ontopy/ontology.py def get_root_object_properties ( self , imported = False ): \"\"\"Returns a list of root object properties.\"\"\" props = set ( self . object_properties ( imported = imported )) return [ p for p in props if not props . intersection ( p . is_a )] get_roots ( self , imported = False ) \u00b6 Returns all class, object_property and data_property roots. Source code in ontopy/ontology.py def get_roots ( self , imported = False ): \"\"\"Returns all class, object_property and data_property roots.\"\"\" roots = self . get_root_classes ( imported = imported ) roots . extend ( self . get_root_object_properties ( imported = imported )) roots . extend ( self . get_root_data_properties ( imported = imported )) return roots get_version ( self , as_iri = False ) \u00b6 Returns the version number of the ontology as inferred from the owl:versionIRI tag. If as_iri is True, the full versionIRI is returned. Source code in ontopy/ontology.py def get_version ( self , as_iri = False ): \"\"\"Returns the version number of the ontology as inferred from the owl:versionIRI tag. If `as_iri` is True, the full versionIRI is returned. \"\"\" versionIRI_storid = self . world . _abbreviate ( 'http://www.w3.org/2002/07/owl#versionIRI' ) tokens = self . get_triples ( s = self . storid , p = versionIRI_storid ) if not tokens : raise TypeError ( 'No versionIRI in Ontology %r ' % self . base_iri ) s , p , o = tokens [ 0 ] versionIRI = self . world . _unabbreviate ( o ) if as_iri : return versionIRI else : return infer_version ( self . base_iri , versionIRI ) get_wu_palmer_measure ( self , cls1 , cls2 ) \u00b6 Return Wu-Palmer measure for semantic similarity. Returns Wu-Palmer measure for semantic similarity between two concepts. Wu, Palmer; ACL 94: Proceedings of the 32nd annual meeting on Association for Computational Linguistics, June 1994. Source code in ontopy/ontology.py def get_wu_palmer_measure ( self , cls1 , cls2 ): \"\"\" Return Wu-Palmer measure for semantic similarity. Returns Wu-Palmer measure for semantic similarity between two concepts. Wu, Palmer; ACL 94: Proceedings of the 32nd annual meeting on Association for Computational Linguistics, June 1994. \"\"\" cca = self . closest_common_ancestor ( cls1 , cls2 ) ccadepth = self . number_of_generations ( cca , self . Thing ) n1 = self . number_of_generations ( cls1 , cca ) n2 = self . number_of_generations ( cls2 , cca ) return 2 * ccadepth / ( n1 + n2 + 2 * ccadepth ) individuals ( self , imported = False ) \u00b6 Returns an generator over all individuals. If imported is true, will imported individuals are also returned. Source code in ontopy/ontology.py def individuals ( self , imported = False ): \"\"\"Returns an generator over all individuals. If `imported` is true, will imported individuals are also returned. \"\"\" if imported : return self . world . individuals () else : return super () . individuals () is_defined ( self , entity ) \u00b6 Returns true if the entity is a defined class. Source code in ontopy/ontology.py def is_defined ( self , entity ): \"\"\"Returns true if the entity is a defined class.\"\"\" if isinstance ( entity , str ): entity = self . get_by_label ( entity ) return hasattr ( entity , 'equivalent_to' ) and bool ( entity . equivalent_to ) is_individual ( self , entity ) \u00b6 Returns true if entity is an individual. Source code in ontopy/ontology.py def is_individual ( self , entity ): \"\"\"Returns true if entity is an individual.\"\"\" if isinstance ( entity , str ): entity = self . get_by_label ( entity ) return isinstance ( entity , owlready2 . Thing ) load ( self , only_local = False , filename = None , format = None , reload = None , reload_if_newer = False , url_from_catalog = None , catalog_file = 'catalog-v001.xml' , tmpdir = None , EMMObased = True , ** kwargs ) \u00b6 Load the ontology. Parameters \u00b6 only_local : bool Whether to only read local files. This requires that you have appended the path to the ontology to owlready2.onto_path. filename : str Path to file to load the ontology from. Defaults to base_iri provided to get_ontology(). format : str Format of filename . Default is inferred from filename extension. reload : bool Whether to reload the ontology if it is already loaded. reload_if_newer : bool Whether to reload the ontology if the source has changed since last time it was loaded. url_from_catalog : bool | None Whether to use catalog file to resolve the location of base_iri . If None, the catalog file is used if it exists in the same directory as filename . catalog_file : str Name of Prot\u00e8g\u00e8 catalog file in the same folder as the ontology. This option is used together with only_local and defaults to \"catalog-v001.xml\". tmpdir : str Path to temporary directory. EMMObased : bool Whether this is an EMMO-based ontology or not, default True . kwargs Additional keyword arguments are passed on to owlready2.Ontology.load(). Source code in ontopy/ontology.py def load ( self , only_local = False , filename = None , format = None , reload = None , reload_if_newer = False , url_from_catalog = None , catalog_file = 'catalog-v001.xml' , tmpdir = None , EMMObased = True , ** kwargs ): \"\"\"Load the ontology. Parameters ---------- only_local : bool Whether to only read local files. This requires that you have appended the path to the ontology to owlready2.onto_path. filename : str Path to file to load the ontology from. Defaults to `base_iri` provided to get_ontology(). format : str Format of `filename`. Default is inferred from `filename` extension. reload : bool Whether to reload the ontology if it is already loaded. reload_if_newer : bool Whether to reload the ontology if the source has changed since last time it was loaded. url_from_catalog : bool | None Whether to use catalog file to resolve the location of `base_iri`. If None, the catalog file is used if it exists in the same directory as `filename`. catalog_file : str Name of Prot\u00e8g\u00e8 catalog file in the same folder as the ontology. This option is used together with `only_local` and defaults to \"catalog-v001.xml\". tmpdir : str Path to temporary directory. EMMObased : bool Whether this is an EMMO-based ontology or not, default `True`. kwargs Additional keyword arguments are passed on to owlready2.Ontology.load(). \"\"\" # TODO: make sure that `only_local` argument is respected... if self . loaded : return self self . _load ( only_local = only_local , filename = filename , format = format , reload = reload , reload_if_newer = reload_if_newer , url_from_catalog = url_from_catalog , catalog_file = catalog_file , tmpdir = tmpdir , ** kwargs ) # Enable optimised search by get_by_label() if self . _special_labels is None and EMMObased : for iri in DEFAULT_LABEL_ANNOTATIONS : self . add_label_annotation ( iri ) t = self . world [ 'http://www.w3.org/2002/07/owl#topObjectProperty' ] self . _special_labels = { 'Thing' : owlready2 . Thing , 'Nothing' : owlready2 . Nothing , 'topObjectProperty' : t , 'owl:Thing' : owlready2 . Thing , 'owl:Nothing' : owlready2 . Nothing , 'owl:topObjectProperty' : t , } return self new_entity ( self , name , parent ) \u00b6 Create and return new entity Makes a new entity in the ontology with given parent. Return the new entity Source code in ontopy/ontology.py def new_entity ( self , name , parent ): \"\"\"Create and return new entity Makes a new entity in the ontology with given parent. Return the new entity \"\"\" with self : e = types . new_class ( name , ( parent , )) return e number_of_generations ( self , descendant , ancestor ) \u00b6 Return shortest distance from ancestor to descendant Source code in ontopy/ontology.py def number_of_generations ( self , descendant , ancestor ): \"\"\" Return shortest distance from ancestor to descendant\"\"\" if ancestor not in descendant . ancestors (): raise ValueError ( 'Descendant is not a descendant of ancestor' ) return self . _number_of_generations ( descendant , ancestor , 0 ) object_properties ( self , imported = False ) \u00b6 Returns an generator over all object properties. If imported is true, will imported object properties are also returned. Source code in ontopy/ontology.py def object_properties ( self , imported = False ): \"\"\"Returns an generator over all object properties. If `imported` is true, will imported object properties are also returned. \"\"\" if imported : return self . world . object_properties () else : return super () . object_properties () remove_label_annotation ( self , iri ) \u00b6 Removes label annotation used by get_by_label(). May be provided either as an IRI or as its owlready2 representation. Source code in ontopy/ontology.py def remove_label_annotation ( self , iri ): \"\"\"Removes label annotation used by get_by_label(). May be provided either as an IRI or as its owlready2 representation. \"\"\" la = iri if hasattr ( iri , 'storid' ) else self . world [ iri ] if not la : raise ValueError ( 'IRI not in ontology: %s ' % iri ) self . _label_annotations . remove ( la ) rename_entities ( self , annotations = ( 'prefLabel' , 'label' , 'altLabel' )) \u00b6 Set name of all entities to the first non-empty annotation in annotations . Warning, this method changes all IRIs in the ontology. However, it may be useful to make the ontology more readable and to work with it together with a triple store. Source code in ontopy/ontology.py def rename_entities ( self , annotations = ( 'prefLabel' , 'label' , 'altLabel' ), ): \"\"\"Set `name` of all entities to the first non-empty annotation in `annotations`. Warning, this method changes all IRIs in the ontology. However, it may be useful to make the ontology more readable and to work with it together with a triple store. \"\"\" for e in self . get_entities (): for a in annotations : if hasattr ( e , a ): name = getattr ( e , a ) . first () if name : e . name = name break save ( self , filename = None , format = None , overwrite = False , ** kwargs ) \u00b6 Writes the ontology to file. If overwrite is true and filename exists, it will be removed before saving. The default is to append an existing ontology. Source code in ontopy/ontology.py def save ( self , filename = None , format = None , overwrite = False , ** kwargs ): \"\"\"Writes the ontology to file. If `overwrite` is true and filename exists, it will be removed before saving. The default is to append an existing ontology. \"\"\" if overwrite and filename and os . path . exists ( filename ): os . remove ( filename ) if not format : format = guess_format ( filename , fmap = FMAP ) if ( not _validate_installed_version ( package = \"rdflib\" , min_version = \"6.0.0\" ) and format == FMAP . get ( \"ttl\" , \"\" ) ): from rdflib import __version__ as __rdflib_version__ warnings . warn ( IncompatibleVersion ( \"To correctly convert to Turtle format, rdflib must be \" \"version 6.0.0 or greater, however, the detected rdflib \" \"version used by your Python interpreter is \" f \" { __rdflib_version__ !r} . For more information see the \" \"'Known issues' section of the README.\" ) ) if format in OWLREADY2_FORMATS : revmap = { v : k for k , v in FMAP . items ()} super () . save ( file = filename , format = revmap [ format ], ** kwargs ) else : with tempfile . NamedTemporaryFile ( suffix = '.owl' ) as f : super () . save ( file = f . name , format = 'rdfxml' , ** kwargs ) g = rdflib . Graph () g . parse ( f . name , format = 'xml' ) g . serialize ( destination = filename , format = format ) set_version ( self , version = None , version_iri = None ) \u00b6 Assign version to ontology by asigning owl:versionIRI. If version but not version_iri is provided, the version IRI will be the combination of base_iri and version . Source code in ontopy/ontology.py def set_version ( self , version = None , version_iri = None ): \"\"\"Assign version to ontology by asigning owl:versionIRI. If `version` but not `version_iri` is provided, the version IRI will be the combination of `base_iri` and `version`. \"\"\" versionIRI = 'http://www.w3.org/2002/07/owl#versionIRI' versionIRI_storid = self . world . _abbreviate ( versionIRI ) if self . _has_obj_triple_spo ( s = self . storid , p = versionIRI_storid ): self . _del_obj_triple_spo ( s = self . storid , p = versionIRI_storid ) if not version_iri : if not version : raise TypeError ( 'Either `version` or `version_iri` must be provided' ) head , tail = self . base_iri . rstrip ( '#/' ) . rsplit ( '/' , 1 ) version_iri = '/' . join ([ head , version , tail ]) self . _add_obj_triple_spo ( s = self . storid , p = self . world . _abbreviate ( versionIRI ), o = self . world . _abbreviate ( version_iri ), ) sync_attributes ( self , name_policy = None , name_prefix = '' , class_docstring = 'comment' , sync_imported = False ) \u00b6 This method is intended to be called after you have added new classes (typically via Python) to make sure that attributes like label and comments are defined. If a class, object property, data property or annotation property in the current ontology has no label, the name of the corresponding Python class will be assigned as label. If a class, object property, data property or annotation property has no comment, it will be assigned the docstring of the corresponding Python class. name_policy specify wether and how the names in the ontology should be updated. Valid values are: None not changed \"uuid\" name_prefix followed by a global unique id (UUID). \"sequential\" name_prefix followed a sequantial number. EMMO conventions imply name_policy=='uuid' . If sync_imported is true, all imported ontologies are also updated. The class_docstring argument specifies the annotation that class docstrings are mapped to. Defaults to \"comment\". Source code in ontopy/ontology.py def sync_attributes ( self , name_policy = None , name_prefix = '' , class_docstring = 'comment' , sync_imported = False ): \"\"\"This method is intended to be called after you have added new classes (typically via Python) to make sure that attributes like `label` and `comments` are defined. If a class, object property, data property or annotation property in the current ontology has no label, the name of the corresponding Python class will be assigned as label. If a class, object property, data property or annotation property has no comment, it will be assigned the docstring of the corresponding Python class. `name_policy` specify wether and how the names in the ontology should be updated. Valid values are: None not changed \"uuid\" `name_prefix` followed by a global unique id (UUID). \"sequential\" `name_prefix` followed a sequantial number. EMMO conventions imply ``name_policy=='uuid'``. If `sync_imported` is true, all imported ontologies are also updated. The `class_docstring` argument specifies the annotation that class docstrings are mapped to. Defaults to \"comment\". \"\"\" for cls in itertools . chain ( self . classes (), self . object_properties (), self . data_properties (), self . annotation_properties ()): if not hasattr ( cls , 'prefLabel' ): # no prefLabel - create new annotation property.. with self : class prefLabel ( owlready2 . label ): pass cls . prefLabel = [ locstr ( cls . __name__ , lang = 'en' )] elif not cls . prefLabel : cls . prefLabel . append ( locstr ( cls . __name__ , lang = 'en' )) if class_docstring and hasattr ( cls , '__doc__' ) and cls . __doc__ : getattr ( cls , class_docstring ) . append ( locstr ( inspect . cleandoc ( cls . __doc__ ), lang = 'en' )) for ind in self . individuals (): if not hasattr ( ind , 'prefLabel' ): # no prefLabel - create new annotation property.. with self : class prefLabel ( owlready2 . label ): # noqa: F811 pass ind . prefLabel = [ locstr ( ind . name , lang = 'en' )] elif not ind . prefLabel : ind . prefLabel . append ( locstr ( ind . name , lang = 'en' )) chain = itertools . chain ( self . classes (), self . individuals (), self . object_properties (), self . data_properties (), self . annotation_properties ()) if name_policy == 'uuid' : for obj in chain : obj . name = name_prefix + str ( uuid . uuid5 ( uuid . NAMESPACE_DNS , obj . name )) elif name_policy == 'sequential' : for obj in chain : n = 0 while f ' { self . base_iri }{ name_prefix }{ n } ' in self : n += 1 obj . name = name_prefix + str ( n ) elif name_policy is not None : raise TypeError ( 'invalid name_policy: %r ' % ( name_policy , )) if sync_imported : for onto in self . imported_ontologies : onto . sync_attributes () sync_python_names ( self , annotations = ( 'prefLabel' , 'label' , 'altLabel' )) \u00b6 Update the python_name attribute of all properties. The python_name attribute will be set to the first non-empty annotation in the sequence of annotations in annotations for the property. Source code in ontopy/ontology.py def sync_python_names ( self , annotations = ( 'prefLabel' , 'label' , 'altLabel' )): \"\"\"Update the `python_name` attribute of all properties. The python_name attribute will be set to the first non-empty annotation in the sequence of annotations in `annotations` for the property. \"\"\" def update ( gen ): for prop in gen : for a in annotations : if hasattr ( prop , a ) and getattr ( prop , a ): prop . python_name = getattr ( prop , a ) . first () break update ( self . get_entities ( classes = False , individuals = False , object_properties = False , data_properties = False )) update ( self . get_entities ( classes = False , individuals = False , annotation_properties = False )) sync_reasoner ( self , reasoner = 'FaCT++' , include_imported = False , ** kwargs ) \u00b6 Update current ontology by running the given reasoner. Supported values for reasoner are 'Pellet', 'HermiT' and 'FaCT++'. If include_imported is true, the reasoner will also reason over imported ontologies. Note that this may be very slow with Pellet and HermiT. Keyword arguments are passed to the underlying owlready2 function. Source code in ontopy/ontology.py def sync_reasoner ( self , reasoner = 'FaCT++' , include_imported = False , ** kwargs ): \"\"\"Update current ontology by running the given reasoner. Supported values for `reasoner` are 'Pellet', 'HermiT' and 'FaCT++'. If `include_imported` is true, the reasoner will also reason over imported ontologies. Note that this may be **very** slow with Pellet and HermiT. Keyword arguments are passed to the underlying owlready2 function. \"\"\" if reasoner == 'Pellet' : sync = owlready2 . sync_reasoner_pellet elif reasoner == 'HermiT' : sync = owlready2 . sync_reasoner_hermit elif reasoner == 'FaCT++' : sync = sync_reasoner_factpp else : raise ValueError ( 'unknown reasoner %r . Supported reasoners' 'are \"Pellet\", \"HermiT\" and \"FaCT++\".' , reasoner ) if include_imported : with self : sync ( ** kwargs ) else : sync ([ self ], ** kwargs ) World ( World ) \u00b6 A subclass of owlready2.World. get_ontology ( self , base_iri = 'emmo-inferred' ) \u00b6 Returns a new Ontology from base_iri . The base_iri argument may be one of: - valid URL (possible excluding final .owl or .ttl) - file name (possible excluding final .owl or .ttl) - \"emmo\": load latest stable version of asserted EMMO - \"emmo-inferred\": load latest stable version of inferred EMMO (default) - \"emmo-development\": load latest inferred development version of EMMO Source code in ontopy/ontology.py def get_ontology ( self , base_iri = 'emmo-inferred' ): \"\"\"Returns a new Ontology from `base_iri`. The `base_iri` argument may be one of: - valid URL (possible excluding final .owl or .ttl) - file name (possible excluding final .owl or .ttl) - \"emmo\": load latest stable version of asserted EMMO - \"emmo-inferred\": load latest stable version of inferred EMMO (default) - \"emmo-development\": load latest inferred development version of EMMO \"\"\" if base_iri == 'emmo' : base_iri = ( 'https://raw.githubusercontent.com/emmo-repo/' 'EMMO/master/emmo.ttl' ) elif base_iri == 'emmo-inferred' : base_iri = ( 'https://emmo-repo.github.io/latest-stable/emmo-inferred.ttl' ) elif base_iri == 'emmo-development' : base_iri = ( 'https://emmo-repo.github.io/development/emmo-inferred.ttl' ) if base_iri in self . ontologies : onto = self . ontologies [ base_iri ] elif base_iri + '#' in self . ontologies : onto = self . ontologies [ base_iri + '#' ] elif base_iri + '/' in self . ontologies : onto = self . ontologies [ base_iri + '/' ] else : if os . path . exists ( base_iri ): iri = os . path . abspath ( base_iri ) elif os . path . exists ( base_iri + '.ttl' ): iri = os . path . abspath ( base_iri + '.ttl' ) elif os . path . exists ( base_iri + '.owl' ): iri = os . path . abspath ( base_iri + '.owl' ) else : iri = base_iri if iri [ - 1 ] not in '/#' : iri += '#' onto = Ontology ( self , iri ) return onto get_ontology ( * args , ** kwargs ) \u00b6 Returns a new Ontology from base_iri . This is a convenient function for calling World.get_ontology(). Source code in ontopy/ontology.py def get_ontology ( * args , ** kwargs ): \"\"\"Returns a new Ontology from `base_iri`. This is a convenient function for calling World.get_ontology().\"\"\" return World () . get_ontology ( * args , ** kwargs )","title":"ontology"},{"location":"api_reference/ontopy/ontology/#ontology","text":"A module adding additional functionality to owlready2. The main additions includes: - Visualisation of taxonomy and ontology as graphs (using pydot, see ontograph.py). The class extension is defined within. If desirable some of this may be moved back into owlready2.","title":"ontology"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.NoSuchLabelError","text":"Error raised when a label cannot be found.","title":"NoSuchLabelError"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology","text":"A generic class extending owlready2.Ontology.","title":"Ontology"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.dir_imported","text":"Whether to include imported ontologies in dir() listing.","title":"dir_imported"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.dir_label","text":"Whether to include entity label in dir() listing.","title":"dir_label"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.dir_name","text":"Whether to include entity name in dir() listing.","title":"dir_name"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.dir_preflabel","text":"Whether to include entity prefLabel in dir() listing.","title":"dir_preflabel"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.label_annotations","text":"List of label annotation searched for by get_by_label().","title":"label_annotations"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.add_label_annotation","text":"Adds label annotation used by get_by_label(). May be provided either as an IRI or as its owlready2 representation. Source code in ontopy/ontology.py def add_label_annotation ( self , iri ): \"\"\"Adds label annotation used by get_by_label(). May be provided either as an IRI or as its owlready2 representation. \"\"\" la = iri if hasattr ( iri , 'storid' ) else self . world [ iri ] if not la : raise ValueError ( 'IRI not in ontology: %s ' % iri ) if la not in self . _label_annotations : self . _label_annotations . append ( la )","title":"add_label_annotation()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.annotation_properties","text":"Returns a generator iterating over all annotation properties defined in the current ontology. If imported is true, annotation properties in imported ontologies will also be included. Source code in ontopy/ontology.py def annotation_properties ( self , imported = False ): \"\"\"Returns a generator iterating over all annotation properties defined in the current ontology. If `imported` is true, annotation properties in imported ontologies will also be included. \"\"\" if imported : return self . world . annotation_properties () else : return super () . annotation_properties ()","title":"annotation_properties()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.classes","text":"Returns an generator over all classes. If imported is true, will imported classes are also returned. Source code in ontopy/ontology.py def classes ( self , imported = False ): \"\"\"Returns an generator over all classes. If `imported` is true, will imported classes are also returned. \"\"\" if imported : return self . world . classes () else : return super () . classes ()","title":"classes()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.closest_common_ancestor","text":"Returns closest_common_ancestor for the given classes. Source code in ontopy/ontology.py def closest_common_ancestor ( self , * classes ): \"\"\"Returns closest_common_ancestor for the given classes.\"\"\" mros = [ cls . mro () for cls in classes ] track = defaultdict ( int ) while mros : for mro in mros : cur = mro . pop ( 0 ) track [ cur ] += 1 if track [ cur ] == len ( classes ): return cur if len ( mro ) == 0 : mros . remove ( mro ) assert ( 0 ) # should never be reached...","title":"closest_common_ancestor()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.closest_common_ancestors","text":"Returns a list with closest_common_ancestor for cls1 and cls2 Source code in ontopy/ontology.py def closest_common_ancestors ( self , cls1 , cls2 ): \"\"\"Returns a list with closest_common_ancestor for cls1 and cls2\"\"\" distances = {} for ancestor in self . common_ancestors ( cls1 , cls2 ): distances [ ancestor ] = ( self . number_of_generations ( cls1 , ancestor ) + self . number_of_generations ( cls2 , ancestor )) return [ ancestor for ancestor , distance in distances . items () if distance == min ( distances . values ())]","title":"closest_common_ancestors()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.common_ancestors","text":"Return a list of common ancestors for cls1 and cls2 . Source code in ontopy/ontology.py def common_ancestors ( self , cls1 , cls2 ): \"\"\"Return a list of common ancestors for `cls1` and `cls2`.\"\"\" return set ( cls1 . ancestors ()) . intersection ( cls2 . ancestors ())","title":"common_ancestors()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.data_properties","text":"Returns an generator over all data properties. If imported is true, will imported data properties are also returned. Source code in ontopy/ontology.py def data_properties ( self , imported = False ): \"\"\"Returns an generator over all data properties. If `imported` is true, will imported data properties are also returned. \"\"\" if imported : return self . world . data_properties () else : return super () . data_properties ()","title":"data_properties()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_ancestors","text":"Return ancestors of all classes in classes . classes to be provided as list The values of include may be: - None: ignore this argument - \"all\": Include all ancestors. - \"closest\": Include all ancestors up to the closest common ancestor of all classes. - int: Include this number of ancestor levels. Here include may be an integer or a string that can be converted to int. Source code in ontopy/ontology.py def get_ancestors ( self , classes , include = 'all' , strict = True ): \"\"\"Return ancestors of all classes in `classes`. classes to be provided as list The values of `include` may be: - None: ignore this argument - \"all\": Include all ancestors. - \"closest\": Include all ancestors up to the closest common ancestor of all classes. - int: Include this number of ancestor levels. Here `include` may be an integer or a string that can be converted to int. \"\"\" ancestors = set () if not classes : return ancestors def addancestors ( e , n , s ): if n > 0 : for p in e . get_parents ( strict = True ): s . add ( p ) addancestors ( p , n - 1 , s ) if isinstance ( include , str ) and include . isdigit (): include = int ( include ) if include == 'all' : ancestors . update ( * ( c . ancestors () for c in classes )) elif include == 'closest' : closest = self . closest_common_ancestor ( * classes ) for c in classes : ancestors . update ( a for a in c . ancestors () if closest in a . ancestors ()) elif isinstance ( include , int ): for e in classes : addancestors ( e , int ( include ), ancestors ) elif include not in ( None , 'None' , 'none' , '' ): raise ValueError ( 'include must be \"all\", \"closest\" or None' ) if strict : return ancestors . difference ( classes ) else : return ancestors","title":"get_ancestors()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_annotations","text":"Returns a dict with annotations for entity . Entity may be given either as a ThingClass object or as a label. Source code in ontopy/ontology.py def get_annotations ( self , entity ): \"\"\"Returns a dict with annotations for `entity`. Entity may be given either as a ThingClass object or as a label.\"\"\" warnings . warn ( 'Ontology.get_annotations(entity) is deprecated. ' 'Use entity.get_annotations() instead.' , DeprecationWarning ) if isinstance ( entity , str ): entity = self . get_by_label ( entity ) d = { 'comment' : getattr ( entity , 'comment' , '' )} for a in self . annotation_properties (): d [ a . label . first ()] = [ o . strip ( '\"' ) for s , p , o in self . get_triples ( entity . storid , a . storid , None )] return d","title":"get_annotations()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_branch","text":"Returns a set with all direct and indirect subclasses of root . Any subclass found in the sequence leafs will be included in the returned list, but its subclasses will not. The elements of leafs may be ThingClass objects or labels. Subclasses of any subclass found in the sequence leafs will be excluded from the returned list, where the elements of leafs may be ThingClass objects or labels. If include_leafs is true, the leafs are included in the returned list, otherwise they are not. If strict_leafs is true, any descendant of a leaf will be excluded in the returned set. If given, exclude may be a sequence of classes, including their subclasses, to exclude from the output. If sort is True, a list sorted according to depth and label will be returned instead of a set. Source code in ontopy/ontology.py def get_branch ( self , root , leafs = (), include_leafs = True , strict_leafs = False , exclude = None , sort = False ): \"\"\"Returns a set with all direct and indirect subclasses of `root`. Any subclass found in the sequence `leafs` will be included in the returned list, but its subclasses will not. The elements of `leafs` may be ThingClass objects or labels. Subclasses of any subclass found in the sequence `leafs` will be excluded from the returned list, where the elements of `leafs` may be ThingClass objects or labels. If `include_leafs` is true, the leafs are included in the returned list, otherwise they are not. If `strict_leafs` is true, any descendant of a leaf will be excluded in the returned set. If given, `exclude` may be a sequence of classes, including their subclasses, to exclude from the output. If `sort` is True, a list sorted according to depth and label will be returned instead of a set. \"\"\" def _branch ( root , leafs ): if root not in leafs : branch = { root , } for c in root . subclasses (): # Defining a branch is actually quite tricky. Consider # the case: # # L isA R # A isA L # A isA R # # where R is the root, L is a leaf and A is a direct # child of both. Logically, since A is a child of the # leaf we want to skip A. But a strait forward imple- # mentation will see that A is a child of the root and # include it. Requireing that the R should be a strict # parent of A solves this. if root in c . get_parents ( strict = True ): branch . update ( _branch ( c , leafs )) else : branch = { root , } if include_leafs else set () return branch if isinstance ( root , str ): root = self . get_by_label ( root ) leafs = set ( self . get_by_label ( leaf ) if isinstance ( leaf , str ) else leaf for leaf in leafs ) leafs . discard ( root ) if exclude : exclude = set ( self . get_by_label ( e ) if isinstance ( e , str ) else e for e in exclude ) leafs . update ( exclude ) branch = _branch ( root , leafs ) # Exclude all descendants of any leaf if strict_leafs : descendants = root . descendants () for leaf in leafs : if leaf in descendants : branch . difference_update ( leaf . descendants ( include_self = False )) if exclude : branch . difference_update ( exclude ) # Sort according to depth, then by label if sort : branch = sorted ( sorted ( branch , key = lambda x : asstring ( x )), key = lambda x : len ( x . mro ())) return branch","title":"get_branch()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_by_label","text":"Returns entity with label annotation label . label_annotations is a sequence of label annotation names to look up. Defaults to the label_annotations property. If namespace is provided, it should be the last component of the base iri of an ontology (with trailing slash (/) or hash (#) stripped off). The search for a matching label will be limited to this namespace. If several entities have the same label, only the one which is found first is returned.Use get_by_label_all() to get all matches. A NoSuchLabelError is raised if label cannot be found.","title":"get_by_label()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_by_label--note","text":"The current implementation also supports \"*\" as a wildcard matching any number of characters. This may change in the future. Source code in ontopy/ontology.py def get_by_label ( self , label , label_annotations = None , namespace = None ): \"\"\"Returns entity with label annotation `label`. `label_annotations` is a sequence of label annotation names to look up. Defaults to the `label_annotations` property. If `namespace` is provided, it should be the last component of the base iri of an ontology (with trailing slash (/) or hash (#) stripped off). The search for a matching label will be limited to this namespace. If several entities have the same label, only the one which is found first is returned.Use get_by_label_all() to get all matches. A NoSuchLabelError is raised if `label` cannot be found. Note ---- The current implementation also supports \"*\" as a wildcard matching any number of characters. This may change in the future. \"\"\" if 'namespaces' in self . __dict__ : if namespace : if namespace in self . namespaces : for e in self . get_by_label_all ( label , label_annotations = label_annotations ): if e . namespace == self . namespaces [ namespace ]: return e raise NoSuchLabelError ( 'No label annotations matches \" %s \" in ' 'namespace \" %s \"' % ( label , namespace )) elif label in self . namespaces : return self . namespaces [ label ] if label_annotations is None : annotations = ( la . name for la in self . label_annotations ) else : annotations = ( s . name if hasattr ( s , 'storid' ) else s for s in label_annotations ) for key in annotations : e = self . search_one ( ** { key : label }) if e : return e if self . _special_labels and label in self . _special_labels : return self . _special_labels [ label ] e = self . world [ self . base_iri + label ] if e : return e raise NoSuchLabelError ( 'No label annotations matches %s ' % label )","title":"Note"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_by_label_all","text":"Like get_by_label(), but returns a list with all matching labels. Returns an empty list if no matches could be found. Source code in ontopy/ontology.py def get_by_label_all ( self , label , label_annotations = None , namespace = None ): \"\"\"Like get_by_label(), but returns a list with all matching labels. Returns an empty list if no matches could be found. \"\"\" if label_annotations is None : annotations = ( la . name for la in self . label_annotations ) else : annotations = ( s . name if hasattr ( s , 'storid' ) else s for s in label_annotations ) e = self . world . search ( ** { annotations . __next__ (): label }) for key in annotations : e . extend ( self . world . search ( ** { key : label })) if self . _special_labels and label in self . _special_labels : e . append ( self . _special_labels [ label ]) if namespace : return [ ns for ns in e if ns . namespace . name == namespace ] return e","title":"get_by_label_all()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_entities","text":"Return a generator over (optionally) all classes, individuals, object_properties, data_properties and annotation_properties. If imported is true, entities in imported ontologies will also be included. Source code in ontopy/ontology.py def get_entities ( self , imported = True , classes = True , individuals = True , object_properties = True , data_properties = True , annotation_properties = True ): \"\"\"Return a generator over (optionally) all classes, individuals, object_properties, data_properties and annotation_properties. If `imported` is true, entities in imported ontologies will also be included. \"\"\" g = [] if classes : g . append ( self . classes ( imported )) if individuals : g . append ( self . individuals ( imported )) if object_properties : g . append ( self . object_properties ( imported )) if data_properties : g . append ( self . data_properties ( imported )) if annotation_properties : g . append ( self . annotation_properties ( imported )) for e in itertools . chain ( * g ): yield e","title":"get_entities()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_graph","text":"Returns a new graph object. See emmo.graph.OntoGraph. Note that this method requires the Python graphviz package. Source code in ontopy/ontology.py def get_graph ( self , ** kwargs ): \"\"\"Returns a new graph object. See emmo.graph.OntoGraph. Note that this method requires the Python graphviz package. \"\"\" from ontopy.graph import OntoGraph return OntoGraph ( self , ** kwargs )","title":"get_graph()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_imported_ontologies","text":"Return a list with imported ontologies. If recursive is true, ontologies imported by imported ontologies are also returned. Source code in ontopy/ontology.py def get_imported_ontologies ( self , recursive = False ): \"\"\"Return a list with imported ontologies. If `recursive` is true, ontologies imported by imported ontologies are also returned. \"\"\" def rec_imported ( onto ): for o in onto . imported_ontologies : if o not in imported : imported . add ( o ) rec_imported ( o ) if recursive : imported = set () rec_imported ( self ) return list ( imported ) else : return self . imported_ontologies","title":"get_imported_ontologies()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_relations","text":"Returns a generator for all relations. Source code in ontopy/ontology.py def get_relations ( self ): \"\"\"Returns a generator for all relations.\"\"\" warnings . warn ( 'Ontology.get_relations() is deprecated. ' 'Use onto.object_properties() instead.' , DeprecationWarning ) return self . object_properties ()","title":"get_relations()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_root_classes","text":"Returns a list or root classes. Source code in ontopy/ontology.py def get_root_classes ( self , imported = False ): \"\"\"Returns a list or root classes.\"\"\" return [ cls for cls in self . classes ( imported = imported ) if not cls . ancestors () . difference ( set ([ cls , owlready2 . Thing ]))]","title":"get_root_classes()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_root_data_properties","text":"Returns a list of root object properties. Source code in ontopy/ontology.py def get_root_data_properties ( self , imported = False ): \"\"\"Returns a list of root object properties.\"\"\" props = set ( self . data_properties ( imported = imported )) return [ p for p in props if not props . intersection ( p . is_a )]","title":"get_root_data_properties()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_root_object_properties","text":"Returns a list of root object properties. Source code in ontopy/ontology.py def get_root_object_properties ( self , imported = False ): \"\"\"Returns a list of root object properties.\"\"\" props = set ( self . object_properties ( imported = imported )) return [ p for p in props if not props . intersection ( p . is_a )]","title":"get_root_object_properties()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_roots","text":"Returns all class, object_property and data_property roots. Source code in ontopy/ontology.py def get_roots ( self , imported = False ): \"\"\"Returns all class, object_property and data_property roots.\"\"\" roots = self . get_root_classes ( imported = imported ) roots . extend ( self . get_root_object_properties ( imported = imported )) roots . extend ( self . get_root_data_properties ( imported = imported )) return roots","title":"get_roots()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_version","text":"Returns the version number of the ontology as inferred from the owl:versionIRI tag. If as_iri is True, the full versionIRI is returned. Source code in ontopy/ontology.py def get_version ( self , as_iri = False ): \"\"\"Returns the version number of the ontology as inferred from the owl:versionIRI tag. If `as_iri` is True, the full versionIRI is returned. \"\"\" versionIRI_storid = self . world . _abbreviate ( 'http://www.w3.org/2002/07/owl#versionIRI' ) tokens = self . get_triples ( s = self . storid , p = versionIRI_storid ) if not tokens : raise TypeError ( 'No versionIRI in Ontology %r ' % self . base_iri ) s , p , o = tokens [ 0 ] versionIRI = self . world . _unabbreviate ( o ) if as_iri : return versionIRI else : return infer_version ( self . base_iri , versionIRI )","title":"get_version()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.get_wu_palmer_measure","text":"Return Wu-Palmer measure for semantic similarity. Returns Wu-Palmer measure for semantic similarity between two concepts. Wu, Palmer; ACL 94: Proceedings of the 32nd annual meeting on Association for Computational Linguistics, June 1994. Source code in ontopy/ontology.py def get_wu_palmer_measure ( self , cls1 , cls2 ): \"\"\" Return Wu-Palmer measure for semantic similarity. Returns Wu-Palmer measure for semantic similarity between two concepts. Wu, Palmer; ACL 94: Proceedings of the 32nd annual meeting on Association for Computational Linguistics, June 1994. \"\"\" cca = self . closest_common_ancestor ( cls1 , cls2 ) ccadepth = self . number_of_generations ( cca , self . Thing ) n1 = self . number_of_generations ( cls1 , cca ) n2 = self . number_of_generations ( cls2 , cca ) return 2 * ccadepth / ( n1 + n2 + 2 * ccadepth )","title":"get_wu_palmer_measure()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.individuals","text":"Returns an generator over all individuals. If imported is true, will imported individuals are also returned. Source code in ontopy/ontology.py def individuals ( self , imported = False ): \"\"\"Returns an generator over all individuals. If `imported` is true, will imported individuals are also returned. \"\"\" if imported : return self . world . individuals () else : return super () . individuals ()","title":"individuals()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.is_defined","text":"Returns true if the entity is a defined class. Source code in ontopy/ontology.py def is_defined ( self , entity ): \"\"\"Returns true if the entity is a defined class.\"\"\" if isinstance ( entity , str ): entity = self . get_by_label ( entity ) return hasattr ( entity , 'equivalent_to' ) and bool ( entity . equivalent_to )","title":"is_defined()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.is_individual","text":"Returns true if entity is an individual. Source code in ontopy/ontology.py def is_individual ( self , entity ): \"\"\"Returns true if entity is an individual.\"\"\" if isinstance ( entity , str ): entity = self . get_by_label ( entity ) return isinstance ( entity , owlready2 . Thing )","title":"is_individual()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.load","text":"Load the ontology.","title":"load()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.load--parameters","text":"only_local : bool Whether to only read local files. This requires that you have appended the path to the ontology to owlready2.onto_path. filename : str Path to file to load the ontology from. Defaults to base_iri provided to get_ontology(). format : str Format of filename . Default is inferred from filename extension. reload : bool Whether to reload the ontology if it is already loaded. reload_if_newer : bool Whether to reload the ontology if the source has changed since last time it was loaded. url_from_catalog : bool | None Whether to use catalog file to resolve the location of base_iri . If None, the catalog file is used if it exists in the same directory as filename . catalog_file : str Name of Prot\u00e8g\u00e8 catalog file in the same folder as the ontology. This option is used together with only_local and defaults to \"catalog-v001.xml\". tmpdir : str Path to temporary directory. EMMObased : bool Whether this is an EMMO-based ontology or not, default True . kwargs Additional keyword arguments are passed on to owlready2.Ontology.load(). Source code in ontopy/ontology.py def load ( self , only_local = False , filename = None , format = None , reload = None , reload_if_newer = False , url_from_catalog = None , catalog_file = 'catalog-v001.xml' , tmpdir = None , EMMObased = True , ** kwargs ): \"\"\"Load the ontology. Parameters ---------- only_local : bool Whether to only read local files. This requires that you have appended the path to the ontology to owlready2.onto_path. filename : str Path to file to load the ontology from. Defaults to `base_iri` provided to get_ontology(). format : str Format of `filename`. Default is inferred from `filename` extension. reload : bool Whether to reload the ontology if it is already loaded. reload_if_newer : bool Whether to reload the ontology if the source has changed since last time it was loaded. url_from_catalog : bool | None Whether to use catalog file to resolve the location of `base_iri`. If None, the catalog file is used if it exists in the same directory as `filename`. catalog_file : str Name of Prot\u00e8g\u00e8 catalog file in the same folder as the ontology. This option is used together with `only_local` and defaults to \"catalog-v001.xml\". tmpdir : str Path to temporary directory. EMMObased : bool Whether this is an EMMO-based ontology or not, default `True`. kwargs Additional keyword arguments are passed on to owlready2.Ontology.load(). \"\"\" # TODO: make sure that `only_local` argument is respected... if self . loaded : return self self . _load ( only_local = only_local , filename = filename , format = format , reload = reload , reload_if_newer = reload_if_newer , url_from_catalog = url_from_catalog , catalog_file = catalog_file , tmpdir = tmpdir , ** kwargs ) # Enable optimised search by get_by_label() if self . _special_labels is None and EMMObased : for iri in DEFAULT_LABEL_ANNOTATIONS : self . add_label_annotation ( iri ) t = self . world [ 'http://www.w3.org/2002/07/owl#topObjectProperty' ] self . _special_labels = { 'Thing' : owlready2 . Thing , 'Nothing' : owlready2 . Nothing , 'topObjectProperty' : t , 'owl:Thing' : owlready2 . Thing , 'owl:Nothing' : owlready2 . Nothing , 'owl:topObjectProperty' : t , } return self","title":"Parameters"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.new_entity","text":"Create and return new entity Makes a new entity in the ontology with given parent. Return the new entity Source code in ontopy/ontology.py def new_entity ( self , name , parent ): \"\"\"Create and return new entity Makes a new entity in the ontology with given parent. Return the new entity \"\"\" with self : e = types . new_class ( name , ( parent , )) return e","title":"new_entity()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.number_of_generations","text":"Return shortest distance from ancestor to descendant Source code in ontopy/ontology.py def number_of_generations ( self , descendant , ancestor ): \"\"\" Return shortest distance from ancestor to descendant\"\"\" if ancestor not in descendant . ancestors (): raise ValueError ( 'Descendant is not a descendant of ancestor' ) return self . _number_of_generations ( descendant , ancestor , 0 )","title":"number_of_generations()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.object_properties","text":"Returns an generator over all object properties. If imported is true, will imported object properties are also returned. Source code in ontopy/ontology.py def object_properties ( self , imported = False ): \"\"\"Returns an generator over all object properties. If `imported` is true, will imported object properties are also returned. \"\"\" if imported : return self . world . object_properties () else : return super () . object_properties ()","title":"object_properties()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.remove_label_annotation","text":"Removes label annotation used by get_by_label(). May be provided either as an IRI or as its owlready2 representation. Source code in ontopy/ontology.py def remove_label_annotation ( self , iri ): \"\"\"Removes label annotation used by get_by_label(). May be provided either as an IRI or as its owlready2 representation. \"\"\" la = iri if hasattr ( iri , 'storid' ) else self . world [ iri ] if not la : raise ValueError ( 'IRI not in ontology: %s ' % iri ) self . _label_annotations . remove ( la )","title":"remove_label_annotation()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.rename_entities","text":"Set name of all entities to the first non-empty annotation in annotations . Warning, this method changes all IRIs in the ontology. However, it may be useful to make the ontology more readable and to work with it together with a triple store. Source code in ontopy/ontology.py def rename_entities ( self , annotations = ( 'prefLabel' , 'label' , 'altLabel' ), ): \"\"\"Set `name` of all entities to the first non-empty annotation in `annotations`. Warning, this method changes all IRIs in the ontology. However, it may be useful to make the ontology more readable and to work with it together with a triple store. \"\"\" for e in self . get_entities (): for a in annotations : if hasattr ( e , a ): name = getattr ( e , a ) . first () if name : e . name = name break","title":"rename_entities()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.save","text":"Writes the ontology to file. If overwrite is true and filename exists, it will be removed before saving. The default is to append an existing ontology. Source code in ontopy/ontology.py def save ( self , filename = None , format = None , overwrite = False , ** kwargs ): \"\"\"Writes the ontology to file. If `overwrite` is true and filename exists, it will be removed before saving. The default is to append an existing ontology. \"\"\" if overwrite and filename and os . path . exists ( filename ): os . remove ( filename ) if not format : format = guess_format ( filename , fmap = FMAP ) if ( not _validate_installed_version ( package = \"rdflib\" , min_version = \"6.0.0\" ) and format == FMAP . get ( \"ttl\" , \"\" ) ): from rdflib import __version__ as __rdflib_version__ warnings . warn ( IncompatibleVersion ( \"To correctly convert to Turtle format, rdflib must be \" \"version 6.0.0 or greater, however, the detected rdflib \" \"version used by your Python interpreter is \" f \" { __rdflib_version__ !r} . For more information see the \" \"'Known issues' section of the README.\" ) ) if format in OWLREADY2_FORMATS : revmap = { v : k for k , v in FMAP . items ()} super () . save ( file = filename , format = revmap [ format ], ** kwargs ) else : with tempfile . NamedTemporaryFile ( suffix = '.owl' ) as f : super () . save ( file = f . name , format = 'rdfxml' , ** kwargs ) g = rdflib . Graph () g . parse ( f . name , format = 'xml' ) g . serialize ( destination = filename , format = format )","title":"save()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.set_version","text":"Assign version to ontology by asigning owl:versionIRI. If version but not version_iri is provided, the version IRI will be the combination of base_iri and version . Source code in ontopy/ontology.py def set_version ( self , version = None , version_iri = None ): \"\"\"Assign version to ontology by asigning owl:versionIRI. If `version` but not `version_iri` is provided, the version IRI will be the combination of `base_iri` and `version`. \"\"\" versionIRI = 'http://www.w3.org/2002/07/owl#versionIRI' versionIRI_storid = self . world . _abbreviate ( versionIRI ) if self . _has_obj_triple_spo ( s = self . storid , p = versionIRI_storid ): self . _del_obj_triple_spo ( s = self . storid , p = versionIRI_storid ) if not version_iri : if not version : raise TypeError ( 'Either `version` or `version_iri` must be provided' ) head , tail = self . base_iri . rstrip ( '#/' ) . rsplit ( '/' , 1 ) version_iri = '/' . join ([ head , version , tail ]) self . _add_obj_triple_spo ( s = self . storid , p = self . world . _abbreviate ( versionIRI ), o = self . world . _abbreviate ( version_iri ), )","title":"set_version()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.sync_attributes","text":"This method is intended to be called after you have added new classes (typically via Python) to make sure that attributes like label and comments are defined. If a class, object property, data property or annotation property in the current ontology has no label, the name of the corresponding Python class will be assigned as label. If a class, object property, data property or annotation property has no comment, it will be assigned the docstring of the corresponding Python class. name_policy specify wether and how the names in the ontology should be updated. Valid values are: None not changed \"uuid\" name_prefix followed by a global unique id (UUID). \"sequential\" name_prefix followed a sequantial number. EMMO conventions imply name_policy=='uuid' . If sync_imported is true, all imported ontologies are also updated. The class_docstring argument specifies the annotation that class docstrings are mapped to. Defaults to \"comment\". Source code in ontopy/ontology.py def sync_attributes ( self , name_policy = None , name_prefix = '' , class_docstring = 'comment' , sync_imported = False ): \"\"\"This method is intended to be called after you have added new classes (typically via Python) to make sure that attributes like `label` and `comments` are defined. If a class, object property, data property or annotation property in the current ontology has no label, the name of the corresponding Python class will be assigned as label. If a class, object property, data property or annotation property has no comment, it will be assigned the docstring of the corresponding Python class. `name_policy` specify wether and how the names in the ontology should be updated. Valid values are: None not changed \"uuid\" `name_prefix` followed by a global unique id (UUID). \"sequential\" `name_prefix` followed a sequantial number. EMMO conventions imply ``name_policy=='uuid'``. If `sync_imported` is true, all imported ontologies are also updated. The `class_docstring` argument specifies the annotation that class docstrings are mapped to. Defaults to \"comment\". \"\"\" for cls in itertools . chain ( self . classes (), self . object_properties (), self . data_properties (), self . annotation_properties ()): if not hasattr ( cls , 'prefLabel' ): # no prefLabel - create new annotation property.. with self : class prefLabel ( owlready2 . label ): pass cls . prefLabel = [ locstr ( cls . __name__ , lang = 'en' )] elif not cls . prefLabel : cls . prefLabel . append ( locstr ( cls . __name__ , lang = 'en' )) if class_docstring and hasattr ( cls , '__doc__' ) and cls . __doc__ : getattr ( cls , class_docstring ) . append ( locstr ( inspect . cleandoc ( cls . __doc__ ), lang = 'en' )) for ind in self . individuals (): if not hasattr ( ind , 'prefLabel' ): # no prefLabel - create new annotation property.. with self : class prefLabel ( owlready2 . label ): # noqa: F811 pass ind . prefLabel = [ locstr ( ind . name , lang = 'en' )] elif not ind . prefLabel : ind . prefLabel . append ( locstr ( ind . name , lang = 'en' )) chain = itertools . chain ( self . classes (), self . individuals (), self . object_properties (), self . data_properties (), self . annotation_properties ()) if name_policy == 'uuid' : for obj in chain : obj . name = name_prefix + str ( uuid . uuid5 ( uuid . NAMESPACE_DNS , obj . name )) elif name_policy == 'sequential' : for obj in chain : n = 0 while f ' { self . base_iri }{ name_prefix }{ n } ' in self : n += 1 obj . name = name_prefix + str ( n ) elif name_policy is not None : raise TypeError ( 'invalid name_policy: %r ' % ( name_policy , )) if sync_imported : for onto in self . imported_ontologies : onto . sync_attributes ()","title":"sync_attributes()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.sync_python_names","text":"Update the python_name attribute of all properties. The python_name attribute will be set to the first non-empty annotation in the sequence of annotations in annotations for the property. Source code in ontopy/ontology.py def sync_python_names ( self , annotations = ( 'prefLabel' , 'label' , 'altLabel' )): \"\"\"Update the `python_name` attribute of all properties. The python_name attribute will be set to the first non-empty annotation in the sequence of annotations in `annotations` for the property. \"\"\" def update ( gen ): for prop in gen : for a in annotations : if hasattr ( prop , a ) and getattr ( prop , a ): prop . python_name = getattr ( prop , a ) . first () break update ( self . get_entities ( classes = False , individuals = False , object_properties = False , data_properties = False )) update ( self . get_entities ( classes = False , individuals = False , annotation_properties = False ))","title":"sync_python_names()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.Ontology.sync_reasoner","text":"Update current ontology by running the given reasoner. Supported values for reasoner are 'Pellet', 'HermiT' and 'FaCT++'. If include_imported is true, the reasoner will also reason over imported ontologies. Note that this may be very slow with Pellet and HermiT. Keyword arguments are passed to the underlying owlready2 function. Source code in ontopy/ontology.py def sync_reasoner ( self , reasoner = 'FaCT++' , include_imported = False , ** kwargs ): \"\"\"Update current ontology by running the given reasoner. Supported values for `reasoner` are 'Pellet', 'HermiT' and 'FaCT++'. If `include_imported` is true, the reasoner will also reason over imported ontologies. Note that this may be **very** slow with Pellet and HermiT. Keyword arguments are passed to the underlying owlready2 function. \"\"\" if reasoner == 'Pellet' : sync = owlready2 . sync_reasoner_pellet elif reasoner == 'HermiT' : sync = owlready2 . sync_reasoner_hermit elif reasoner == 'FaCT++' : sync = sync_reasoner_factpp else : raise ValueError ( 'unknown reasoner %r . Supported reasoners' 'are \"Pellet\", \"HermiT\" and \"FaCT++\".' , reasoner ) if include_imported : with self : sync ( ** kwargs ) else : sync ([ self ], ** kwargs )","title":"sync_reasoner()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.World","text":"A subclass of owlready2.World.","title":"World"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.World.get_ontology","text":"Returns a new Ontology from base_iri . The base_iri argument may be one of: - valid URL (possible excluding final .owl or .ttl) - file name (possible excluding final .owl or .ttl) - \"emmo\": load latest stable version of asserted EMMO - \"emmo-inferred\": load latest stable version of inferred EMMO (default) - \"emmo-development\": load latest inferred development version of EMMO Source code in ontopy/ontology.py def get_ontology ( self , base_iri = 'emmo-inferred' ): \"\"\"Returns a new Ontology from `base_iri`. The `base_iri` argument may be one of: - valid URL (possible excluding final .owl or .ttl) - file name (possible excluding final .owl or .ttl) - \"emmo\": load latest stable version of asserted EMMO - \"emmo-inferred\": load latest stable version of inferred EMMO (default) - \"emmo-development\": load latest inferred development version of EMMO \"\"\" if base_iri == 'emmo' : base_iri = ( 'https://raw.githubusercontent.com/emmo-repo/' 'EMMO/master/emmo.ttl' ) elif base_iri == 'emmo-inferred' : base_iri = ( 'https://emmo-repo.github.io/latest-stable/emmo-inferred.ttl' ) elif base_iri == 'emmo-development' : base_iri = ( 'https://emmo-repo.github.io/development/emmo-inferred.ttl' ) if base_iri in self . ontologies : onto = self . ontologies [ base_iri ] elif base_iri + '#' in self . ontologies : onto = self . ontologies [ base_iri + '#' ] elif base_iri + '/' in self . ontologies : onto = self . ontologies [ base_iri + '/' ] else : if os . path . exists ( base_iri ): iri = os . path . abspath ( base_iri ) elif os . path . exists ( base_iri + '.ttl' ): iri = os . path . abspath ( base_iri + '.ttl' ) elif os . path . exists ( base_iri + '.owl' ): iri = os . path . abspath ( base_iri + '.owl' ) else : iri = base_iri if iri [ - 1 ] not in '/#' : iri += '#' onto = Ontology ( self , iri ) return onto","title":"get_ontology()"},{"location":"api_reference/ontopy/ontology/#ontopy.ontology.get_ontology","text":"Returns a new Ontology from base_iri . This is a convenient function for calling World.get_ontology(). Source code in ontopy/ontology.py def get_ontology ( * args , ** kwargs ): \"\"\"Returns a new Ontology from `base_iri`. This is a convenient function for calling World.get_ontology().\"\"\" return World () . get_ontology ( * args , ** kwargs )","title":"get_ontology()"},{"location":"api_reference/ontopy/patch/","text":"patch \u00b6 This module injects some additional methods into owlready2 classes. disjoint_with ( self , reduce = False ) \u00b6 Returns a generator with all classes that are disjoint with self . If reduce is true, all classes that are a descendant of another class will be excluded. Source code in ontopy/patch.py def disjoint_with ( self , reduce = False ): \"\"\"Returns a generator with all classes that are disjoint with `self`. If `reduce` is true, all classes that are a descendant of another class will be excluded.\"\"\" if reduce : s = set ( self . disjoint_with ()) for e in s . copy (): s . difference_update ( e . descendants ( include_self = False )) for e in s : yield e else : for d in self . disjoints (): for e in d . entities : if e is not self : yield e get_class_annotations ( self , all = False , imported = True ) \u00b6 Returns a dict with non-empty annotations. If all is true, also annotations with no value are included. If imported is true, also include annotations defined in imported ontologies. Source code in ontopy/patch.py def get_class_annotations ( self , all = False , imported = True ): \"\"\"Returns a dict with non-empty annotations. If `all` is true, also annotations with no value are included. If `imported` is true, also include annotations defined in imported ontologies. \"\"\" onto = self . namespace . ontology d = { get_preferred_label ( a ): a . _get_values_for_class ( self ) for a in onto . annotation_properties ( imported = imported )} if all : return d else : return { k : v for k , v in d . items () if v } get_indirect_is_a ( self , skip_classes = True ) \u00b6 Returns the set of all isSubclassOf relations of self and its ancestors. If skip_classes is true, indirect classes are not included in the returned set. Source code in ontopy/patch.py def get_indirect_is_a ( self , skip_classes = True ): \"\"\"Returns the set of all isSubclassOf relations of self and its ancestors. If `skip_classes` is true, indirect classes are not included in the returned set. \"\"\" s = set () for e in reversed ( self . mro ()): if hasattr ( e , 'is_a' ): if skip_classes : s . update ( r for r in e . is_a if not isinstance ( r , owlready2 . ThingClass )) else : s . update ( e . is_a ) s . update ( self . is_a ) return s get_individual_annotations ( self , all = False , imported = True ) \u00b6 Returns a dict with non-empty individual annotations. If all is true, also annotations with no value are included. If imported is true, also include annotations defined in imported ontologies. Source code in ontopy/patch.py def get_individual_annotations ( self , all = False , imported = True ): \"\"\"Returns a dict with non-empty individual annotations. If `all` is true, also annotations with no value are included. If `imported` is true, also include annotations defined in imported ontologies. \"\"\" onto = self . namespace . ontology d = { get_preferred_label ( a ): a . _get_values_for_individual ( self ) for a in onto . annotation_properties ( imported = imported )} if all : return d else : return { k : v for k , v in d . items () if v } get_parents ( self , strict = False ) \u00b6 Returns a list of all parents. If strict is true, parents that are parents of other parents are excluded. Source code in ontopy/patch.py def get_parents ( self , strict = False ): \"\"\"Returns a list of all parents. If `strict` is true, parents that are parents of other parents are excluded.\"\"\" if strict : s = self . get_parents () for e in s . copy (): s . difference_update ( e . ancestors ( include_self = False )) return s elif isinstance ( self , ThingClass ): return { cls for cls in self . is_a if isinstance ( cls , ThingClass )} elif isinstance ( self , owlready2 . ObjectPropertyClass ): return { cls for cls in self . is_a if isinstance ( cls , owlready2 . ObjectPropertyClass )} else : assert 0 get_preferred_label ( self ) \u00b6 Returns the preferred label as a string (not list). The following heuristics is used: - if prefLabel annotation property exists, returns the first prefLabel - if label annotation property exists, returns the first label - otherwise return the name Source code in ontopy/patch.py def get_preferred_label ( self ): \"\"\"Returns the preferred label as a string (not list). The following heuristics is used: - if prefLabel annotation property exists, returns the first prefLabel - if label annotation property exists, returns the first label - otherwise return the name \"\"\" if hasattr ( self , 'prefLabel' ) and self . prefLabel : return self . prefLabel [ 0 ] elif hasattr ( self , 'label' ) and self . label : return self . label . first () else : return self . name get_property_annotations ( self , all = False , imported = True ) \u00b6 Returns a dict with non-empty property annotations. If all is true, also annotations with no value are included. If imported is true, also include annotations defined in imported ontologies. Source code in ontopy/patch.py def get_property_annotations ( self , all = False , imported = True ): \"\"\"Returns a dict with non-empty property annotations. If `all` is true, also annotations with no value are included. If `imported` is true, also include annotations defined in imported ontologies. \"\"\" onto = self . namespace . ontology d = { get_preferred_label ( a ): a . _get_values_for_class ( self ) for a in onto . annotation_properties ( imported = imported )} if all : return d else : return { k : v for k , v in d . items () if v } has ( self , name ) \u00b6 Returns true if name Source code in ontopy/patch.py def has ( self , name ): \"\"\"Returns true if `name`\"\"\" return name in set ( self . keys ()) items ( self ) \u00b6 Return a generator over annotation property (name, value_list) pairs associates with this ontology. Source code in ontopy/patch.py def items ( self ): \"\"\"Return a generator over annotation property (name, value_list) pairs associates with this ontology.\"\"\" ns = self . namespace for a in ns . annotation_properties (): if ns . _has_data_triple_spod ( s = ns . storid , p = a . storid ): yield a , self . __getattr__ ( a . name ) keys ( self ) \u00b6 Return a generator over annotation property names associates with this ontology. Source code in ontopy/patch.py def keys ( self ): \"\"\"Return a generator over annotation property names associates with this ontology.\"\"\" ns = self . namespace for a in ns . annotation_properties (): if ns . _has_data_triple_spod ( s = ns . storid , p = a . storid ): yield a","title":"patch"},{"location":"api_reference/ontopy/patch/#patch","text":"This module injects some additional methods into owlready2 classes.","title":"patch"},{"location":"api_reference/ontopy/patch/#ontopy.patch.disjoint_with","text":"Returns a generator with all classes that are disjoint with self . If reduce is true, all classes that are a descendant of another class will be excluded. Source code in ontopy/patch.py def disjoint_with ( self , reduce = False ): \"\"\"Returns a generator with all classes that are disjoint with `self`. If `reduce` is true, all classes that are a descendant of another class will be excluded.\"\"\" if reduce : s = set ( self . disjoint_with ()) for e in s . copy (): s . difference_update ( e . descendants ( include_self = False )) for e in s : yield e else : for d in self . disjoints (): for e in d . entities : if e is not self : yield e","title":"disjoint_with()"},{"location":"api_reference/ontopy/patch/#ontopy.patch.get_class_annotations","text":"Returns a dict with non-empty annotations. If all is true, also annotations with no value are included. If imported is true, also include annotations defined in imported ontologies. Source code in ontopy/patch.py def get_class_annotations ( self , all = False , imported = True ): \"\"\"Returns a dict with non-empty annotations. If `all` is true, also annotations with no value are included. If `imported` is true, also include annotations defined in imported ontologies. \"\"\" onto = self . namespace . ontology d = { get_preferred_label ( a ): a . _get_values_for_class ( self ) for a in onto . annotation_properties ( imported = imported )} if all : return d else : return { k : v for k , v in d . items () if v }","title":"get_class_annotations()"},{"location":"api_reference/ontopy/patch/#ontopy.patch.get_indirect_is_a","text":"Returns the set of all isSubclassOf relations of self and its ancestors. If skip_classes is true, indirect classes are not included in the returned set. Source code in ontopy/patch.py def get_indirect_is_a ( self , skip_classes = True ): \"\"\"Returns the set of all isSubclassOf relations of self and its ancestors. If `skip_classes` is true, indirect classes are not included in the returned set. \"\"\" s = set () for e in reversed ( self . mro ()): if hasattr ( e , 'is_a' ): if skip_classes : s . update ( r for r in e . is_a if not isinstance ( r , owlready2 . ThingClass )) else : s . update ( e . is_a ) s . update ( self . is_a ) return s","title":"get_indirect_is_a()"},{"location":"api_reference/ontopy/patch/#ontopy.patch.get_individual_annotations","text":"Returns a dict with non-empty individual annotations. If all is true, also annotations with no value are included. If imported is true, also include annotations defined in imported ontologies. Source code in ontopy/patch.py def get_individual_annotations ( self , all = False , imported = True ): \"\"\"Returns a dict with non-empty individual annotations. If `all` is true, also annotations with no value are included. If `imported` is true, also include annotations defined in imported ontologies. \"\"\" onto = self . namespace . ontology d = { get_preferred_label ( a ): a . _get_values_for_individual ( self ) for a in onto . annotation_properties ( imported = imported )} if all : return d else : return { k : v for k , v in d . items () if v }","title":"get_individual_annotations()"},{"location":"api_reference/ontopy/patch/#ontopy.patch.get_parents","text":"Returns a list of all parents. If strict is true, parents that are parents of other parents are excluded. Source code in ontopy/patch.py def get_parents ( self , strict = False ): \"\"\"Returns a list of all parents. If `strict` is true, parents that are parents of other parents are excluded.\"\"\" if strict : s = self . get_parents () for e in s . copy (): s . difference_update ( e . ancestors ( include_self = False )) return s elif isinstance ( self , ThingClass ): return { cls for cls in self . is_a if isinstance ( cls , ThingClass )} elif isinstance ( self , owlready2 . ObjectPropertyClass ): return { cls for cls in self . is_a if isinstance ( cls , owlready2 . ObjectPropertyClass )} else : assert 0","title":"get_parents()"},{"location":"api_reference/ontopy/patch/#ontopy.patch.get_preferred_label","text":"Returns the preferred label as a string (not list). The following heuristics is used: - if prefLabel annotation property exists, returns the first prefLabel - if label annotation property exists, returns the first label - otherwise return the name Source code in ontopy/patch.py def get_preferred_label ( self ): \"\"\"Returns the preferred label as a string (not list). The following heuristics is used: - if prefLabel annotation property exists, returns the first prefLabel - if label annotation property exists, returns the first label - otherwise return the name \"\"\" if hasattr ( self , 'prefLabel' ) and self . prefLabel : return self . prefLabel [ 0 ] elif hasattr ( self , 'label' ) and self . label : return self . label . first () else : return self . name","title":"get_preferred_label()"},{"location":"api_reference/ontopy/patch/#ontopy.patch.get_property_annotations","text":"Returns a dict with non-empty property annotations. If all is true, also annotations with no value are included. If imported is true, also include annotations defined in imported ontologies. Source code in ontopy/patch.py def get_property_annotations ( self , all = False , imported = True ): \"\"\"Returns a dict with non-empty property annotations. If `all` is true, also annotations with no value are included. If `imported` is true, also include annotations defined in imported ontologies. \"\"\" onto = self . namespace . ontology d = { get_preferred_label ( a ): a . _get_values_for_class ( self ) for a in onto . annotation_properties ( imported = imported )} if all : return d else : return { k : v for k , v in d . items () if v }","title":"get_property_annotations()"},{"location":"api_reference/ontopy/patch/#ontopy.patch.has","text":"Returns true if name Source code in ontopy/patch.py def has ( self , name ): \"\"\"Returns true if `name`\"\"\" return name in set ( self . keys ())","title":"has()"},{"location":"api_reference/ontopy/patch/#ontopy.patch.items","text":"Return a generator over annotation property (name, value_list) pairs associates with this ontology. Source code in ontopy/patch.py def items ( self ): \"\"\"Return a generator over annotation property (name, value_list) pairs associates with this ontology.\"\"\" ns = self . namespace for a in ns . annotation_properties (): if ns . _has_data_triple_spod ( s = ns . storid , p = a . storid ): yield a , self . __getattr__ ( a . name )","title":"items()"},{"location":"api_reference/ontopy/patch/#ontopy.patch.keys","text":"Return a generator over annotation property names associates with this ontology. Source code in ontopy/patch.py def keys ( self ): \"\"\"Return a generator over annotation property names associates with this ontology.\"\"\" ns = self . namespace for a in ns . annotation_properties (): if ns . _has_data_triple_spod ( s = ns . storid , p = a . storid ): yield a","title":"keys()"},{"location":"api_reference/ontopy/utils/","text":"utils \u00b6 Some generic utility functions. IncompatibleVersion ( Warning ) \u00b6 An installed dependency version may be incompatible with a functionality of this package - or rather an outcome of a functionality. This is not critical, hence this is only a warning. ReadCatalogError ( OSError ) \u00b6 Error reading catalog file. UnknownVersion ( Exception ) \u00b6 Cannot retrieve version from a package. annotate_with_ontology ( onto , imported = True ) \u00b6 Annotate all entities with the ontology_name and ontology_iri . If imported is true, imported ontologies will also be annotated. The ontology name and IRI are important contextual information that is lost when ontologies are inferred and/or squashed. This function retain this information as annotations. Source code in ontopy/utils.py def annotate_with_ontology ( onto , imported = True ): \"\"\"Annotate all entities with the `ontology_name` and `ontology_iri`. If imported is true, imported ontologies will also be annotated. The ontology name and IRI are important contextual information that is lost when ontologies are inferred and/or squashed. This function retain this information as annotations. \"\"\" with onto : if 'ontology_name' not in onto . world . _props : types . new_class ( 'ontology_name' , ( owlready2 . AnnotationProperty , )) if 'ontology_iri' not in onto . world . _props : types . new_class ( 'ontology_iri' , ( owlready2 . AnnotationProperty , )) for e in onto . get_entities ( imported = imported ): if onto . name not in getattr ( e , 'ontology_name' ): setattr ( e , 'ontology_name' , onto . name ) if onto . base_iri not in getattr ( e , 'ontology_iri' ): setattr ( e , 'ontology_iri' , onto . base_iri ) asstring ( expr , link = ' {name} ' , n = 0 , exclude_object = False ) \u00b6 Returns a string representation of expr , which may be an entity, restriction, or logical expression of these. link is a format string for formatting references to entities or relations. It may contain the keywords \"name\", \"url\" and \"lowerurl\". n is the recursion depth and only intended for internal use. If exclude_object is true, the object will be excluded in restrictions. Source code in ontopy/utils.py def asstring ( expr , link = ' {name} ' , n = 0 , exclude_object = False ): \"\"\"Returns a string representation of `expr`, which may be an entity, restriction, or logical expression of these. `link` is a format string for formatting references to entities or relations. It may contain the keywords \"name\", \"url\" and \"lowerurl\". `n` is the recursion depth and only intended for internal use. If `exclude_object` is true, the object will be excluded in restrictions. \"\"\" def fmt ( e ): \"\"\"Returns the formatted label of `e`.\"\"\" name = None for attr in ( 'prefLabel' , 'label' , '__name__' , 'name' ): if hasattr ( e , attr ) and getattr ( e , attr ): name = getattr ( e , attr ) if not isinstance ( name , str ) and hasattr ( name , '__getitem__' ): name = name [ 0 ] break if not name : name = str ( e ) . replace ( '.' , ':' ) url = name if re . match ( r '^[a-z]+://' , name ) else '#' + name return link . format ( name = name , url = url , lowerurl = url . lower ()) if isinstance ( expr , str ): # return link.format(name=expr) return fmt ( expr ) elif isinstance ( expr , owlready2 . Restriction ): rlabel = owlready2 . class_construct . _restriction_type_2_label [ expr . type ] if isinstance ( expr . property , ( owlready2 . ObjectPropertyClass , owlready2 . DataPropertyClass )): s = fmt ( expr . property ) elif isinstance ( expr . property , owlready2 . Inverse ): s = 'Inverse( %s )' % asstring ( expr . property . property , link , n + 1 ) else : print ( '*** WARNING: unknown restriction property: %r ' % expr . property ) s = fmt ( expr . property ) if not rlabel : pass elif expr . type in ( owlready2 . MIN , owlready2 . MAX , owlready2 . EXACTLY ): s += ' %s %d ' % ( rlabel , expr . cardinality ) elif expr . type in ( owlready2 . SOME , owlready2 . ONLY , owlready2 . VALUE , owlready2 . HAS_SELF ): s += ' %s ' % rlabel else : print ( '*** WARNING: unknown relation' , expr , rlabel ) s += ' %s ' % rlabel if not exclude_object : if isinstance ( expr . value , str ): s += ' \" %s \"' % asstring ( expr . value , link , n + 1 ) else : s += ' %s ' % asstring ( expr . value , link , n + 1 ) return s elif isinstance ( expr , owlready2 . Or ): s = ' %s ' if n == 0 else '( %s )' return s % ' or ' . join ([ asstring ( c , link , n + 1 ) for c in expr . Classes ]) elif isinstance ( expr , owlready2 . And ): s = ' %s ' if n == 0 else '( %s )' return s % ' and ' . join ([ asstring ( c , link , n + 1 ) for c in expr . Classes ]) elif isinstance ( expr , owlready2 . Not ): return 'not %s ' % asstring ( expr . Class , link , n + 1 ) elif isinstance ( expr , owlready2 . ThingClass ): return fmt ( expr ) elif isinstance ( expr , owlready2 . PropertyClass ): return fmt ( expr ) elif isinstance ( expr , owlready2 . Thing ): # instance (individual) return fmt ( expr ) elif isinstance ( expr , owlready2 . class_construct . Inverse ): return 'inverse( %s )' % fmt ( expr . property ) elif isinstance ( expr , owlready2 . disjoint . AllDisjoint ): return fmt ( expr ) elif isinstance ( expr , ( bool , int , float )): return repr ( expr ) # Check for subclasses elif issubclass ( expr , ( bool , int , float , str )): return fmt ( expr . __class__ . __name__ ) elif issubclass ( expr , datetime . date ): return 'date' elif issubclass ( expr , datetime . time ): return 'datetime' elif issubclass ( expr , datetime . datetime ): return 'datetime' else : raise RuntimeError ( 'Unknown expression: %r (type: %r )' % ( expr , type ( expr ))) camelsplit ( s ) \u00b6 Splits CamelCase string s before upper case letters (except if there is a sequence of upper case letters). Source code in ontopy/utils.py def camelsplit ( s ): \"\"\"Splits CamelCase string `s` before upper case letters (except if there is a sequence of upper case letters).\"\"\" if len ( s ) < 2 : return s result = [] prev_lower = False prev_isspace = True c = s [ 0 ] for next in s [ 1 :]: if (( not prev_isspace and c . isupper () and next . islower ()) or prev_lower and c . isupper ()): result . append ( ' ' ) result . append ( c ) prev_lower = c . islower () prev_isspace = c . isspace () c = next result . append ( next ) return '' . join ( result ) convert_imported ( input , output , input_format = None , output_format = 'xml' , url_from_catalog = None , catalog_file = 'catalog-v001.xml' ) \u00b6 Convert imported ontologies. Store the output in a directory structure matching the source files. This require catalog file(s) to be present. Warning To convert to Turtle ( .ttl ) format, you must have installed rdflib>=6.0.0 . See Known issues for more information. Parameters: Name Type Description Default input input ontology file name required output output ontology file path. The directory part of output will be the root of the generated directory structure required input_format input format. The default is to infer from input None output_format output format. The default is to infer from output 'xml' url_from_catalog bool | None. Whether to read urls form catalog file. If None, the catalog file will be used if it exists. None catalog_file name of catalog file, that maps ontology IRIs to local file names 'catalog-v001.xml' Source code in ontopy/utils.py def convert_imported ( input , output , input_format = None , output_format = 'xml' , url_from_catalog = None , catalog_file = 'catalog-v001.xml' ): \"\"\"Convert imported ontologies. Store the output in a directory structure matching the source files. This require catalog file(s) to be present. Warning: To convert to Turtle (`.ttl`) format, you must have installed `rdflib>=6.0.0`. See [Known issues](../../../#known-issues) for more information. Args: input: input ontology file name output: output ontology file path. The directory part of `output` will be the root of the generated directory structure input_format: input format. The default is to infer from `input` output_format: output format. The default is to infer from `output` url_from_catalog: bool | None. Whether to read urls form catalog file. If None, the catalog file will be used if it exists. catalog_file: name of catalog file, that maps ontology IRIs to local file names \"\"\" inroot = os . path . dirname ( os . path . abspath ( input )) outroot = os . path . dirname ( os . path . abspath ( output )) outext = os . path . splitext ( output )[ 1 ] if url_from_catalog is None : url_from_catalog = os . path . exists ( os . path . join ( inroot , catalog_file )) if url_from_catalog : d , dirs = read_catalog ( inroot , catalog_file = catalog_file , recursive = True , return_paths = True ) # Create output dirs and copy catalog files for indir in dirs : outdir = os . path . normpath ( os . path . join ( outroot , os . path . relpath ( indir , inroot ))) if not os . path . exists ( outdir ): os . makedirs ( outdir ) with open ( os . path . join ( indir , catalog_file ), mode = 'rt' ) as f : s = f . read () for path in d . values (): newpath = os . path . splitext ( path )[ 0 ] + outext s = s . replace ( os . path . basename ( path ), os . path . basename ( newpath ) ) with open ( os . path . join ( outdir , catalog_file ), mode = 'wt' ) as f : f . write ( s ) else : d = {} outpaths = set () def recur ( graph , outext ): for imported in graph . objects ( predicate = URIRef ( 'http://www.w3.org/2002/07/owl#imports' )): inpath = d . get ( str ( imported ), str ( imported )) if inpath . startswith (( 'http://' , 'https://' , 'ftp://' )): outpath = os . path . join ( outroot , inpath . split ( '/' )[ - 1 ]) else : outpath = os . path . join ( outroot , os . path . relpath ( inpath , inroot )) outpath = os . path . splitext ( os . path . normpath ( outpath ))[ 0 ] + outext if outpath not in outpaths : outpaths . add ( outpath ) fmt = input_format if input_format else guess_format ( inpath , fmap = FMAP ) g = Graph () g . parse ( d . get ( inpath , inpath ), format = fmt ) g . serialize ( destination = outpath , format = output_format ) recur ( g , outext ) # Write output files fmt = input_format if input_format else guess_format ( input , fmap = FMAP ) if ( not _validate_installed_version ( package = \"rdflib\" , min_version = \"6.0.0\" ) and ( output_format == FMAP . get ( \"ttl\" , \"\" ) or outext == \"ttl\" ) ): from rdflib import __version__ as __rdflib_version__ warnings . warn ( IncompatibleVersion ( \"To correctly convert to Turtle format, rdflib must be \" \"version 6.0.0 or greater, however, the detected rdflib \" \"version used by your Python interpreter is \" f \" { __rdflib_version__ !r} . For more information see the \" \"'Known issues' section of the README.\" ) ) g = Graph () g . parse ( input , format = fmt ) g . serialize ( destination = output , format = output_format ) recur ( g , outext ) get_label ( e ) \u00b6 Returns the label of entity e . Source code in ontopy/utils.py def get_label ( e ): \"\"\"Returns the label of entity `e`.\"\"\" if hasattr ( e , 'prefLabel' ) and e . prefLabel : return e . prefLabel . first () if hasattr ( e , 'label' ) and e . label : return e . label . first () elif hasattr ( e , '__name__' ): return e . __name__ elif hasattr ( e , 'name' ): return str ( e . name ) elif isinstance ( e , str ): return e else : return repr ( e ) infer_version ( iri , version_iri ) \u00b6 Infer version from IRI and versionIRI. Source code in ontopy/utils.py def infer_version ( iri , version_iri ): \"\"\"Infer version from IRI and versionIRI.\"\"\" if str ( version_iri [: len ( iri )]) == str ( iri ): version = version_iri [ len ( iri ):] . lstrip ( '/' ) else : j = 0 v = [] for i in range ( len ( iri )): while i + j < len ( version_iri ) and iri [ i ] != version_iri [ i + j ]: v . append ( version_iri [ i + j ]) j += 1 version = '' . join ( v ) . lstrip ( '/' ) . rstrip ( '/#' ) if '/' in version : raise ValueError ( 'version IRI %r is not consistent with base IRI ' ' %r ' % ( version_iri , iri )) return version isinteractive () \u00b6 Returns true if we are running from an interactive interpreater, false otherwise. Source code in ontopy/utils.py def isinteractive (): \"\"\"Returns true if we are running from an interactive interpreater, false otherwise.\"\"\" return bool ( hasattr ( __builtins__ , '__IPYTHON__' ) or sys . flags . interactive or hasattr ( sys , 'ps1' )) read_catalog ( uri , catalog_file = 'catalog-v001.xml' , baseuri = None , recursive = False , return_paths = False ) \u00b6 Reads a Prot\u00e8g\u00e8 catalog file and returns as a dict. The returned dict maps the ontology IRI (name) to its actual location (URI). The location can be either an absolute file path or a HTTP, HTTPS or FTP web location. uri is a string locating the catalog file. It may be a http or https web location or a file path. The catalog_file argument spesifies the catalog file name and is used if path is used when recursive is true or when path is a directory. If baseuri is not None, it will be used as the base URI for the mapped locations. Otherwise it defaults to uri with its final component omitted. If recursive is true, catalog files in sub-folders are also read. If return_paths is true, a set of directory paths to source files is returned in addition to the default dict. A ReadCatalogError is raised if the catalog file cannot be found. Source code in ontopy/utils.py def read_catalog ( uri , catalog_file = 'catalog-v001.xml' , baseuri = None , recursive = False , return_paths = False ): \"\"\"Reads a Prot\u00e8g\u00e8 catalog file and returns as a dict. The returned dict maps the ontology IRI (name) to its actual location (URI). The location can be either an absolute file path or a HTTP, HTTPS or FTP web location. `uri` is a string locating the catalog file. It may be a http or https web location or a file path. The `catalog_file` argument spesifies the catalog file name and is used if `path` is used when `recursive` is true or when `path` is a directory. If `baseuri` is not None, it will be used as the base URI for the mapped locations. Otherwise it defaults to `uri` with its final component omitted. If `recursive` is true, catalog files in sub-folders are also read. If `return_paths` is true, a set of directory paths to source files is returned in addition to the default dict. A ReadCatalogError is raised if the catalog file cannot be found. \"\"\" # Protocols supported by urllib.request web_protocols = 'http://' , 'https://' , 'ftp://' if uri . startswith ( web_protocols ): # Call read_catalog() recursively to ensure that the temporary # file is properly cleaned up with tempfile . TemporaryDirectory () as tmpdir : destfile = os . path . join ( tmpdir , catalog_file ) uris = { # maps uri to base uri : ( baseuri if baseuri else os . path . dirname ( uri )), f ' { uri . rstrip ( \"/\" ) } / { catalog_file } ' : ( baseuri if baseuri else uri . rstrip ( '/' )), f ' { os . path . dirname ( uri ) } / { catalog_file } ' : ( os . path . dirname ( uri )), } for url , base in uris . items (): try : f , msg = urllib . request . urlretrieve ( url , destfile ) except urllib . request . URLError : continue else : if 'Content-Length' not in msg : continue return read_catalog ( destfile , catalog_file = catalog_file , baseuri = baseuri if baseuri else base , recursive = recursive , return_paths = return_paths ) raise ReadCatalogError ( 'Cannot download catalog from URLs: ' + \", \" . join ( uris )) elif uri . startswith ( 'file://' ): path = uri [ 7 :] else : path = uri if os . path . isdir ( path ): dirname = os . path . abspath ( path ) filepath = os . path . join ( dirname , catalog_file ) else : catalog_file = os . path . basename ( path ) filepath = os . path . abspath ( path ) dirname = os . path . dirname ( filepath ) def gettag ( e ): return e . tag . rsplit ( '}' , 1 )[ - 1 ] def load_catalog ( filepath ): if not os . path . exists ( filepath ): raise ReadCatalogError ( 'No such catalog file: ' + filepath ) dirname = os . path . normpath ( os . path . dirname ( filepath )) dirs . add ( baseuri if baseuri else dirname ) xml = ET . parse ( filepath ) root = xml . getroot () if gettag ( root ) != 'catalog' : raise ReadCatalogError ( 'expected root tag of catalog file %r to ' 'be \"catalog\"' , filepath ) for child in root : if gettag ( child ) == 'uri' : load_uri ( child , dirname ) elif gettag ( child ) == 'group' : for uri in child : load_uri ( uri , dirname ) def load_uri ( uri , dirname ): assert gettag ( uri ) == 'uri' s = uri . attrib [ 'uri' ] if s . startswith ( web_protocols ): if baseuri : url = baseuri . rstrip ( '/#' ) + '/' + os . path . basename ( s ) else : url = s else : s = os . path . normpath ( s ) if baseuri and baseuri . startswith ( web_protocols ): url = f ' { baseuri } / { s } ' else : url = os . path . normpath ( os . path . join ( baseuri if baseuri else dirname , s )) iris . setdefault ( uri . attrib [ 'name' ], url ) if recursive : dir = os . path . dirname ( url ) if dir not in dirs : catalog = os . path . join ( dir , catalog_file ) if catalog . startswith ( web_protocols ): iris_ , dirs_ = read_catalog ( catalog , catalog_file = catalog_file , baseuri = None , recursive = recursive , return_paths = True ) iris . update ( iris_ ) dirs . update ( dirs_ ) else : load_catalog ( catalog ) iris = {} dirs = set () load_catalog ( filepath ) if return_paths : return iris , dirs else : return iris squash_imported ( input , output , input_format = None , output_format = 'xml' , url_from_catalog = None , catalog_file = 'catalog-v001.xml' ) \u00b6 Convert imported ontologies and squash them into a single file. If url_from_catalog is true the catalog file will be used to load possible imported ontologies. If url_from_catalog is None, it will only be used if it exists in the same directory as the input file. The the squash rdflib graph is returned. Warning To convert to Turtle ( .ttl ) format, you must have installed rdflib>=6.0.0 . See Known issues for more information. Source code in ontopy/utils.py def squash_imported ( input , output , input_format = None , output_format = 'xml' , url_from_catalog = None , catalog_file = 'catalog-v001.xml' ): \"\"\"Convert imported ontologies and squash them into a single file. If `url_from_catalog` is true the catalog file will be used to load possible imported ontologies. If `url_from_catalog` is None, it will only be used if it exists in the same directory as the input file. The the squash rdflib graph is returned. Warning: To convert to Turtle (`.ttl`) format, you must have installed `rdflib>=6.0.0`. See [Known issues](../../../#known-issues) for more information. \"\"\" inroot = os . path . dirname ( os . path . abspath ( input )) if url_from_catalog is None : url_from_catalog = os . path . exists ( os . path . join ( inroot , catalog_file )) if url_from_catalog : d = read_catalog ( inroot , catalog_file = catalog_file , recursive = True ) else : d = {} imported = set () def recur ( g ): for s , p , o in g . triples ( ( None , URIRef ( 'http://www.w3.org/2002/07/owl#imports' ), None )): g . remove (( s , p , o )) iri = d . get ( str ( o ), str ( o )) if iri not in imported : imported . add ( iri ) g2 = Graph () g2 . parse ( iri , format = input_format ) recur ( g2 ) for t in g2 . triples (( None , None , None )): graph . add ( t ) graph = Graph () graph . parse ( input , format = input_format ) recur ( graph ) if output : if ( not _validate_installed_version ( package = \"rdflib\" , min_version = \"6.0.0\" ) and ( output_format == FMAP . get ( \"ttl\" , \"\" ) or os . path . splitext ( output )[ 1 ] == \"ttl\" ) ): from rdflib import __version__ as __rdflib_version__ warnings . warn ( IncompatibleVersion ( \"To correctly convert to Turtle format, rdflib must be \" \"version 6.0.0 or greater, however, the detected rdflib \" \"version used by your Python interpreter is \" f \" { __rdflib_version__ !r} . For more information see the \" \"'Known issues' section of the README.\" ) ) graph . serialize ( destination = output , format = output_format ) return graph write_catalog ( mappings , output = 'catalog-v001.xml' ) \u00b6 Writes a catalog file. mappings is a dict mapping ontology IRIs (name) to actual locations (uri). It has the same format as the dict returned by read_catalog(). output it the name of the generated file. Source code in ontopy/utils.py def write_catalog ( mappings , output = 'catalog-v001.xml' ): \"\"\"Writes a catalog file. `mappings` is a dict mapping ontology IRIs (name) to actual locations (uri). It has the same format as the dict returned by read_catalog(). `output` it the name of the generated file. \"\"\" s = [ '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>' , '<catalog prefer=\"public\" ' 'xmlns=\"urn:oasis:names:tc:entity:xmlns:xml:catalog\">' , ' <group id=\"Folder Repository, directory=, recursive=true, ' 'Auto-Update=false, version=2\" prefer=\"public\" xml:base=\"\">' , ] for k , v in dict ( mappings ) . items (): s . append ( f ' <uri name=\" { k } \" uri=\" { v } \"/>' ) s . append ( ' </group>' ) s . append ( '</catalog>' ) with open ( output , 'wt' ) as f : f . write ( ' \\n ' . join ( s ) + ' \\n ' )","title":"utils"},{"location":"api_reference/ontopy/utils/#utils","text":"Some generic utility functions.","title":"utils"},{"location":"api_reference/ontopy/utils/#ontopy.utils.IncompatibleVersion","text":"An installed dependency version may be incompatible with a functionality of this package - or rather an outcome of a functionality. This is not critical, hence this is only a warning.","title":"IncompatibleVersion"},{"location":"api_reference/ontopy/utils/#ontopy.utils.ReadCatalogError","text":"Error reading catalog file.","title":"ReadCatalogError"},{"location":"api_reference/ontopy/utils/#ontopy.utils.UnknownVersion","text":"Cannot retrieve version from a package.","title":"UnknownVersion"},{"location":"api_reference/ontopy/utils/#ontopy.utils.annotate_with_ontology","text":"Annotate all entities with the ontology_name and ontology_iri . If imported is true, imported ontologies will also be annotated. The ontology name and IRI are important contextual information that is lost when ontologies are inferred and/or squashed. This function retain this information as annotations. Source code in ontopy/utils.py def annotate_with_ontology ( onto , imported = True ): \"\"\"Annotate all entities with the `ontology_name` and `ontology_iri`. If imported is true, imported ontologies will also be annotated. The ontology name and IRI are important contextual information that is lost when ontologies are inferred and/or squashed. This function retain this information as annotations. \"\"\" with onto : if 'ontology_name' not in onto . world . _props : types . new_class ( 'ontology_name' , ( owlready2 . AnnotationProperty , )) if 'ontology_iri' not in onto . world . _props : types . new_class ( 'ontology_iri' , ( owlready2 . AnnotationProperty , )) for e in onto . get_entities ( imported = imported ): if onto . name not in getattr ( e , 'ontology_name' ): setattr ( e , 'ontology_name' , onto . name ) if onto . base_iri not in getattr ( e , 'ontology_iri' ): setattr ( e , 'ontology_iri' , onto . base_iri )","title":"annotate_with_ontology()"},{"location":"api_reference/ontopy/utils/#ontopy.utils.asstring","text":"Returns a string representation of expr , which may be an entity, restriction, or logical expression of these. link is a format string for formatting references to entities or relations. It may contain the keywords \"name\", \"url\" and \"lowerurl\". n is the recursion depth and only intended for internal use. If exclude_object is true, the object will be excluded in restrictions. Source code in ontopy/utils.py def asstring ( expr , link = ' {name} ' , n = 0 , exclude_object = False ): \"\"\"Returns a string representation of `expr`, which may be an entity, restriction, or logical expression of these. `link` is a format string for formatting references to entities or relations. It may contain the keywords \"name\", \"url\" and \"lowerurl\". `n` is the recursion depth and only intended for internal use. If `exclude_object` is true, the object will be excluded in restrictions. \"\"\" def fmt ( e ): \"\"\"Returns the formatted label of `e`.\"\"\" name = None for attr in ( 'prefLabel' , 'label' , '__name__' , 'name' ): if hasattr ( e , attr ) and getattr ( e , attr ): name = getattr ( e , attr ) if not isinstance ( name , str ) and hasattr ( name , '__getitem__' ): name = name [ 0 ] break if not name : name = str ( e ) . replace ( '.' , ':' ) url = name if re . match ( r '^[a-z]+://' , name ) else '#' + name return link . format ( name = name , url = url , lowerurl = url . lower ()) if isinstance ( expr , str ): # return link.format(name=expr) return fmt ( expr ) elif isinstance ( expr , owlready2 . Restriction ): rlabel = owlready2 . class_construct . _restriction_type_2_label [ expr . type ] if isinstance ( expr . property , ( owlready2 . ObjectPropertyClass , owlready2 . DataPropertyClass )): s = fmt ( expr . property ) elif isinstance ( expr . property , owlready2 . Inverse ): s = 'Inverse( %s )' % asstring ( expr . property . property , link , n + 1 ) else : print ( '*** WARNING: unknown restriction property: %r ' % expr . property ) s = fmt ( expr . property ) if not rlabel : pass elif expr . type in ( owlready2 . MIN , owlready2 . MAX , owlready2 . EXACTLY ): s += ' %s %d ' % ( rlabel , expr . cardinality ) elif expr . type in ( owlready2 . SOME , owlready2 . ONLY , owlready2 . VALUE , owlready2 . HAS_SELF ): s += ' %s ' % rlabel else : print ( '*** WARNING: unknown relation' , expr , rlabel ) s += ' %s ' % rlabel if not exclude_object : if isinstance ( expr . value , str ): s += ' \" %s \"' % asstring ( expr . value , link , n + 1 ) else : s += ' %s ' % asstring ( expr . value , link , n + 1 ) return s elif isinstance ( expr , owlready2 . Or ): s = ' %s ' if n == 0 else '( %s )' return s % ' or ' . join ([ asstring ( c , link , n + 1 ) for c in expr . Classes ]) elif isinstance ( expr , owlready2 . And ): s = ' %s ' if n == 0 else '( %s )' return s % ' and ' . join ([ asstring ( c , link , n + 1 ) for c in expr . Classes ]) elif isinstance ( expr , owlready2 . Not ): return 'not %s ' % asstring ( expr . Class , link , n + 1 ) elif isinstance ( expr , owlready2 . ThingClass ): return fmt ( expr ) elif isinstance ( expr , owlready2 . PropertyClass ): return fmt ( expr ) elif isinstance ( expr , owlready2 . Thing ): # instance (individual) return fmt ( expr ) elif isinstance ( expr , owlready2 . class_construct . Inverse ): return 'inverse( %s )' % fmt ( expr . property ) elif isinstance ( expr , owlready2 . disjoint . AllDisjoint ): return fmt ( expr ) elif isinstance ( expr , ( bool , int , float )): return repr ( expr ) # Check for subclasses elif issubclass ( expr , ( bool , int , float , str )): return fmt ( expr . __class__ . __name__ ) elif issubclass ( expr , datetime . date ): return 'date' elif issubclass ( expr , datetime . time ): return 'datetime' elif issubclass ( expr , datetime . datetime ): return 'datetime' else : raise RuntimeError ( 'Unknown expression: %r (type: %r )' % ( expr , type ( expr )))","title":"asstring()"},{"location":"api_reference/ontopy/utils/#ontopy.utils.camelsplit","text":"Splits CamelCase string s before upper case letters (except if there is a sequence of upper case letters). Source code in ontopy/utils.py def camelsplit ( s ): \"\"\"Splits CamelCase string `s` before upper case letters (except if there is a sequence of upper case letters).\"\"\" if len ( s ) < 2 : return s result = [] prev_lower = False prev_isspace = True c = s [ 0 ] for next in s [ 1 :]: if (( not prev_isspace and c . isupper () and next . islower ()) or prev_lower and c . isupper ()): result . append ( ' ' ) result . append ( c ) prev_lower = c . islower () prev_isspace = c . isspace () c = next result . append ( next ) return '' . join ( result )","title":"camelsplit()"},{"location":"api_reference/ontopy/utils/#ontopy.utils.convert_imported","text":"Convert imported ontologies. Store the output in a directory structure matching the source files. This require catalog file(s) to be present. Warning To convert to Turtle ( .ttl ) format, you must have installed rdflib>=6.0.0 . See Known issues for more information. Parameters: Name Type Description Default input input ontology file name required output output ontology file path. The directory part of output will be the root of the generated directory structure required input_format input format. The default is to infer from input None output_format output format. The default is to infer from output 'xml' url_from_catalog bool | None. Whether to read urls form catalog file. If None, the catalog file will be used if it exists. None catalog_file name of catalog file, that maps ontology IRIs to local file names 'catalog-v001.xml' Source code in ontopy/utils.py def convert_imported ( input , output , input_format = None , output_format = 'xml' , url_from_catalog = None , catalog_file = 'catalog-v001.xml' ): \"\"\"Convert imported ontologies. Store the output in a directory structure matching the source files. This require catalog file(s) to be present. Warning: To convert to Turtle (`.ttl`) format, you must have installed `rdflib>=6.0.0`. See [Known issues](../../../#known-issues) for more information. Args: input: input ontology file name output: output ontology file path. The directory part of `output` will be the root of the generated directory structure input_format: input format. The default is to infer from `input` output_format: output format. The default is to infer from `output` url_from_catalog: bool | None. Whether to read urls form catalog file. If None, the catalog file will be used if it exists. catalog_file: name of catalog file, that maps ontology IRIs to local file names \"\"\" inroot = os . path . dirname ( os . path . abspath ( input )) outroot = os . path . dirname ( os . path . abspath ( output )) outext = os . path . splitext ( output )[ 1 ] if url_from_catalog is None : url_from_catalog = os . path . exists ( os . path . join ( inroot , catalog_file )) if url_from_catalog : d , dirs = read_catalog ( inroot , catalog_file = catalog_file , recursive = True , return_paths = True ) # Create output dirs and copy catalog files for indir in dirs : outdir = os . path . normpath ( os . path . join ( outroot , os . path . relpath ( indir , inroot ))) if not os . path . exists ( outdir ): os . makedirs ( outdir ) with open ( os . path . join ( indir , catalog_file ), mode = 'rt' ) as f : s = f . read () for path in d . values (): newpath = os . path . splitext ( path )[ 0 ] + outext s = s . replace ( os . path . basename ( path ), os . path . basename ( newpath ) ) with open ( os . path . join ( outdir , catalog_file ), mode = 'wt' ) as f : f . write ( s ) else : d = {} outpaths = set () def recur ( graph , outext ): for imported in graph . objects ( predicate = URIRef ( 'http://www.w3.org/2002/07/owl#imports' )): inpath = d . get ( str ( imported ), str ( imported )) if inpath . startswith (( 'http://' , 'https://' , 'ftp://' )): outpath = os . path . join ( outroot , inpath . split ( '/' )[ - 1 ]) else : outpath = os . path . join ( outroot , os . path . relpath ( inpath , inroot )) outpath = os . path . splitext ( os . path . normpath ( outpath ))[ 0 ] + outext if outpath not in outpaths : outpaths . add ( outpath ) fmt = input_format if input_format else guess_format ( inpath , fmap = FMAP ) g = Graph () g . parse ( d . get ( inpath , inpath ), format = fmt ) g . serialize ( destination = outpath , format = output_format ) recur ( g , outext ) # Write output files fmt = input_format if input_format else guess_format ( input , fmap = FMAP ) if ( not _validate_installed_version ( package = \"rdflib\" , min_version = \"6.0.0\" ) and ( output_format == FMAP . get ( \"ttl\" , \"\" ) or outext == \"ttl\" ) ): from rdflib import __version__ as __rdflib_version__ warnings . warn ( IncompatibleVersion ( \"To correctly convert to Turtle format, rdflib must be \" \"version 6.0.0 or greater, however, the detected rdflib \" \"version used by your Python interpreter is \" f \" { __rdflib_version__ !r} . For more information see the \" \"'Known issues' section of the README.\" ) ) g = Graph () g . parse ( input , format = fmt ) g . serialize ( destination = output , format = output_format ) recur ( g , outext )","title":"convert_imported()"},{"location":"api_reference/ontopy/utils/#ontopy.utils.get_label","text":"Returns the label of entity e . Source code in ontopy/utils.py def get_label ( e ): \"\"\"Returns the label of entity `e`.\"\"\" if hasattr ( e , 'prefLabel' ) and e . prefLabel : return e . prefLabel . first () if hasattr ( e , 'label' ) and e . label : return e . label . first () elif hasattr ( e , '__name__' ): return e . __name__ elif hasattr ( e , 'name' ): return str ( e . name ) elif isinstance ( e , str ): return e else : return repr ( e )","title":"get_label()"},{"location":"api_reference/ontopy/utils/#ontopy.utils.infer_version","text":"Infer version from IRI and versionIRI. Source code in ontopy/utils.py def infer_version ( iri , version_iri ): \"\"\"Infer version from IRI and versionIRI.\"\"\" if str ( version_iri [: len ( iri )]) == str ( iri ): version = version_iri [ len ( iri ):] . lstrip ( '/' ) else : j = 0 v = [] for i in range ( len ( iri )): while i + j < len ( version_iri ) and iri [ i ] != version_iri [ i + j ]: v . append ( version_iri [ i + j ]) j += 1 version = '' . join ( v ) . lstrip ( '/' ) . rstrip ( '/#' ) if '/' in version : raise ValueError ( 'version IRI %r is not consistent with base IRI ' ' %r ' % ( version_iri , iri )) return version","title":"infer_version()"},{"location":"api_reference/ontopy/utils/#ontopy.utils.isinteractive","text":"Returns true if we are running from an interactive interpreater, false otherwise. Source code in ontopy/utils.py def isinteractive (): \"\"\"Returns true if we are running from an interactive interpreater, false otherwise.\"\"\" return bool ( hasattr ( __builtins__ , '__IPYTHON__' ) or sys . flags . interactive or hasattr ( sys , 'ps1' ))","title":"isinteractive()"},{"location":"api_reference/ontopy/utils/#ontopy.utils.read_catalog","text":"Reads a Prot\u00e8g\u00e8 catalog file and returns as a dict. The returned dict maps the ontology IRI (name) to its actual location (URI). The location can be either an absolute file path or a HTTP, HTTPS or FTP web location. uri is a string locating the catalog file. It may be a http or https web location or a file path. The catalog_file argument spesifies the catalog file name and is used if path is used when recursive is true or when path is a directory. If baseuri is not None, it will be used as the base URI for the mapped locations. Otherwise it defaults to uri with its final component omitted. If recursive is true, catalog files in sub-folders are also read. If return_paths is true, a set of directory paths to source files is returned in addition to the default dict. A ReadCatalogError is raised if the catalog file cannot be found. Source code in ontopy/utils.py def read_catalog ( uri , catalog_file = 'catalog-v001.xml' , baseuri = None , recursive = False , return_paths = False ): \"\"\"Reads a Prot\u00e8g\u00e8 catalog file and returns as a dict. The returned dict maps the ontology IRI (name) to its actual location (URI). The location can be either an absolute file path or a HTTP, HTTPS or FTP web location. `uri` is a string locating the catalog file. It may be a http or https web location or a file path. The `catalog_file` argument spesifies the catalog file name and is used if `path` is used when `recursive` is true or when `path` is a directory. If `baseuri` is not None, it will be used as the base URI for the mapped locations. Otherwise it defaults to `uri` with its final component omitted. If `recursive` is true, catalog files in sub-folders are also read. If `return_paths` is true, a set of directory paths to source files is returned in addition to the default dict. A ReadCatalogError is raised if the catalog file cannot be found. \"\"\" # Protocols supported by urllib.request web_protocols = 'http://' , 'https://' , 'ftp://' if uri . startswith ( web_protocols ): # Call read_catalog() recursively to ensure that the temporary # file is properly cleaned up with tempfile . TemporaryDirectory () as tmpdir : destfile = os . path . join ( tmpdir , catalog_file ) uris = { # maps uri to base uri : ( baseuri if baseuri else os . path . dirname ( uri )), f ' { uri . rstrip ( \"/\" ) } / { catalog_file } ' : ( baseuri if baseuri else uri . rstrip ( '/' )), f ' { os . path . dirname ( uri ) } / { catalog_file } ' : ( os . path . dirname ( uri )), } for url , base in uris . items (): try : f , msg = urllib . request . urlretrieve ( url , destfile ) except urllib . request . URLError : continue else : if 'Content-Length' not in msg : continue return read_catalog ( destfile , catalog_file = catalog_file , baseuri = baseuri if baseuri else base , recursive = recursive , return_paths = return_paths ) raise ReadCatalogError ( 'Cannot download catalog from URLs: ' + \", \" . join ( uris )) elif uri . startswith ( 'file://' ): path = uri [ 7 :] else : path = uri if os . path . isdir ( path ): dirname = os . path . abspath ( path ) filepath = os . path . join ( dirname , catalog_file ) else : catalog_file = os . path . basename ( path ) filepath = os . path . abspath ( path ) dirname = os . path . dirname ( filepath ) def gettag ( e ): return e . tag . rsplit ( '}' , 1 )[ - 1 ] def load_catalog ( filepath ): if not os . path . exists ( filepath ): raise ReadCatalogError ( 'No such catalog file: ' + filepath ) dirname = os . path . normpath ( os . path . dirname ( filepath )) dirs . add ( baseuri if baseuri else dirname ) xml = ET . parse ( filepath ) root = xml . getroot () if gettag ( root ) != 'catalog' : raise ReadCatalogError ( 'expected root tag of catalog file %r to ' 'be \"catalog\"' , filepath ) for child in root : if gettag ( child ) == 'uri' : load_uri ( child , dirname ) elif gettag ( child ) == 'group' : for uri in child : load_uri ( uri , dirname ) def load_uri ( uri , dirname ): assert gettag ( uri ) == 'uri' s = uri . attrib [ 'uri' ] if s . startswith ( web_protocols ): if baseuri : url = baseuri . rstrip ( '/#' ) + '/' + os . path . basename ( s ) else : url = s else : s = os . path . normpath ( s ) if baseuri and baseuri . startswith ( web_protocols ): url = f ' { baseuri } / { s } ' else : url = os . path . normpath ( os . path . join ( baseuri if baseuri else dirname , s )) iris . setdefault ( uri . attrib [ 'name' ], url ) if recursive : dir = os . path . dirname ( url ) if dir not in dirs : catalog = os . path . join ( dir , catalog_file ) if catalog . startswith ( web_protocols ): iris_ , dirs_ = read_catalog ( catalog , catalog_file = catalog_file , baseuri = None , recursive = recursive , return_paths = True ) iris . update ( iris_ ) dirs . update ( dirs_ ) else : load_catalog ( catalog ) iris = {} dirs = set () load_catalog ( filepath ) if return_paths : return iris , dirs else : return iris","title":"read_catalog()"},{"location":"api_reference/ontopy/utils/#ontopy.utils.squash_imported","text":"Convert imported ontologies and squash them into a single file. If url_from_catalog is true the catalog file will be used to load possible imported ontologies. If url_from_catalog is None, it will only be used if it exists in the same directory as the input file. The the squash rdflib graph is returned. Warning To convert to Turtle ( .ttl ) format, you must have installed rdflib>=6.0.0 . See Known issues for more information. Source code in ontopy/utils.py def squash_imported ( input , output , input_format = None , output_format = 'xml' , url_from_catalog = None , catalog_file = 'catalog-v001.xml' ): \"\"\"Convert imported ontologies and squash them into a single file. If `url_from_catalog` is true the catalog file will be used to load possible imported ontologies. If `url_from_catalog` is None, it will only be used if it exists in the same directory as the input file. The the squash rdflib graph is returned. Warning: To convert to Turtle (`.ttl`) format, you must have installed `rdflib>=6.0.0`. See [Known issues](../../../#known-issues) for more information. \"\"\" inroot = os . path . dirname ( os . path . abspath ( input )) if url_from_catalog is None : url_from_catalog = os . path . exists ( os . path . join ( inroot , catalog_file )) if url_from_catalog : d = read_catalog ( inroot , catalog_file = catalog_file , recursive = True ) else : d = {} imported = set () def recur ( g ): for s , p , o in g . triples ( ( None , URIRef ( 'http://www.w3.org/2002/07/owl#imports' ), None )): g . remove (( s , p , o )) iri = d . get ( str ( o ), str ( o )) if iri not in imported : imported . add ( iri ) g2 = Graph () g2 . parse ( iri , format = input_format ) recur ( g2 ) for t in g2 . triples (( None , None , None )): graph . add ( t ) graph = Graph () graph . parse ( input , format = input_format ) recur ( graph ) if output : if ( not _validate_installed_version ( package = \"rdflib\" , min_version = \"6.0.0\" ) and ( output_format == FMAP . get ( \"ttl\" , \"\" ) or os . path . splitext ( output )[ 1 ] == \"ttl\" ) ): from rdflib import __version__ as __rdflib_version__ warnings . warn ( IncompatibleVersion ( \"To correctly convert to Turtle format, rdflib must be \" \"version 6.0.0 or greater, however, the detected rdflib \" \"version used by your Python interpreter is \" f \" { __rdflib_version__ !r} . For more information see the \" \"'Known issues' section of the README.\" ) ) graph . serialize ( destination = output , format = output_format ) return graph","title":"squash_imported()"},{"location":"api_reference/ontopy/utils/#ontopy.utils.write_catalog","text":"Writes a catalog file. mappings is a dict mapping ontology IRIs (name) to actual locations (uri). It has the same format as the dict returned by read_catalog(). output it the name of the generated file. Source code in ontopy/utils.py def write_catalog ( mappings , output = 'catalog-v001.xml' ): \"\"\"Writes a catalog file. `mappings` is a dict mapping ontology IRIs (name) to actual locations (uri). It has the same format as the dict returned by read_catalog(). `output` it the name of the generated file. \"\"\" s = [ '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>' , '<catalog prefer=\"public\" ' 'xmlns=\"urn:oasis:names:tc:entity:xmlns:xml:catalog\">' , ' <group id=\"Folder Repository, directory=, recursive=true, ' 'Auto-Update=false, version=2\" prefer=\"public\" xml:base=\"\">' , ] for k , v in dict ( mappings ) . items (): s . append ( f ' <uri name=\" { k } \" uri=\" { v } \"/>' ) s . append ( ' </group>' ) s . append ( '</catalog>' ) with open ( output , 'wt' ) as f : f . write ( ' \\n ' . join ( s ) + ' \\n ' )","title":"write_catalog()"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/","text":"factppgraph \u00b6 FaCTPPGraph \u00b6 Class for running the FaCT++ reasoner (using OwlApiInterface) and postprocessing the resulting inferred ontology. Parameters \u00b6 graph : owlapi.Graph instance The graph to be inferred. base_iri property writable \u00b6 Base iri of inferred ontology. inferred property readonly \u00b6 The current inferred graph. namespaces property readonly \u00b6 Namespaces defined in the original graph. add_base_annotations ( self ) \u00b6 Copy base annotations from original graph to the inferred graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def add_base_annotations ( self ): \"\"\"Copy base annotations from original graph to the inferred graph.\"\"\" base = self . base_iri inferred = self . inferred for s , p , o in self . graph . triples ( ( self . asserted_base_iri (), None , None )): if p == OWL . versionIRI : version = o . rsplit ( '/' , 1 )[ - 1 ] o = URIRef ( ' %s / %s ' % ( base , version )) inferred . add (( base , p , o )) asserted_base_iri ( self ) \u00b6 Returns the base iri or the original graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def asserted_base_iri ( self ): \"\"\"Returns the base iri or the original graph.\"\"\" return URIRef ( dict ( self . graph . namespaces ()) . get ( '' , '' ) . rstrip ( '#/' )) clean_ancestors ( self ) \u00b6 Remove redundant rdfs:subClassOf relations in inferred graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def clean_ancestors ( self ): \"\"\"Remove redundant rdfs:subClassOf relations in inferred graph.\"\"\" inferred = self . inferred for s in inferred . subjects ( RDF . type , OWL . Class ): if isinstance ( s , URIRef ): parents = set ( p for p in inferred . objects ( s , RDFS . subClassOf ) if isinstance ( p , URIRef )) if len ( parents ) > 1 : for parent in parents : ancestors = set ( inferred . transitive_objects ( parent , RDFS . subClassOf )) for p in parents : if p != parent and p in ancestors : t = s , RDFS . subClassOf , p if t in inferred : inferred . remove ( t ) clean_base ( self ) \u00b6 Remove all relations s? a owl:Ontology where s? is not base_iri . Source code in ontopy/factpluspluswrapper/factppgraph.py def clean_base ( self ): \"\"\"Remove all relations `s? a owl:Ontology` where `s?` is not `base_iri`. \"\"\" inferred = self . inferred for s , p , o in inferred . triples (( None , RDF . type , OWL . Ontology )): inferred . remove (( s , p , o )) inferred . add (( self . base_iri , RDF . type , OWL . Ontology )) inferred_graph ( self ) \u00b6 Returns the postprocessed inferred graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def inferred_graph ( self ): \"\"\"Returns the postprocessed inferred graph.\"\"\" self . add_base_annotations () self . set_namespace () self . clean_base () self . remove_nothing_is_nothing () self . clean_ancestors () return self . inferred raw_inferred_graph ( self ) \u00b6 Returns the raw non-postprocessed inferred ontology as a rdflib graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def raw_inferred_graph ( self ): \"\"\"Returns the raw non-postprocessed inferred ontology as a rdflib graph.\"\"\" return OwlApiInterface () . reason ( self . graph ) remove_nothing_is_nothing ( self ) \u00b6 Remove superfluid relation in inferred graph: owl:Nothing rdfs:subClassOf owl:Nothing Source code in ontopy/factpluspluswrapper/factppgraph.py def remove_nothing_is_nothing ( self ): \"\"\"Remove superfluid relation in inferred graph: owl:Nothing rdfs:subClassOf owl:Nothing \"\"\" t = OWL . Nothing , RDFS . subClassOf , OWL . Nothing inferred = self . inferred if t in inferred : inferred . remove ( t ) set_namespace ( self ) \u00b6 Override namespace of inferred graph with the namespace of the original graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def set_namespace ( self ): \"\"\"Override namespace of inferred graph with the namespace of the original graph. \"\"\" inferred = self . inferred for k , v in self . namespaces . items (): inferred . namespace_manager . bind ( k , v , override = True , replace = True ) FactPPError \u00b6 Postprocessing error after reasoning with FaCT++.","title":"factppgraph"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#factppgraph","text":"","title":"factppgraph"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph","text":"Class for running the FaCT++ reasoner (using OwlApiInterface) and postprocessing the resulting inferred ontology.","title":"FaCTPPGraph"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph--parameters","text":"graph : owlapi.Graph instance The graph to be inferred.","title":"Parameters"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.base_iri","text":"Base iri of inferred ontology.","title":"base_iri"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.inferred","text":"The current inferred graph.","title":"inferred"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.namespaces","text":"Namespaces defined in the original graph.","title":"namespaces"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.add_base_annotations","text":"Copy base annotations from original graph to the inferred graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def add_base_annotations ( self ): \"\"\"Copy base annotations from original graph to the inferred graph.\"\"\" base = self . base_iri inferred = self . inferred for s , p , o in self . graph . triples ( ( self . asserted_base_iri (), None , None )): if p == OWL . versionIRI : version = o . rsplit ( '/' , 1 )[ - 1 ] o = URIRef ( ' %s / %s ' % ( base , version )) inferred . add (( base , p , o ))","title":"add_base_annotations()"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.asserted_base_iri","text":"Returns the base iri or the original graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def asserted_base_iri ( self ): \"\"\"Returns the base iri or the original graph.\"\"\" return URIRef ( dict ( self . graph . namespaces ()) . get ( '' , '' ) . rstrip ( '#/' ))","title":"asserted_base_iri()"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.clean_ancestors","text":"Remove redundant rdfs:subClassOf relations in inferred graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def clean_ancestors ( self ): \"\"\"Remove redundant rdfs:subClassOf relations in inferred graph.\"\"\" inferred = self . inferred for s in inferred . subjects ( RDF . type , OWL . Class ): if isinstance ( s , URIRef ): parents = set ( p for p in inferred . objects ( s , RDFS . subClassOf ) if isinstance ( p , URIRef )) if len ( parents ) > 1 : for parent in parents : ancestors = set ( inferred . transitive_objects ( parent , RDFS . subClassOf )) for p in parents : if p != parent and p in ancestors : t = s , RDFS . subClassOf , p if t in inferred : inferred . remove ( t )","title":"clean_ancestors()"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.clean_base","text":"Remove all relations s? a owl:Ontology where s? is not base_iri . Source code in ontopy/factpluspluswrapper/factppgraph.py def clean_base ( self ): \"\"\"Remove all relations `s? a owl:Ontology` where `s?` is not `base_iri`. \"\"\" inferred = self . inferred for s , p , o in inferred . triples (( None , RDF . type , OWL . Ontology )): inferred . remove (( s , p , o )) inferred . add (( self . base_iri , RDF . type , OWL . Ontology ))","title":"clean_base()"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.inferred_graph","text":"Returns the postprocessed inferred graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def inferred_graph ( self ): \"\"\"Returns the postprocessed inferred graph.\"\"\" self . add_base_annotations () self . set_namespace () self . clean_base () self . remove_nothing_is_nothing () self . clean_ancestors () return self . inferred","title":"inferred_graph()"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.raw_inferred_graph","text":"Returns the raw non-postprocessed inferred ontology as a rdflib graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def raw_inferred_graph ( self ): \"\"\"Returns the raw non-postprocessed inferred ontology as a rdflib graph.\"\"\" return OwlApiInterface () . reason ( self . graph )","title":"raw_inferred_graph()"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.remove_nothing_is_nothing","text":"Remove superfluid relation in inferred graph: owl:Nothing rdfs:subClassOf owl:Nothing Source code in ontopy/factpluspluswrapper/factppgraph.py def remove_nothing_is_nothing ( self ): \"\"\"Remove superfluid relation in inferred graph: owl:Nothing rdfs:subClassOf owl:Nothing \"\"\" t = OWL . Nothing , RDFS . subClassOf , OWL . Nothing inferred = self . inferred if t in inferred : inferred . remove ( t )","title":"remove_nothing_is_nothing()"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FaCTPPGraph.set_namespace","text":"Override namespace of inferred graph with the namespace of the original graph. Source code in ontopy/factpluspluswrapper/factppgraph.py def set_namespace ( self ): \"\"\"Override namespace of inferred graph with the namespace of the original graph. \"\"\" inferred = self . inferred for k , v in self . namespaces . items (): inferred . namespace_manager . bind ( k , v , override = True , replace = True )","title":"set_namespace()"},{"location":"api_reference/ontopy/factpluspluswrapper/factppgraph/#ontopy.factpluspluswrapper.factppgraph.FactPPError","text":"Postprocessing error after reasoning with FaCT++.","title":"FactPPError"},{"location":"api_reference/ontopy/factpluspluswrapper/owlapi_interface/","text":"owlapi_interface \u00b6 Python interface to the FaCT++ Reasoner. This module is copied from the SimPhoNy project. Original author: Matthias Urban OwlApiInterface \u00b6 Interface to the FaCT++ reasoner via OWLAPI. __init__ ( self ) special \u00b6 Initialize the interface. Source code in ontopy/factpluspluswrapper/owlapi_interface.py def __init__ ( self ): \"\"\"Initialize the interface.\"\"\" pass merge_files ( self , * owl_files ) \u00b6 Merge the given owl files and its import closure. Parameters: Name Type Description Default owl_files os.path The owl files two merge () Source code in ontopy/factpluspluswrapper/owlapi_interface.py def merge_files ( self , * owl_files ): \"\"\"Merge the given owl files and its import closure. Args: owl_files (os.path): The owl files two merge \"\"\" return self . _run ( * owl_files , command = \"--merge-only\" ) reason ( self , graph ) \u00b6 Generate the inferred axioms for a given Graph. Parameters: Name Type Description Default graph Graph An rdflib graph to execute the reasoner on. required Source code in ontopy/factpluspluswrapper/owlapi_interface.py def reason ( self , graph ): \"\"\"Generate the inferred axioms for a given Graph. Args: graph (Graph): An rdflib graph to execute the reasoner on. \"\"\" with tempfile . NamedTemporaryFile ( \"wt\" ) as f : graph . serialize ( f . name , format = \"xml\" ) return self . _run ( f . name , command = \"--run-reasoner\" ) reason_files ( self , * owl_files ) \u00b6 Merge the given owl and generate the inferred axioms. Parameters: Name Type Description Default owl_files os.path The owl files two merge () Source code in ontopy/factpluspluswrapper/owlapi_interface.py def reason_files ( self , * owl_files ): \"\"\"Merge the given owl and generate the inferred axioms. Args: owl_files (os.path): The owl files two merge \"\"\" return self . _run ( * owl_files , command = \"--run-reasoner\" ) reason_from_terminal () \u00b6 Run the reasoner from terminal. Source code in ontopy/factpluspluswrapper/owlapi_interface.py def reason_from_terminal (): \"\"\"Run the reasoner from terminal.\"\"\" parser = argparse . ArgumentParser ( description = \"Run the FaCT++ reasoner on the given OWL file. \" \"Catalog files are used to load the import closure. \" \"Then the reasoner is executed and the inferred triples are merged \" \"with the asserted ones. If multiple OWL files are given, they are \" \"merged beforehand\" ) parser . add_argument ( \"owl_file\" , nargs = \"+\" , help = \"OWL file(s) to run the reasoner on.\" ) parser . add_argument ( \"output_file\" , help = \"Path to store inferred axioms to.\" ) args = parser . parse_args () OwlApiInterface () . _run ( * args . owl_file , command = \"--run-reasoner\" , return_graph = False , output_file = args . output_file )","title":"owlapi_interface"},{"location":"api_reference/ontopy/factpluspluswrapper/owlapi_interface/#owlapi_interface","text":"Python interface to the FaCT++ Reasoner. This module is copied from the SimPhoNy project. Original author: Matthias Urban","title":"owlapi_interface"},{"location":"api_reference/ontopy/factpluspluswrapper/owlapi_interface/#ontopy.factpluspluswrapper.owlapi_interface.OwlApiInterface","text":"Interface to the FaCT++ reasoner via OWLAPI.","title":"OwlApiInterface"},{"location":"api_reference/ontopy/factpluspluswrapper/owlapi_interface/#ontopy.factpluspluswrapper.owlapi_interface.OwlApiInterface.__init__","text":"Initialize the interface. Source code in ontopy/factpluspluswrapper/owlapi_interface.py def __init__ ( self ): \"\"\"Initialize the interface.\"\"\" pass","title":"__init__()"},{"location":"api_reference/ontopy/factpluspluswrapper/owlapi_interface/#ontopy.factpluspluswrapper.owlapi_interface.OwlApiInterface.merge_files","text":"Merge the given owl files and its import closure. Parameters: Name Type Description Default owl_files os.path The owl files two merge () Source code in ontopy/factpluspluswrapper/owlapi_interface.py def merge_files ( self , * owl_files ): \"\"\"Merge the given owl files and its import closure. Args: owl_files (os.path): The owl files two merge \"\"\" return self . _run ( * owl_files , command = \"--merge-only\" )","title":"merge_files()"},{"location":"api_reference/ontopy/factpluspluswrapper/owlapi_interface/#ontopy.factpluspluswrapper.owlapi_interface.OwlApiInterface.reason","text":"Generate the inferred axioms for a given Graph. Parameters: Name Type Description Default graph Graph An rdflib graph to execute the reasoner on. required Source code in ontopy/factpluspluswrapper/owlapi_interface.py def reason ( self , graph ): \"\"\"Generate the inferred axioms for a given Graph. Args: graph (Graph): An rdflib graph to execute the reasoner on. \"\"\" with tempfile . NamedTemporaryFile ( \"wt\" ) as f : graph . serialize ( f . name , format = \"xml\" ) return self . _run ( f . name , command = \"--run-reasoner\" )","title":"reason()"},{"location":"api_reference/ontopy/factpluspluswrapper/owlapi_interface/#ontopy.factpluspluswrapper.owlapi_interface.OwlApiInterface.reason_files","text":"Merge the given owl and generate the inferred axioms. Parameters: Name Type Description Default owl_files os.path The owl files two merge () Source code in ontopy/factpluspluswrapper/owlapi_interface.py def reason_files ( self , * owl_files ): \"\"\"Merge the given owl and generate the inferred axioms. Args: owl_files (os.path): The owl files two merge \"\"\" return self . _run ( * owl_files , command = \"--run-reasoner\" )","title":"reason_files()"},{"location":"api_reference/ontopy/factpluspluswrapper/owlapi_interface/#ontopy.factpluspluswrapper.owlapi_interface.reason_from_terminal","text":"Run the reasoner from terminal. Source code in ontopy/factpluspluswrapper/owlapi_interface.py def reason_from_terminal (): \"\"\"Run the reasoner from terminal.\"\"\" parser = argparse . ArgumentParser ( description = \"Run the FaCT++ reasoner on the given OWL file. \" \"Catalog files are used to load the import closure. \" \"Then the reasoner is executed and the inferred triples are merged \" \"with the asserted ones. If multiple OWL files are given, they are \" \"merged beforehand\" ) parser . add_argument ( \"owl_file\" , nargs = \"+\" , help = \"OWL file(s) to run the reasoner on.\" ) parser . add_argument ( \"output_file\" , help = \"Path to store inferred axioms to.\" ) args = parser . parse_args () OwlApiInterface () . _run ( * args . owl_file , command = \"--run-reasoner\" , return_graph = False , output_file = args . output_file )","title":"reason_from_terminal()"},{"location":"api_reference/ontopy/factpluspluswrapper/sync_factpp/","text":"sync_factpp \u00b6 sync_reasoner_factpp ( ontology_or_world = None , infer_property_values = False , debug = 1 ) \u00b6 Run FaCT++ reasoner and load the inferred relations back into the owlready2 triplestore. Parameters \u00b6 ontology_or_world : None | Ontology instance | World instance | list Identifies the world to run the reasoner over. infer_property_values : bool Whether to also infer property values. debug : bool Whether to print debug info to standard output. Source code in ontopy/factpluspluswrapper/sync_factpp.py def sync_reasoner_factpp ( ontology_or_world = None , infer_property_values = False , debug = 1 ): \"\"\"Run FaCT++ reasoner and load the inferred relations back into the owlready2 triplestore. Parameters ---------- ontology_or_world : None | Ontology instance | World instance | list Identifies the world to run the reasoner over. infer_property_values : bool Whether to also infer property values. debug : bool Whether to print debug info to standard output. \"\"\" if isinstance ( ontology_or_world , World ): world = ontology_or_world elif isinstance ( ontology_or_world , Ontology ): world = ontology_or_world . world elif isinstance ( ontology_or_world , Sequence ): world = ontology_or_world [ 0 ] . world else : world = owlready2 . default_world if isinstance ( ontology_or_world , Ontology ): ontology = ontology_or_world elif CURRENT_NAMESPACES . get (): ontology = CURRENT_NAMESPACES . get ()[ - 1 ] . ontology else : ontology = world . get_ontology ( _INFERRENCES_ONTOLOGY ) locked = world . graph . has_write_lock () if locked : world . graph . release_write_lock () # Not needed during reasoning try : print ( '*** Prepare graph' ) # Exclude owl:imports because they are not needed and can # cause trouble when loading the inferred ontology g1 = rdflib . Graph () for s , p , o in world . as_rdflib_graph () . triples (( None , None , None )): if p != OWL . imports : g1 . add (( s , p , o )) print ( '*** Run FaCT++ reasoner (and postprocess)' ) g2 = FaCTPPGraph ( g1 ) . inferred_graph () print ( '*** Load inferred ontology' ) # Check all rdfs:subClassOf relations in the inferred graph and add # them to the world if they are missing new_parents = defaultdict ( list ) new_equivs = defaultdict ( list ) entity_2_type = {} for s , p , o in g2 . triples (( None , None , None )): if ( isinstance ( s , URIRef ) and p in OWL_2_TYPE and isinstance ( o , URIRef )): s_storid = ontology . _abbreviate ( str ( s ), False ) p_storid = ontology . _abbreviate ( str ( p ), False ) o_storid = ontology . _abbreviate ( str ( o ), False ) if ( s_storid is not None and p_storid is not None and o_storid is not None ): if p in ( RDFS . subClassOf , RDFS . subPropertyOf , RDF . type ): new_parents [ s_storid ] . append ( o_storid ) entity_2_type [ s_storid ] = OWL_2_TYPE [ p ] else : new_equivs [ s_storid ] . append ( o_storid ) entity_2_type [ s_storid ] = OWL_2_TYPE [ p ] if infer_property_values : inferred_obj_relations = [] # Hmm, does FaCT++ infer any property values? # If not, remove the `infer_property_values` keyword argument. raise NotImplementedError finally : if locked : world . graph . acquire_write_lock () # re-lock when applying results print ( '*** Applying reasoning results' ) _apply_reasoning_results ( world , ontology , debug , new_parents , new_equivs , entity_2_type ) if infer_property_values : _apply_inferred_obj_relations ( world , ontology , debug , inferred_obj_relations )","title":"sync_factpp"},{"location":"api_reference/ontopy/factpluspluswrapper/sync_factpp/#sync_factpp","text":"","title":"sync_factpp"},{"location":"api_reference/ontopy/factpluspluswrapper/sync_factpp/#ontopy.factpluspluswrapper.sync_factpp.sync_reasoner_factpp","text":"Run FaCT++ reasoner and load the inferred relations back into the owlready2 triplestore.","title":"sync_reasoner_factpp()"},{"location":"api_reference/ontopy/factpluspluswrapper/sync_factpp/#ontopy.factpluspluswrapper.sync_factpp.sync_reasoner_factpp--parameters","text":"ontology_or_world : None | Ontology instance | World instance | list Identifies the world to run the reasoner over. infer_property_values : bool Whether to also infer property values. debug : bool Whether to print debug info to standard output. Source code in ontopy/factpluspluswrapper/sync_factpp.py def sync_reasoner_factpp ( ontology_or_world = None , infer_property_values = False , debug = 1 ): \"\"\"Run FaCT++ reasoner and load the inferred relations back into the owlready2 triplestore. Parameters ---------- ontology_or_world : None | Ontology instance | World instance | list Identifies the world to run the reasoner over. infer_property_values : bool Whether to also infer property values. debug : bool Whether to print debug info to standard output. \"\"\" if isinstance ( ontology_or_world , World ): world = ontology_or_world elif isinstance ( ontology_or_world , Ontology ): world = ontology_or_world . world elif isinstance ( ontology_or_world , Sequence ): world = ontology_or_world [ 0 ] . world else : world = owlready2 . default_world if isinstance ( ontology_or_world , Ontology ): ontology = ontology_or_world elif CURRENT_NAMESPACES . get (): ontology = CURRENT_NAMESPACES . get ()[ - 1 ] . ontology else : ontology = world . get_ontology ( _INFERRENCES_ONTOLOGY ) locked = world . graph . has_write_lock () if locked : world . graph . release_write_lock () # Not needed during reasoning try : print ( '*** Prepare graph' ) # Exclude owl:imports because they are not needed and can # cause trouble when loading the inferred ontology g1 = rdflib . Graph () for s , p , o in world . as_rdflib_graph () . triples (( None , None , None )): if p != OWL . imports : g1 . add (( s , p , o )) print ( '*** Run FaCT++ reasoner (and postprocess)' ) g2 = FaCTPPGraph ( g1 ) . inferred_graph () print ( '*** Load inferred ontology' ) # Check all rdfs:subClassOf relations in the inferred graph and add # them to the world if they are missing new_parents = defaultdict ( list ) new_equivs = defaultdict ( list ) entity_2_type = {} for s , p , o in g2 . triples (( None , None , None )): if ( isinstance ( s , URIRef ) and p in OWL_2_TYPE and isinstance ( o , URIRef )): s_storid = ontology . _abbreviate ( str ( s ), False ) p_storid = ontology . _abbreviate ( str ( p ), False ) o_storid = ontology . _abbreviate ( str ( o ), False ) if ( s_storid is not None and p_storid is not None and o_storid is not None ): if p in ( RDFS . subClassOf , RDFS . subPropertyOf , RDF . type ): new_parents [ s_storid ] . append ( o_storid ) entity_2_type [ s_storid ] = OWL_2_TYPE [ p ] else : new_equivs [ s_storid ] . append ( o_storid ) entity_2_type [ s_storid ] = OWL_2_TYPE [ p ] if infer_property_values : inferred_obj_relations = [] # Hmm, does FaCT++ infer any property values? # If not, remove the `infer_property_values` keyword argument. raise NotImplementedError finally : if locked : world . graph . acquire_write_lock () # re-lock when applying results print ( '*** Applying reasoning results' ) _apply_reasoning_results ( world , ontology , debug , new_parents , new_equivs , entity_2_type ) if infer_property_values : _apply_inferred_obj_relations ( world , ontology , debug , inferred_obj_relations )","title":"Parameters"},{"location":"demo/","text":"EMMO use cases \u00b6 This demo contains two use cases on how EMMO can be used to achieve vertical and horizontal interpoerability, respectivily. Warning This demonstration is still work in progress. Especially documentation is lacking. Content \u00b6 Vertical interoperability . Horizontal interoperability . The user case - welding an aluminium plate to steel \u00b6","title":"EMMO use cases"},{"location":"demo/#emmo-use-cases","text":"This demo contains two use cases on how EMMO can be used to achieve vertical and horizontal interpoerability, respectivily. Warning This demonstration is still work in progress. Especially documentation is lacking.","title":"EMMO use cases"},{"location":"demo/#content","text":"Vertical interoperability . Horizontal interoperability .","title":"Content"},{"location":"demo/#the-user-case-welding-an-aluminium-plate-to-steel","text":"","title":"The user case - welding an aluminium plate to steel"},{"location":"demo/horizontal/","text":"EMMO use case for horizontal interoperability \u00b6 Horizontal interoperability is about interoperability between different types of models and codes for a single material (i.e., one use case, multiple models). The key here is to show how to map between EMMO (or an EMMO-based ontology) and another ontology (possible EMMO-based). In this example we use a data-driven approach based on a C-implementation of SOFT 1 , 2 . This is done in four steps: Generate metadata from the EMMO-based user case ontology. Implemented in the script step1_generate_metadata.py . Define metadata for an application developed independently of EMMO. In this case a metadata description of the ASE Atoms class 3 is created in atoms.json . Implemented in the script step2_define_metadata.py . Instantiate the metadata defined defined in step 2 with an atomistic structure interface structure. Implemented in the script step3_instantiate.py . Map the atomistic interface structure from the application representation to the common EMMO-based representation. Implemented in the script step4_map_instance.py . Essentially, this demonstration shows how EMMO can be extended and how external data can be mapped into our extended ontology (serving as a common representational system). Requirements for running the user case \u00b6 In addition to emmo, this demo also requires: DLite , a C-implementation of SOFT used for handling metadata ASE , for reading atom structure from cif and visualisation","title":"EMMO use case for horizontal interoperability"},{"location":"demo/horizontal/#emmo-use-case-for-horizontal-interoperability","text":"Horizontal interoperability is about interoperability between different types of models and codes for a single material (i.e., one use case, multiple models). The key here is to show how to map between EMMO (or an EMMO-based ontology) and another ontology (possible EMMO-based). In this example we use a data-driven approach based on a C-implementation of SOFT 1 , 2 . This is done in four steps: Generate metadata from the EMMO-based user case ontology. Implemented in the script step1_generate_metadata.py . Define metadata for an application developed independently of EMMO. In this case a metadata description of the ASE Atoms class 3 is created in atoms.json . Implemented in the script step2_define_metadata.py . Instantiate the metadata defined defined in step 2 with an atomistic structure interface structure. Implemented in the script step3_instantiate.py . Map the atomistic interface structure from the application representation to the common EMMO-based representation. Implemented in the script step4_map_instance.py . Essentially, this demonstration shows how EMMO can be extended and how external data can be mapped into our extended ontology (serving as a common representational system).","title":"EMMO use case for horizontal interoperability"},{"location":"demo/horizontal/#requirements-for-running-the-user-case","text":"In addition to emmo, this demo also requires: DLite , a C-implementation of SOFT used for handling metadata ASE , for reading atom structure from cif and visualisation","title":"Requirements for running the user case"},{"location":"demo/vertical/","text":"EMMO use case for vertical interoperability \u00b6 Vertical interoperability is about interoperability across two or more granulaty levels. In this use case we study the welded interface between an aluminium and a steel plate at three granularity levels. In this case, the granularity levels corresponds to three different length scales, that we here denote component , microstructure and atomistic scale. Creating an EMMO-based user case ontology \u00b6 The script define_ontology.py uses the Python API for EMMO to generate an application ontology extending EMMO with additional concepts needed to describe the data that is exchanged between scales. The user case ontology can then be visualised with the script plot_ontology.py . Defining the needed material entities \u00b6 Assigning properties to material entities \u00b6 Note that we here also assign properties to e-bonded_atom , even though e-bonded_atom is defined in EMMO. Assigning units to properties \u00b6 We choose here to consistently use SI units for all scales (even though at the atomistic scale units like \u00c5ngstr\u00f6m and electron volt are more commonly used). Assigning types to properties \u00b6 In order to be able to generate metadata and to describe the actual data transferred between scales, we also need to define types. The new application-ontology \u00b6 The final plot shows the user case ontology in context of EMMO.","title":"EMMO use case for vertical interoperability"},{"location":"demo/vertical/#emmo-use-case-for-vertical-interoperability","text":"Vertical interoperability is about interoperability across two or more granulaty levels. In this use case we study the welded interface between an aluminium and a steel plate at three granularity levels. In this case, the granularity levels corresponds to three different length scales, that we here denote component , microstructure and atomistic scale.","title":"EMMO use case for vertical interoperability"},{"location":"demo/vertical/#creating-an-emmo-based-user-case-ontology","text":"The script define_ontology.py uses the Python API for EMMO to generate an application ontology extending EMMO with additional concepts needed to describe the data that is exchanged between scales. The user case ontology can then be visualised with the script plot_ontology.py .","title":"Creating an EMMO-based user case ontology"},{"location":"demo/vertical/#defining-the-needed-material-entities","text":"","title":"Defining the needed material entities"},{"location":"demo/vertical/#assigning-properties-to-material-entities","text":"Note that we here also assign properties to e-bonded_atom , even though e-bonded_atom is defined in EMMO.","title":"Assigning properties to material entities"},{"location":"demo/vertical/#assigning-units-to-properties","text":"We choose here to consistently use SI units for all scales (even though at the atomistic scale units like \u00c5ngstr\u00f6m and electron volt are more commonly used).","title":"Assigning units to properties"},{"location":"demo/vertical/#assigning-types-to-properties","text":"In order to be able to generate metadata and to describe the actual data transferred between scales, we also need to define types.","title":"Assigning types to properties"},{"location":"demo/vertical/#the-new-application-ontology","text":"The final plot shows the user case ontology in context of EMMO.","title":"The new application-ontology"},{"location":"examples/emmodoc/","text":"Generate documentation for EMMO \u00b6 This directory contains the needed templates, introductory text and figures for generating the full EMMO documentation using ontodoc . Since the introduction is written in markdown, pandoc is required for both pdf and html generation. For a standalone html documentation including all inferred relations, enter this directory and run: ontodoc --template=emmo.md --format=html emmo-inferred emmo.html Pandoc options may be adjusted with the files pandoc-options.yaml and pandoc-html-options.yaml . Similarly, for generating pdf documentation, enter this directory and run: ontodoc --template=emmo.md emmo-inferred emmo.pdf By default, we have configured pandoc to use xelatex for better unicode support. It is possible to change these settings in pandoc-options.yaml and pandoc-pdf-options.yaml . Content of this directory \u00b6 ontodoc templates with introductory text and document layout \u00b6 emmo.md : Main template for EMMO. It includes the other templates. introduction.md : Introductory text. relations.md : Introduction and sections for Relations chapter. classes.md : Introduction and sections for Classes. figs : Figures used in the introduction. pandoc configuration files \u00b6 emmodoc-meta.yaml : Metadata for EMMO, like title, authers, abstract, etc. pandoc-options.yaml : General pandoc options. pandoc-html-options.yaml : Additional pandoc options for html generation. pandoc-pdf-options.yaml : Additional pandoc options for pdf generation. pandoc-html.css : css file used for html generation. pandoc-template.html : Modified copy of the standard pandoc html template with a small adjustment for the author list. pandoc-template.tex : Modified copy of the standard pandoc latex template with a small adjustment for the author list. Using this example as a starting point for documenting your own ontology \u00b6 For simple html documentation, you can skip all input files and simply run ontodoc as ontodoc --format=simple-html YOUR_ONTO.owl YOUR_ONTO.html It is also possible to include ontodoc templates using the --template option for adding additional information and structure the document. In this case the template may only contain ontodoc pre-processer directives and inline html, but not markdown. In order to produce output in pdf (or any other output format supported by pandoc), you can write your ontodoc template in markdown (with ontodoc pre-processer directives) and follow these steps to get started: Copy all the files starting with pandoc- to a new directory. Create a metadata YAML file for your ontology. You can use emmodoc-meta.yaml as a template. Update pandoc-options.yaml . Especially change: input-files to the name of your new yaml metadata file. logo to the path of your logo (or remove it). titlegraphic to the path of your title figure (or remove it). Optionally add ontodoc template files with additional information about your ontology and document layout. That should be it. Good luck!","title":"Generate documentation for EMMO"},{"location":"examples/emmodoc/#generate-documentation-for-emmo","text":"This directory contains the needed templates, introductory text and figures for generating the full EMMO documentation using ontodoc . Since the introduction is written in markdown, pandoc is required for both pdf and html generation. For a standalone html documentation including all inferred relations, enter this directory and run: ontodoc --template=emmo.md --format=html emmo-inferred emmo.html Pandoc options may be adjusted with the files pandoc-options.yaml and pandoc-html-options.yaml . Similarly, for generating pdf documentation, enter this directory and run: ontodoc --template=emmo.md emmo-inferred emmo.pdf By default, we have configured pandoc to use xelatex for better unicode support. It is possible to change these settings in pandoc-options.yaml and pandoc-pdf-options.yaml .","title":"Generate documentation for EMMO"},{"location":"examples/emmodoc/#content-of-this-directory","text":"","title":"Content of this directory"},{"location":"examples/emmodoc/#ontodoc-templates-with-introductory-text-and-document-layout","text":"emmo.md : Main template for EMMO. It includes the other templates. introduction.md : Introductory text. relations.md : Introduction and sections for Relations chapter. classes.md : Introduction and sections for Classes. figs : Figures used in the introduction.","title":"ontodoc templates with introductory text and document layout"},{"location":"examples/emmodoc/#pandoc-configuration-files","text":"emmodoc-meta.yaml : Metadata for EMMO, like title, authers, abstract, etc. pandoc-options.yaml : General pandoc options. pandoc-html-options.yaml : Additional pandoc options for html generation. pandoc-pdf-options.yaml : Additional pandoc options for pdf generation. pandoc-html.css : css file used for html generation. pandoc-template.html : Modified copy of the standard pandoc html template with a small adjustment for the author list. pandoc-template.tex : Modified copy of the standard pandoc latex template with a small adjustment for the author list.","title":"pandoc configuration files"},{"location":"examples/emmodoc/#using-this-example-as-a-starting-point-for-documenting-your-own-ontology","text":"For simple html documentation, you can skip all input files and simply run ontodoc as ontodoc --format=simple-html YOUR_ONTO.owl YOUR_ONTO.html It is also possible to include ontodoc templates using the --template option for adding additional information and structure the document. In this case the template may only contain ontodoc pre-processer directives and inline html, but not markdown. In order to produce output in pdf (or any other output format supported by pandoc), you can write your ontodoc template in markdown (with ontodoc pre-processer directives) and follow these steps to get started: Copy all the files starting with pandoc- to a new directory. Create a metadata YAML file for your ontology. You can use emmodoc-meta.yaml as a template. Update pandoc-options.yaml . Especially change: input-files to the name of your new yaml metadata file. logo to the path of your logo (or remove it). titlegraphic to the path of your title figure (or remove it). Optionally add ontodoc template files with additional information about your ontology and document layout. That should be it. Good luck!","title":"Using this example as a starting point for documenting your own ontology"},{"location":"examples/emmodoc/classes/","text":"%% %% This file %% This is Markdown file, except of lines starting with %% will %% be stripped off. %% %HEADER \"EMMO Classes\" level=1 emmo is a class representing the collection of all the individuals (signs) that are used in the ontology. Individuals are declared by the EMMO users when they want to apply the EMMO to represent the world. %BRANCHHEAD EMMO The root of all classes used to represent the world. It has two children; collection and item . collection is the class representing the collection of all the individuals (signs) that represents a collection of non-connected real world objects. item Is the class that collects all the individuals that are members of a set (it's the most comprehensive set individual). It is the branch of mereotopology. %% - based on has_part mereological relation that can be axiomatically defined %% - a fusion is the sum of its parts (e.g. a car is made of several %% mechanical parts, an molecule is made of nuclei and electrons) %% - a fusion is of the same entity type as its parts (e.g. a physical %% entity is made of physical entities parts) %% - a fusion can be partitioned in more than one way %BRANCH EMMO %BRANCHDOC Elementary %BRANCHDOC Perspective %BRANCHDOC Holistic %BRANCHDOC Semiotic %BRANCHDOC Sign %BRANCHDOC Interpreter %BRANCHDOC Object %BRANCHDOC Conventional %BRANCHDOC Property %BRANCHDOC Icon %BRANCHDOC Process %BRANCHDOC Perceptual %BRANCHDOC Graphical %BRANCHDOC Geometrical %BRANCHDOC Symbol %BRANCHDOC Mathematical %BRANCHDOC MathematicalSymbol %BRANCHDOC MathematicalModel %BRANCHDOC MathematicalOperator %BRANCHDOC Metrological %BRANCHDOC PhysicalDimension rankdir=RL %BRANCHDOC PhysicalQuantity %BRANCHDOC Number %BRANCHDOC MeasurementUnit %BRANCHDOC UTF8 %BRANCHDOC SIBaseUnit %BRANCHDOC SISpecialUnit rankdir=RL %BRANCHDOC PrefixedUnit %BRANCHDOC MetricPrefix rankdir=RL %BRANCHDOC Quantity %BRANCHDOC BaseQuantity %BRANCHDOC DerivedQuantity rankdir=RL %BRANCHDOC PhysicalConstant %BRANCHDOC Reductionistic %BRANCHDOC Expression %BRANCHDOC Physicalistic %BRANCHDOC ElementaryParticle %BRANCHDOC Subatomic %BRANCHDOC Matter %BRANCHDOC Fluid %BRANCHDOC Mixture %BRANCHDOC StateOfMatter","title":"Classes"},{"location":"examples/emmodoc/emmo/","text":"%% %% This is the main Markdown input file for the EMMO documentation. %% %% Lines starting with a % are pre-processor directives. %% %INCLUDE introduction.md %INCLUDE relations.md %INCLUDE classes.md %HEADER Individuals level=1 %ALL individuals %HEADER Appendix level=1 %HEADER \"The complete taxonomy of EMMO relations\" level=2 %BRANCHFIG EMMORelation caption='The complete taxonomy of EMMO relations.' terminated=0 relations=all edgelabels=0 %HEADER \"The taxonomy of EMMO classes\" level=2 %BRANCHFIG EMMO caption='The almost complete taxonomy of EMMO classes. Only physical quantities and constants are left out.' terminated=0 relations=isA edgelabels=0 leafs=PhysicalDimension,BaseQuantity,DerivedQuantity,ExactConstant,MeasuredConstant,SIBaseUnit,SISpecialUnit,MetricPrefix,UTF8","title":"Emmo"},{"location":"examples/emmodoc/important_concepts/","text":"Important concepts \u00b6 Mereotopological composition \u00b6 Substrate \u00b6 A substrate represents the place (in general sense) in which every real world item exists. It provides the dimensions of existence for real world entities. This follows from the fact that everything that exists is placed somewhere in space and time. Hence, its space and time coordinates can be used to identify it. Substrates are always topologically connected spaces . A topological space, X, is said to be disconnected if it is the union of two disjoint non-empty open sets. Otherwise, X is said to be connected. substrate is the superclass of space , time and their combinations, like spacetime . Following Kant, space and time are a priori forms of intuition, i.e. they are the substrate upon which we place our intuitions, assigning space and time coordinates to them. Hybrid \u00b6 A hybrid is the combination of space and time . It has the subclasses world_line (0D space + 1D time), world_sheet (1D space + 1D time), world_volume (2D space + 1D time) and spacetime (3D space + 1D time). Spacetime \u00b6 EMMO represents real world entities as subclasses of spacetime . A spacetime is valid for all reference systems (as required by the theory of relativity). Matter \u00b6 matter is used to represent a group of elementary in an enclosing spacetime . As illustrated in the figure, a matter is an elementary or a composition of other matter and vacuum . In EMMO matter is always a 4D spacetime. This is a fundamental difference between EMMO and most other ontologies. In order to describe the real world, we must also take into account the vacuum between the elementaries that composes higher granularity level entity (e.g. an atom). In EMMO vacuum is defined as a spacetime that has no elementary parts. Existent \u00b6 An existent is defined as a matter that unfolds in time as a succession of states. It is used to represent the whole life of a complex but structured state-changing matter entity, like e.g. an atom that becomes ionised and then recombines with an electron. On the contrary, a matter and not existent entity is something \"amorphous\", randomly collected and not classifiable by common terms or definitions. That is a heterogeneous heap of elementary , appearing and disappearing in time. State \u00b6 A state is matter in a particular configurational state. It is defined as having spatial direct parts that persist (do not change) throughout the lifetime of the state . Hence, a state is like a snapshot of a physical in a finite time interval. The use of spatial direct parthood in the definition of state means that a state cannot overlap in space with another state . An important feature of states, that follows from the fact that they are spacetime , is that they constitute a finite time interval. Elementary \u00b6 The basic assumption of decomposition in EMMO, is that the most basic manifestation of matter is represented by a subclass of spacetime called elementary . The elementary class defines the \"atomic\" (undividable) level in EMMO. A generic matter can always be decomposed in proper parts down to the elementary level using proper parthood. An elementary can still be decomposed in temporal parts, that are themselves elementary . Example of elementaries are electrons, photons and quarks. Granularity - direct parthood \u00b6 Granularity is a central concept of EMMO, which allows the user to percieve the world at different levels of detail (granularity) that follow physics and materials science perspectives. Every material in EMMO is placed on a granularity level and the ontology gives information about the direct upper and direct lower level classes. This is done with the non-transitive is_direct_part_of relation. Granularity is a defined class and is useful sine a reasoner automatically can put the individuals defined by the user under a generic class that clearly expresses the types of its compositional parts. Mathematical entities \u00b6 The class mathematical_entity represents fundamental elements of mathematical expressions, like numbers, variables, unknowns and equations. Mathematical entities are pure mathematical and have no physical unit. Natural law \u00b6 A natural_law is an abstraction for a series of experiments that tries to define a common cause and effect of the time evolution of a set of interacting participants. It is (by definition) a pre-mathematical entity. The natural_law class is defined as is_abstraction_for some experiment It can be represented e.g. as a thought in the mind of the experimentalist, a sketch and textual description in a book of science. physical_law and material_law are, according to the RoMM and CWA , the laws behind physical equations and material relations, respectively. Properties \u00b6 Properties are abstracts that are related to a specific material entity with the relation has_property , but that depend on a specific observation process , participated by a specific observer , who catch the physical entity behaviour that is abstracted as a property. Properties enable us to connect a measured property to the measurement process and the measurement instrument.","title":"Important concepts"},{"location":"examples/emmodoc/important_concepts/#important-concepts","text":"","title":"Important concepts"},{"location":"examples/emmodoc/important_concepts/#mereotopological-composition","text":"","title":"Mereotopological composition"},{"location":"examples/emmodoc/important_concepts/#substrate","text":"A substrate represents the place (in general sense) in which every real world item exists. It provides the dimensions of existence for real world entities. This follows from the fact that everything that exists is placed somewhere in space and time. Hence, its space and time coordinates can be used to identify it. Substrates are always topologically connected spaces . A topological space, X, is said to be disconnected if it is the union of two disjoint non-empty open sets. Otherwise, X is said to be connected. substrate is the superclass of space , time and their combinations, like spacetime . Following Kant, space and time are a priori forms of intuition, i.e. they are the substrate upon which we place our intuitions, assigning space and time coordinates to them.","title":"Substrate"},{"location":"examples/emmodoc/important_concepts/#hybrid","text":"A hybrid is the combination of space and time . It has the subclasses world_line (0D space + 1D time), world_sheet (1D space + 1D time), world_volume (2D space + 1D time) and spacetime (3D space + 1D time).","title":"Hybrid"},{"location":"examples/emmodoc/important_concepts/#spacetime","text":"EMMO represents real world entities as subclasses of spacetime . A spacetime is valid for all reference systems (as required by the theory of relativity).","title":"Spacetime"},{"location":"examples/emmodoc/important_concepts/#matter","text":"matter is used to represent a group of elementary in an enclosing spacetime . As illustrated in the figure, a matter is an elementary or a composition of other matter and vacuum . In EMMO matter is always a 4D spacetime. This is a fundamental difference between EMMO and most other ontologies. In order to describe the real world, we must also take into account the vacuum between the elementaries that composes higher granularity level entity (e.g. an atom). In EMMO vacuum is defined as a spacetime that has no elementary parts.","title":"Matter"},{"location":"examples/emmodoc/important_concepts/#existent","text":"An existent is defined as a matter that unfolds in time as a succession of states. It is used to represent the whole life of a complex but structured state-changing matter entity, like e.g. an atom that becomes ionised and then recombines with an electron. On the contrary, a matter and not existent entity is something \"amorphous\", randomly collected and not classifiable by common terms or definitions. That is a heterogeneous heap of elementary , appearing and disappearing in time.","title":"Existent"},{"location":"examples/emmodoc/important_concepts/#state","text":"A state is matter in a particular configurational state. It is defined as having spatial direct parts that persist (do not change) throughout the lifetime of the state . Hence, a state is like a snapshot of a physical in a finite time interval. The use of spatial direct parthood in the definition of state means that a state cannot overlap in space with another state . An important feature of states, that follows from the fact that they are spacetime , is that they constitute a finite time interval.","title":"State"},{"location":"examples/emmodoc/important_concepts/#elementary","text":"The basic assumption of decomposition in EMMO, is that the most basic manifestation of matter is represented by a subclass of spacetime called elementary . The elementary class defines the \"atomic\" (undividable) level in EMMO. A generic matter can always be decomposed in proper parts down to the elementary level using proper parthood. An elementary can still be decomposed in temporal parts, that are themselves elementary . Example of elementaries are electrons, photons and quarks.","title":"Elementary"},{"location":"examples/emmodoc/important_concepts/#granularity-direct-parthood","text":"Granularity is a central concept of EMMO, which allows the user to percieve the world at different levels of detail (granularity) that follow physics and materials science perspectives. Every material in EMMO is placed on a granularity level and the ontology gives information about the direct upper and direct lower level classes. This is done with the non-transitive is_direct_part_of relation. Granularity is a defined class and is useful sine a reasoner automatically can put the individuals defined by the user under a generic class that clearly expresses the types of its compositional parts.","title":"Granularity - direct parthood"},{"location":"examples/emmodoc/important_concepts/#mathematical-entities","text":"The class mathematical_entity represents fundamental elements of mathematical expressions, like numbers, variables, unknowns and equations. Mathematical entities are pure mathematical and have no physical unit.","title":"Mathematical entities"},{"location":"examples/emmodoc/important_concepts/#natural-law","text":"A natural_law is an abstraction for a series of experiments that tries to define a common cause and effect of the time evolution of a set of interacting participants. It is (by definition) a pre-mathematical entity. The natural_law class is defined as is_abstraction_for some experiment It can be represented e.g. as a thought in the mind of the experimentalist, a sketch and textual description in a book of science. physical_law and material_law are, according to the RoMM and CWA , the laws behind physical equations and material relations, respectively.","title":"Natural law"},{"location":"examples/emmodoc/important_concepts/#properties","text":"Properties are abstracts that are related to a specific material entity with the relation has_property , but that depend on a specific observation process , participated by a specific observer , who catch the physical entity behaviour that is abstracted as a property. Properties enable us to connect a measured property to the measurement process and the measurement instrument.","title":"Properties"},{"location":"examples/emmodoc/introduction/","text":"Introduction \u00b6 EMMO is a multidisciplinary effort to develop a standard representational framework (the ontology) based on current materials modelling knowledge, including physical sciences, analytical philosophy and information and communication technologies. This multidisciplinarity is illustrated by the figure on the title page. It provides the connection between the physical world, materials characterisation world and materials modelling world. EMMO is based on and is consistent with the Review of Materials Modelling , CEN Workshop Agreement and MODA template . However, while these efforts are written for humans, EMMO is defined using the Web Ontology Language (OWL) , which is machine readable and allows for machine reasoning. In terms of semantic representation, EMMO brings everything to a much higher level than these foundations. As illustrated in the figure below, EMMO covers all aspects of materials modelling and characterisation, including: the material itself, which must be described in a rigorous way; the observation process involving an observer that percieves the real world (characterisation); the properties that are measured or modelled; the physics laws that describe the material behaviour; the physical models that approximate the physics laws; the solver including the numerical discretisation method that leads to a solvable mathematical representation under certain simplifying assumptions; the numerical solver that performs the calculations; and the post processing of experimental or simulated data. EMMO is released under the Creative Commons license and is available at emmo.info/ . The OWL2-DL sources are available in RDF/XML format. What is an ontology \u00b6 In short, an ontology is a specification of a conceptualization. The word ontology has a long history in philosophy, in which it refers to the subject of existence. The so-called ontological argument for the existence of God was proposed by Anselm of Canterbury in 1078. He defined God as \"that than which nothing greater can be thought\" , and argued that \"if the greatest possible being exists in the mind, it must also exist in reality. If it only exists in the mind, then an even greater being must be possible -- one which exists both in the mind and in reality\" . Even though this example has little to do with todays use of ontologies in e.g. computer science, it illustrates the basic idea; the ontology defines some basic premises (concepts and relations between them) from which it is possible reason to gain new knowledge. For a more elaborated and modern definition of the ontology we refer the reader to the one provided by Tom Gruber (2009) . Another useful introduction to ontologies is the paper Ontology Development 101: A Guide to Creating Your First Ontology by Noy and McGuinness (2001), which is based on the Protege sortware, with which EMMO has been developed. A taxonomy is a hierarchical representation of classes and subclasses connected via is_a relations. Hence, it is a subset of the ontology excluding all but the is_a relations. The main use of taxonomies is for the organisation of classifications. The figure shows a simple example of a taxonomy illustrating a categorisation of four classes into a hierarchy of more higher of levels of generality. In EMMO, the taxonomy is a rooted directed acyclic graph (DAG). This is important since many classification methods relies on this property, see e.g. Valentini (2014) and Robison et al (2015) . Note, that EMMO is a DAG does not prevent some classes from having more than one parent. A Variable is for instance both a Mathematical and a Symbol . See appendix for the full EMMO taxonomy. Primitive elements in EMMO \u00b6 Individuals \u00b6 Individuals are the basic, \"ground level\" components of EMMO. They may include concrete objects such as cars, flowers, stars, persons and molecules, as well as abstract individuals such as a measured height, a specific equation and software programs. Individuals possess attributes in form of axioms that are defined by the user (interpreter) upon declaration. Classes \u00b6 Classes represent concepts. They are the building blocks that we use to create an ontology as a representation of knowledge. We distinguish between defined and non-defined classes. Defined classes are defined by the requirements for being a member of the class. In the graphical representations of EMMO, defined classes are orange. For instance, in the graph of the top-level entity branch below, The root EMMO and a defined class (defined to be the disjoint union of Item and Collection ). Non-defined classes are defined as an abstract group of objects, whose members are defined as belonging to the class. They are yellow in the graphical representations. %BRANCHFIG EMMO leafs=Perspective,Elementary caption='Example of the top-level branch of EMMO showing some classes and relationships between them.' width=460 Axioms \u00b6 Axioms are propositions in a logical framework that define the relations between the individuals and classes. They are used to categorise individuals in classes and to define the defined classes. The simplest form of a class axiom is a class description that just states the existence of the class and gives it an unique identifier. In order to provide more knowledge about the class, class axioms typically contain additional components that state necessary and/or sufficient characteristics of the class. OWL contains three language constructs for combining class descriptions into class axioms: Subclass ( rdfs:subClassOf ) allows one to say that the class extension of a class description is a subset of the class extension of another class description. Equivalence ( owl:equivalentClass ) allows one to say that a class description has exactly the same class extension (i.e. the individuals associated with the class) as another class description. Distjointness ( owl:disjointWith ) allows one to say that the class extension of a class description has no members in common with the class extension of another class description. See the section about Description logic for more information about these language constructs. Axioms are also used to define relations between relations. These are further detailed in the chapter on Relations . Theoretical foundations \u00b6 EMMO build upon several theoretical frameworks. Semiotics \u00b6 Semiotics is the study of meaning-making. It is the dicipline of formulating something that possibly can exist in a defined space and time in the real world. %%It is introdused in EMMO via the %% semion class and used as a way to reduce the complexity of a %%physical to a simple sign (symbol). A Sign is a physical %%entity that can represent another object. %% %%### Set theory %%Set theory is the theory of membership. This is introduced via %%the set class, representing the collection of all individuals %%(signs) that represent a collection of items. Sets are defined %%via the hasMember relations. Mereotopology \u00b6 Mereotopology is the combination of mereology (science of parthood) and topology (mathematical study of the geometrical properties and conservation through deformations). It is introdused via the Item class and based on the mereotopological relations. Items in EMMO are always topologically connected in space and time. EMMO makes a strong distinction between membership and parthood relations. In contrast to collections, items can only have parts that are themselves items. For further information, see Casati and Varzi \"Parts and Places\" (1999) . Physics \u00b6 EMMO is strongly based on physics, with the aim of being able to describe all aspects and all domains of physics, from quantum mechanics to continuum, engeneering, chemistry, etc. EMMO is compatible with both the De Broglie - Bohm and the Copenhagen interpretation of quantum mecanics (see Physical for more comments). EMMO defines a physics-based parthood hierachy under Physical by introducing the following concepts (illustrated in the figure below): Elementary is the fundamental, non-divisible constituent of entities. In EMMO, elementaries are based on the standard model of physics. State is a Physical whose parts does not change during its life time (at the chosen level of granularity). This is consistent with a state within e.g. thermodynamics. Existent is a succession of states. Metrology \u00b6 Metrology is the science of measurements. It introduces units and links them to properties. The description of metrology in EMMO is based on the standards of International System of Quantities (ISQ) and International System of Units (SI) . Description logic \u00b6 Description logic (DL) is a formal knowledge representation language in which the axioms are expressed. It is less expressive than first-order logic (FOL) , but commonly used for providing the logical formalism for ontologies and semantic web. EMMO is expressed in the Web Ontology Language (OWL) , which in turn is based on DL. This brings along features like reasoning. Since it is essential to have a basic notion of OWL and DL, we include here a very brief overview. For a proper introduction to OWL and DL, we refer the reader to sources like Grau et.al. (2008) , OWL2 Primer and OWL Reference . OWL distinguishes between six types of class descriptions: a class identifier (a IRI reference); an exhaustive enumeration of individuals that together form the instances of a class ( owl:oneOf ); a property restriction ( owl:someValuesFrom , owl:allValuesFrom , owl:hasValue , owl:cardinality , owl:minCardinality , owl:maxCardinality ); the intersection of two or more class descriptions ( owl:intersectionOf ); the union of two or more class descriptions ( owl:unionOf ); and the complement of a class description ( owl:complementOf ). Except for the first, all of these refer to defined classes . The table below shows the notation in OWL, DL and the Manchester OWL syntax , all commonly used for the definitions. The Manchester syntax is used by Protege and is designed to not use DL symbols and to be easy and quick to read and write. Several other syntaxes exist for DL. An interesting example is the pure Python syntax proposed by Lamy (2017) , which is used in the open source Owlready2 Python package. The Python API for EMMO is also based on Owlready2. DL Manchester Python + Owlready2 Read Meaning --------------- ----------------- ------------------- ------------------- -------------------- Constants $\\top$ Thing top A special class with every individual as an instance $\\bot$ Nothing bottom The empty class Axioms $A\\doteq B$ A is defined to be Class definition equal to B $A\\sqsubseteq B$ A subclass_of B class A(B): ... all A are B Class inclusion issubclass(A, B) Test for *inclusion* $A\\equiv B$ A equivalent_to B A.equivalent_to.append(B) A is equivalent to B Class equivalence B in A.equivalent_to Test for equivalence $a:A$ a is_a A a = A() a is a A Class assertion ( instantiation ) isinstance(a, A) Test for instance of $(a,b):R$ a object property a.R.append(b) a is R-related to b Property assertion assertion b $(a,n):R$ a data property a.R.append(n) a is R-related to n Data assertion assertion n Constructions $A\\sqcap B$ A and B A & B A and B Class intersection ( conjunction ) $A\\sqcup B$ A or B A | B A or B Class union ( disjunction ) $\\lnot A$ not A Not(A) not A Class complement ( negation ) ${a, b, ...}$ {a, b, ...} OneOf([a, b, ...]) one of a, b, ... Class enumeration $S\\equiv R^-$ S inverse_of R Inverse(R) S is inverse of R Property inverse S.inverse == R Test for *inverse* $\\forall R.A$ R only A R.only(A) all A with R Universal restriction $\\exists R.A$ R some A R.some(A) some A with R Existential restriction $=n R.A$ R exactly n A R.exactly(n, A) Cardinality restriction $\\leq n R.A$ R min n A R.min(n, A) Minimum cardinality restriction $\\geq n R.A$ R max n A R.max(n, A) Minimum cardinality restriction $\\exists R{a}$ R value a R.value(a) Value restriction Decompositions $A\\sqcup B A disjoint with B AllDisjoint([A, B]) A disjoint with B Disjoint \\sqsubseteq\\bot$ B in A.disjoints() Test for disjointness $\\exists R.\\top R domain A R.domain = [A] Classes that the restriction applies to \\sqsubseteq A$ $\\top\\sqsubseteq R range B R.range = [B] All classes that can be the value of the restriction \\forall R.B$ Table: Notation for DL and Protege. A and B are classes, R is an active relation, S is an passive relation, a and b are individuals and n is a literal. Inspired by the Great table of Description Logics . Examples \u00b6 Here are some examples of different class descriptions using both the DL and Manchester notation. Equivalence ( owl:equivalentTo ) \u00b6 Equivalence ($\\equiv$) defines necessary and sufficient conditions. Parent is equivalent to mother or father DL: parent $\\equiv$ mother $\\lor$ father Manchester: parent equivalent_to mother or father Inclusion ( rdf:subclassOf ) \u00b6 Inclusion ($\\sqsubseteq$) defines necessary conditions. An employee is a person. DL: employee $\\sqsubseteq$ person Manchester: employee is_a person Enumeration ( owl:oneOf ) \u00b6 The color of a wine is either white, rose or red: DL: wine_color $\\equiv$ { white , rose , red } Manchester: wine_color equivalent_to {white, rose, red} Existential restriction ( owl:someValuesFrom ) \u00b6 A mother is a woman that has a child (some person): DL: mother $\\equiv$ woman $\\sqcap$ $\\exists$ has_child . person Manchester: mother equivalent_to woman and has_child some person Universal restriction ( owl:allValuesFrom ) \u00b6 All parents that only have daughters: DL: parents_with_only_daughters $\\equiv$ person $\\sqcap$ $\\forall$ has_child . woman Manchester: parents_with_only_daughters equivalent_to person and has_child only woman Value restriction ( owl:hasValue ) \u00b6 The owl:hasValue restriction allows to define classes based on the existence of particular property values. There must be at least one matching property value. All children of Mary: DL: Marys_children $\\equiv$ person $\\sqcap$ $\\exists$ has_parent .{ Mary } Manchester: Marys_children equivalent_to person and has_parent value Mary Property cardinality ( owl:cardinality ) \u00b6 The owl:cardinality restrictions ($\\geq$, $\\leq$ or $\\equiv$) allow to define classes based on the maximum (owl:maxCardinality), minimum (owl:minCardinality) or exact (owl:cardinality) number of occurences. A person with one parent: DL: half_orphant $\\equiv$ person and =1 has_parent . person Manchester: half_orphant equivalent_to person and has_parent exactly 1 person Intersection ( owl:intersectionOf ) \u00b6 Individuals of the intersection ($\\sqcap$) of two classes, are simultaneously instances of both classes. A man is a person that is male: DL: man $\\equiv$ person $\\sqcap$ male Manchester: man equivalent_to person and male Union ( owl:unionOf ) \u00b6 Individuals of the union ($\\sqcup$) of two classes, are either instances of one or both classes. A person is a man or woman: DL: person $\\equiv$ man $\\sqcup$ woman Manchester: person equivalent_to man or woman Complement ( owl:complementOf ) \u00b6 Individuals of the complement ($\\lnot$) of a class, are all individuals that are not member of the class. Not a man: DL: female $\\equiv$ $\\lnot$ male Manchester: female equivalent_to not male The structure of EMMO \u00b6 The EMMO ontology is structured in shells, expressed by specific ontology fragments, that extends from fundamental concepts to the application domains, following the dependency flow. Top Level \u00b6 The EMMO top level is the group of fundamental axioms that constitute the philosophical foundation of the EMMO. Adopting a physicalistic/nominalistic perspective, the EMMO defines real world objects as 4D objects that are always extended in space and time (i.e. real world objects cannot be spaceless nor timeless). For this reason abstract objects, i.e. objects that does not extend in space and time, are forbidden in the EMMO. EMMO is strongly based on the analytical philosophy dicipline semiotic. The role of abstract objects are in EMMO fulfilled by semiotic objects, i.e. real world objects (e.g. symbol or sign) that stand for other real world objects that are to be interpreted by an agent. These symbols appear in actions (semiotic processes) meant to communicate meaning by establishing relationships between symbols (signs). Another important building block of from analytical philosophy is atomistic mereology applied to 4D objects. The EMMO calls it 'quantum mereology', since the there is a epistemological limit to how fine we can resolve space and time due to the uncertanity principles. The mereotopology module introduces the fundamental mereotopological concepts and their relations with the real world objects that they represent. The EMMO uses mereotopology as the ground for all the subsequent ontology modules. The concept of topological connection is used to define the first distinction between ontology entities namely the Item and Collection classes. Items are causally self-connected objects, while collections are causally disconnected. Quantum mereology is represented by the Quantum class. This module introduces also the fundamental mereotopological relations used to distinguish between space and time dimensions. The physical module, defines the Physical objects and the concept of Void that plays a fundamental role in the description of multiscale objects and quantum systems. It also define the Elementary class, that restricts mereological atomism in space. In EMMO, the only univocally defined real world object is the Item individual called Universe that stands for the universe. Every other real world object is a composition of elementaries up to the most comprehensive object; the Universe . Intermediate objects are not univocally defined, but their definition is provided according to some specific philosophical perspectives. This is an expression of reductionism (i.e. objects are made of sub-objects) and epistemological pluralism (i.e. objects are always defined according to the perspective of an interpreter, or a class of interpreters). The Perspective class collects the different ways to represent the objects that populate the conceptual region between the elementary and universe levels. Middle Level \u00b6 The middle level ontologies act as roots for extending the EMMO towards specific application domains. The Reductionistic perspective class uses the fundamental non-transitive parthood relation, called direct parthood, to provide a powerful granularity description of multiscale real world objects. The EMMO can in principle represents the Universe with direct parthood relations as a direct rooted tree up to its elementary constituents. The Phenomenic perspective class introduces the concept of real world objects that express of a recognisable pattern in space or time that impress the user. Under this class the EMMO categorises e.g. formal languages, pictures, geometry, mathematics and sounds. Phenomenic objects can be used in a semiotic process as signs. The Physicalistic perspective class introduces the concept of real world objects that have a meaning for the under applied physics perspective. The Holistic perspective class introduces the concept of real world objects that unfold in time in a way that has a meaning for the EMMO user, through the definition of the classes Process and Participant . The semiotics module introduces the concepts of semiotics and the Semiosis process that has a Sign , an Object and an Interpreter as participants. This forms the basis in EMMO to represent e.g. models, formal languages, theories, information and properties. EMMO relations \u00b6 All EMMO relations are subrelations of the relations found in the two roots: mereotopological and semiotical . The relation hierarchy extends more vertically (i.e. more subrelations) than horizontally (i.e. less sibling relations), facilitating the categorisation and inferencing of individuals. See also the chapter EMMO Relations . Imposing all relations to fall under mereotopology or semiotics is how the EMMO force the developers to respect its perspectives. Two entities are related only by contact or parthood (mereotopology) or by standing one for another (semiosis): no other types of relation are possible within the EMMO. A unique feature in EMMO, is the introduction of direct parthood . As illustrated in the figure below, it is a mereological relation that lacks transitivity. This makes it possible to entities made of parts at different levels of granularity and to go between granularity levels in a well-defined manner. This is paramount for cross scale interoperability. Every material in EMMO is placed on a granularity level and the ontology gives information about the direct upper and direct lower level classes using the non-transitive direct parthood relations. Annotations \u00b6 All entities and relations in EMMO have some attributes, called annotations . In some cases, only the required International Resource Identifier (IRI) and relations are provided. However, descriptive annotations, like elucidation and comment , are planned to be added for all classes and relations. Possible annotations are: Elucidation is a human readable explanation and clearification of the documented class or relation. Example clearifies the elucidation through an example. A class may have several examples, each addressing different aspects. Comment is a clearifying note complementing the definition and elucidation. A class may have several comments, each clearifying different aspects. IRI stands for international resource identifier . It is an identifier that uniquely identifies the class or relation. IRIs are similar to URIs, but are not restricted to the ASCII character set. In EMMO, the IRIs are now valid URLs pointing to the stable version of EMMO. Relations is a list of relations applying to the current class or relation. The relations for relations are special and will be elaborated on in the introduction to chapter [Relations]. Some of the listed relations are defined in the OWL sources, while other are inferred by the reasoner. The relations are expressed using the Manchester OWL syntax introduced in section Description logic . %%### Graphs %%The generated graphs borrow some syntax from the Unified Modelling %%Language (UML) , which is a general purpose language for software %%design and modelling. The table below shows the style used for the %%different types of relations and the concept they correspond to in %%UML. %% %%Relation UML arrow UML concept %%------------- ----------- ----------- %%is-a ![img][isa] inheritance %%disjoint_with ![img][djw] association %%equivalent_to ![img][eqt] association %%encloses ![img][rel] aggregation %%has_abstract_part ![img][rel] aggregation %%has_abstraction ![img][rel] aggregation %%has_representation ![img][rel] aggregation %%has_member ![img][rel] aggregation %%has_property ![img][rel] aggregation %% %%Table: Notation for arrow styles used in the graphs. Only active %%relations are listed. Corresponding passive relations use the same %%style. %% %%[isa]: figs/arrow-is_a.png \"inheritance\" %%[djw]: figs/arrow-disjoint_with.png \"association\" %%[eqt]: figs/arrow-equivalent_to.png \"association\" %%[rel]: figs/arrow-relation.png \"aggregation\" %%All relationships have a direction. In the graphical visualisations, %%the relationships are represented with an arrow pointing from the %%subject to the object. In order to reduce clutter and limit the size %%of the graphs, the relations are abbreviated according to the %%following table: %% %%Relation Abbreviation %%-------- ------------ %%has_part only hp-o %%is_part_of only ipo-o %%has_member some hm-s %%is_member_of some imo-s %%has_abstraction some ha-s %%is_abstraction_of some iao-s %%has_abstract_part only pap-o %%is_abstract_part_of only iapo-o %%has_space_slice some hss-s %%is_space_slice_of some isso-s %%has_time_slice some hts-s %%is_time_slice_of some itso-s %%has_projection some hp-s %%is_projection_of some ipo-s %%has_proper_part some hpp-s %%is_proper_part_of some ippo-s %%has_proper_part_of some hppo-s %%has_spatial_direct_part min hsdp-m %%has_spatial_direct_part some hsdp-s %%has_spatial_direct_part exactly hsdp-e %% %%Table: Abbriviations of relations used in the graphical representation %%of the different subbranches. %% %% %%UML represents classes as a box with three compartments; names, attributes %%and operators. However, since the classes in EMMO have no operators and %%since it gives little meaning to include the OWL annotations as attributes, %%we simply represent the classes as boxes by a name. %% %%As already mentioned, defined classes are colored orange, while %%undefined classes are yellow. %% %% %%","title":"Introduction"},{"location":"examples/emmodoc/introduction/#introduction","text":"EMMO is a multidisciplinary effort to develop a standard representational framework (the ontology) based on current materials modelling knowledge, including physical sciences, analytical philosophy and information and communication technologies. This multidisciplinarity is illustrated by the figure on the title page. It provides the connection between the physical world, materials characterisation world and materials modelling world. EMMO is based on and is consistent with the Review of Materials Modelling , CEN Workshop Agreement and MODA template . However, while these efforts are written for humans, EMMO is defined using the Web Ontology Language (OWL) , which is machine readable and allows for machine reasoning. In terms of semantic representation, EMMO brings everything to a much higher level than these foundations. As illustrated in the figure below, EMMO covers all aspects of materials modelling and characterisation, including: the material itself, which must be described in a rigorous way; the observation process involving an observer that percieves the real world (characterisation); the properties that are measured or modelled; the physics laws that describe the material behaviour; the physical models that approximate the physics laws; the solver including the numerical discretisation method that leads to a solvable mathematical representation under certain simplifying assumptions; the numerical solver that performs the calculations; and the post processing of experimental or simulated data. EMMO is released under the Creative Commons license and is available at emmo.info/ . The OWL2-DL sources are available in RDF/XML format.","title":"Introduction"},{"location":"examples/emmodoc/introduction/#what-is-an-ontology","text":"In short, an ontology is a specification of a conceptualization. The word ontology has a long history in philosophy, in which it refers to the subject of existence. The so-called ontological argument for the existence of God was proposed by Anselm of Canterbury in 1078. He defined God as \"that than which nothing greater can be thought\" , and argued that \"if the greatest possible being exists in the mind, it must also exist in reality. If it only exists in the mind, then an even greater being must be possible -- one which exists both in the mind and in reality\" . Even though this example has little to do with todays use of ontologies in e.g. computer science, it illustrates the basic idea; the ontology defines some basic premises (concepts and relations between them) from which it is possible reason to gain new knowledge. For a more elaborated and modern definition of the ontology we refer the reader to the one provided by Tom Gruber (2009) . Another useful introduction to ontologies is the paper Ontology Development 101: A Guide to Creating Your First Ontology by Noy and McGuinness (2001), which is based on the Protege sortware, with which EMMO has been developed. A taxonomy is a hierarchical representation of classes and subclasses connected via is_a relations. Hence, it is a subset of the ontology excluding all but the is_a relations. The main use of taxonomies is for the organisation of classifications. The figure shows a simple example of a taxonomy illustrating a categorisation of four classes into a hierarchy of more higher of levels of generality. In EMMO, the taxonomy is a rooted directed acyclic graph (DAG). This is important since many classification methods relies on this property, see e.g. Valentini (2014) and Robison et al (2015) . Note, that EMMO is a DAG does not prevent some classes from having more than one parent. A Variable is for instance both a Mathematical and a Symbol . See appendix for the full EMMO taxonomy.","title":"What is an ontology"},{"location":"examples/emmodoc/introduction/#primitive-elements-in-emmo","text":"","title":"Primitive elements in EMMO"},{"location":"examples/emmodoc/introduction/#individuals","text":"Individuals are the basic, \"ground level\" components of EMMO. They may include concrete objects such as cars, flowers, stars, persons and molecules, as well as abstract individuals such as a measured height, a specific equation and software programs. Individuals possess attributes in form of axioms that are defined by the user (interpreter) upon declaration.","title":"Individuals"},{"location":"examples/emmodoc/introduction/#classes","text":"Classes represent concepts. They are the building blocks that we use to create an ontology as a representation of knowledge. We distinguish between defined and non-defined classes. Defined classes are defined by the requirements for being a member of the class. In the graphical representations of EMMO, defined classes are orange. For instance, in the graph of the top-level entity branch below, The root EMMO and a defined class (defined to be the disjoint union of Item and Collection ). Non-defined classes are defined as an abstract group of objects, whose members are defined as belonging to the class. They are yellow in the graphical representations. %BRANCHFIG EMMO leafs=Perspective,Elementary caption='Example of the top-level branch of EMMO showing some classes and relationships between them.' width=460","title":"Classes"},{"location":"examples/emmodoc/introduction/#axioms","text":"Axioms are propositions in a logical framework that define the relations between the individuals and classes. They are used to categorise individuals in classes and to define the defined classes. The simplest form of a class axiom is a class description that just states the existence of the class and gives it an unique identifier. In order to provide more knowledge about the class, class axioms typically contain additional components that state necessary and/or sufficient characteristics of the class. OWL contains three language constructs for combining class descriptions into class axioms: Subclass ( rdfs:subClassOf ) allows one to say that the class extension of a class description is a subset of the class extension of another class description. Equivalence ( owl:equivalentClass ) allows one to say that a class description has exactly the same class extension (i.e. the individuals associated with the class) as another class description. Distjointness ( owl:disjointWith ) allows one to say that the class extension of a class description has no members in common with the class extension of another class description. See the section about Description logic for more information about these language constructs. Axioms are also used to define relations between relations. These are further detailed in the chapter on Relations .","title":"Axioms"},{"location":"examples/emmodoc/introduction/#theoretical-foundations","text":"EMMO build upon several theoretical frameworks.","title":"Theoretical foundations"},{"location":"examples/emmodoc/introduction/#semiotics","text":"Semiotics is the study of meaning-making. It is the dicipline of formulating something that possibly can exist in a defined space and time in the real world. %%It is introdused in EMMO via the %% semion class and used as a way to reduce the complexity of a %%physical to a simple sign (symbol). A Sign is a physical %%entity that can represent another object. %% %%### Set theory %%Set theory is the theory of membership. This is introduced via %%the set class, representing the collection of all individuals %%(signs) that represent a collection of items. Sets are defined %%via the hasMember relations.","title":"Semiotics"},{"location":"examples/emmodoc/introduction/#mereotopology","text":"Mereotopology is the combination of mereology (science of parthood) and topology (mathematical study of the geometrical properties and conservation through deformations). It is introdused via the Item class and based on the mereotopological relations. Items in EMMO are always topologically connected in space and time. EMMO makes a strong distinction between membership and parthood relations. In contrast to collections, items can only have parts that are themselves items. For further information, see Casati and Varzi \"Parts and Places\" (1999) .","title":"Mereotopology"},{"location":"examples/emmodoc/introduction/#physics","text":"EMMO is strongly based on physics, with the aim of being able to describe all aspects and all domains of physics, from quantum mechanics to continuum, engeneering, chemistry, etc. EMMO is compatible with both the De Broglie - Bohm and the Copenhagen interpretation of quantum mecanics (see Physical for more comments). EMMO defines a physics-based parthood hierachy under Physical by introducing the following concepts (illustrated in the figure below): Elementary is the fundamental, non-divisible constituent of entities. In EMMO, elementaries are based on the standard model of physics. State is a Physical whose parts does not change during its life time (at the chosen level of granularity). This is consistent with a state within e.g. thermodynamics. Existent is a succession of states.","title":"Physics"},{"location":"examples/emmodoc/introduction/#metrology","text":"Metrology is the science of measurements. It introduces units and links them to properties. The description of metrology in EMMO is based on the standards of International System of Quantities (ISQ) and International System of Units (SI) .","title":"Metrology"},{"location":"examples/emmodoc/introduction/#description-logic","text":"Description logic (DL) is a formal knowledge representation language in which the axioms are expressed. It is less expressive than first-order logic (FOL) , but commonly used for providing the logical formalism for ontologies and semantic web. EMMO is expressed in the Web Ontology Language (OWL) , which in turn is based on DL. This brings along features like reasoning. Since it is essential to have a basic notion of OWL and DL, we include here a very brief overview. For a proper introduction to OWL and DL, we refer the reader to sources like Grau et.al. (2008) , OWL2 Primer and OWL Reference . OWL distinguishes between six types of class descriptions: a class identifier (a IRI reference); an exhaustive enumeration of individuals that together form the instances of a class ( owl:oneOf ); a property restriction ( owl:someValuesFrom , owl:allValuesFrom , owl:hasValue , owl:cardinality , owl:minCardinality , owl:maxCardinality ); the intersection of two or more class descriptions ( owl:intersectionOf ); the union of two or more class descriptions ( owl:unionOf ); and the complement of a class description ( owl:complementOf ). Except for the first, all of these refer to defined classes . The table below shows the notation in OWL, DL and the Manchester OWL syntax , all commonly used for the definitions. The Manchester syntax is used by Protege and is designed to not use DL symbols and to be easy and quick to read and write. Several other syntaxes exist for DL. An interesting example is the pure Python syntax proposed by Lamy (2017) , which is used in the open source Owlready2 Python package. The Python API for EMMO is also based on Owlready2. DL Manchester Python + Owlready2 Read Meaning --------------- ----------------- ------------------- ------------------- -------------------- Constants $\\top$ Thing top A special class with every individual as an instance $\\bot$ Nothing bottom The empty class Axioms $A\\doteq B$ A is defined to be Class definition equal to B $A\\sqsubseteq B$ A subclass_of B class A(B): ... all A are B Class inclusion issubclass(A, B) Test for *inclusion* $A\\equiv B$ A equivalent_to B A.equivalent_to.append(B) A is equivalent to B Class equivalence B in A.equivalent_to Test for equivalence $a:A$ a is_a A a = A() a is a A Class assertion ( instantiation ) isinstance(a, A) Test for instance of $(a,b):R$ a object property a.R.append(b) a is R-related to b Property assertion assertion b $(a,n):R$ a data property a.R.append(n) a is R-related to n Data assertion assertion n Constructions $A\\sqcap B$ A and B A & B A and B Class intersection ( conjunction ) $A\\sqcup B$ A or B A | B A or B Class union ( disjunction ) $\\lnot A$ not A Not(A) not A Class complement ( negation ) ${a, b, ...}$ {a, b, ...} OneOf([a, b, ...]) one of a, b, ... Class enumeration $S\\equiv R^-$ S inverse_of R Inverse(R) S is inverse of R Property inverse S.inverse == R Test for *inverse* $\\forall R.A$ R only A R.only(A) all A with R Universal restriction $\\exists R.A$ R some A R.some(A) some A with R Existential restriction $=n R.A$ R exactly n A R.exactly(n, A) Cardinality restriction $\\leq n R.A$ R min n A R.min(n, A) Minimum cardinality restriction $\\geq n R.A$ R max n A R.max(n, A) Minimum cardinality restriction $\\exists R{a}$ R value a R.value(a) Value restriction Decompositions $A\\sqcup B A disjoint with B AllDisjoint([A, B]) A disjoint with B Disjoint \\sqsubseteq\\bot$ B in A.disjoints() Test for disjointness $\\exists R.\\top R domain A R.domain = [A] Classes that the restriction applies to \\sqsubseteq A$ $\\top\\sqsubseteq R range B R.range = [B] All classes that can be the value of the restriction \\forall R.B$ Table: Notation for DL and Protege. A and B are classes, R is an active relation, S is an passive relation, a and b are individuals and n is a literal. Inspired by the Great table of Description Logics .","title":"Description logic"},{"location":"examples/emmodoc/introduction/#examples","text":"Here are some examples of different class descriptions using both the DL and Manchester notation.","title":"Examples"},{"location":"examples/emmodoc/introduction/#equivalence-owlequivalentto","text":"Equivalence ($\\equiv$) defines necessary and sufficient conditions. Parent is equivalent to mother or father DL: parent $\\equiv$ mother $\\lor$ father Manchester: parent equivalent_to mother or father","title":"Equivalence (owl:equivalentTo)"},{"location":"examples/emmodoc/introduction/#inclusion-rdfsubclassof","text":"Inclusion ($\\sqsubseteq$) defines necessary conditions. An employee is a person. DL: employee $\\sqsubseteq$ person Manchester: employee is_a person","title":"Inclusion (rdf:subclassOf)"},{"location":"examples/emmodoc/introduction/#enumeration-owloneof","text":"The color of a wine is either white, rose or red: DL: wine_color $\\equiv$ { white , rose , red } Manchester: wine_color equivalent_to {white, rose, red}","title":"Enumeration (owl:oneOf)"},{"location":"examples/emmodoc/introduction/#existential-restriction-owlsomevaluesfrom","text":"A mother is a woman that has a child (some person): DL: mother $\\equiv$ woman $\\sqcap$ $\\exists$ has_child . person Manchester: mother equivalent_to woman and has_child some person","title":"Existential restriction (owl:someValuesFrom)"},{"location":"examples/emmodoc/introduction/#universal-restriction-owlallvaluesfrom","text":"All parents that only have daughters: DL: parents_with_only_daughters $\\equiv$ person $\\sqcap$ $\\forall$ has_child . woman Manchester: parents_with_only_daughters equivalent_to person and has_child only woman","title":"Universal restriction (owl:allValuesFrom)"},{"location":"examples/emmodoc/introduction/#value-restriction-owlhasvalue","text":"The owl:hasValue restriction allows to define classes based on the existence of particular property values. There must be at least one matching property value. All children of Mary: DL: Marys_children $\\equiv$ person $\\sqcap$ $\\exists$ has_parent .{ Mary } Manchester: Marys_children equivalent_to person and has_parent value Mary","title":"Value restriction (owl:hasValue)"},{"location":"examples/emmodoc/introduction/#property-cardinality-owlcardinality","text":"The owl:cardinality restrictions ($\\geq$, $\\leq$ or $\\equiv$) allow to define classes based on the maximum (owl:maxCardinality), minimum (owl:minCardinality) or exact (owl:cardinality) number of occurences. A person with one parent: DL: half_orphant $\\equiv$ person and =1 has_parent . person Manchester: half_orphant equivalent_to person and has_parent exactly 1 person","title":"Property cardinality (owl:cardinality)"},{"location":"examples/emmodoc/introduction/#intersection-owlintersectionof","text":"Individuals of the intersection ($\\sqcap$) of two classes, are simultaneously instances of both classes. A man is a person that is male: DL: man $\\equiv$ person $\\sqcap$ male Manchester: man equivalent_to person and male","title":"Intersection (owl:intersectionOf)"},{"location":"examples/emmodoc/introduction/#union-owlunionof","text":"Individuals of the union ($\\sqcup$) of two classes, are either instances of one or both classes. A person is a man or woman: DL: person $\\equiv$ man $\\sqcup$ woman Manchester: person equivalent_to man or woman","title":"Union (owl:unionOf)"},{"location":"examples/emmodoc/introduction/#complement-owlcomplementof","text":"Individuals of the complement ($\\lnot$) of a class, are all individuals that are not member of the class. Not a man: DL: female $\\equiv$ $\\lnot$ male Manchester: female equivalent_to not male","title":"Complement (owl:complementOf)"},{"location":"examples/emmodoc/introduction/#the-structure-of-emmo","text":"The EMMO ontology is structured in shells, expressed by specific ontology fragments, that extends from fundamental concepts to the application domains, following the dependency flow.","title":"The structure of EMMO"},{"location":"examples/emmodoc/introduction/#top-level","text":"The EMMO top level is the group of fundamental axioms that constitute the philosophical foundation of the EMMO. Adopting a physicalistic/nominalistic perspective, the EMMO defines real world objects as 4D objects that are always extended in space and time (i.e. real world objects cannot be spaceless nor timeless). For this reason abstract objects, i.e. objects that does not extend in space and time, are forbidden in the EMMO. EMMO is strongly based on the analytical philosophy dicipline semiotic. The role of abstract objects are in EMMO fulfilled by semiotic objects, i.e. real world objects (e.g. symbol or sign) that stand for other real world objects that are to be interpreted by an agent. These symbols appear in actions (semiotic processes) meant to communicate meaning by establishing relationships between symbols (signs). Another important building block of from analytical philosophy is atomistic mereology applied to 4D objects. The EMMO calls it 'quantum mereology', since the there is a epistemological limit to how fine we can resolve space and time due to the uncertanity principles. The mereotopology module introduces the fundamental mereotopological concepts and their relations with the real world objects that they represent. The EMMO uses mereotopology as the ground for all the subsequent ontology modules. The concept of topological connection is used to define the first distinction between ontology entities namely the Item and Collection classes. Items are causally self-connected objects, while collections are causally disconnected. Quantum mereology is represented by the Quantum class. This module introduces also the fundamental mereotopological relations used to distinguish between space and time dimensions. The physical module, defines the Physical objects and the concept of Void that plays a fundamental role in the description of multiscale objects and quantum systems. It also define the Elementary class, that restricts mereological atomism in space. In EMMO, the only univocally defined real world object is the Item individual called Universe that stands for the universe. Every other real world object is a composition of elementaries up to the most comprehensive object; the Universe . Intermediate objects are not univocally defined, but their definition is provided according to some specific philosophical perspectives. This is an expression of reductionism (i.e. objects are made of sub-objects) and epistemological pluralism (i.e. objects are always defined according to the perspective of an interpreter, or a class of interpreters). The Perspective class collects the different ways to represent the objects that populate the conceptual region between the elementary and universe levels.","title":"Top Level"},{"location":"examples/emmodoc/introduction/#middle-level","text":"The middle level ontologies act as roots for extending the EMMO towards specific application domains. The Reductionistic perspective class uses the fundamental non-transitive parthood relation, called direct parthood, to provide a powerful granularity description of multiscale real world objects. The EMMO can in principle represents the Universe with direct parthood relations as a direct rooted tree up to its elementary constituents. The Phenomenic perspective class introduces the concept of real world objects that express of a recognisable pattern in space or time that impress the user. Under this class the EMMO categorises e.g. formal languages, pictures, geometry, mathematics and sounds. Phenomenic objects can be used in a semiotic process as signs. The Physicalistic perspective class introduces the concept of real world objects that have a meaning for the under applied physics perspective. The Holistic perspective class introduces the concept of real world objects that unfold in time in a way that has a meaning for the EMMO user, through the definition of the classes Process and Participant . The semiotics module introduces the concepts of semiotics and the Semiosis process that has a Sign , an Object and an Interpreter as participants. This forms the basis in EMMO to represent e.g. models, formal languages, theories, information and properties.","title":"Middle Level"},{"location":"examples/emmodoc/introduction/#emmo-relations","text":"All EMMO relations are subrelations of the relations found in the two roots: mereotopological and semiotical . The relation hierarchy extends more vertically (i.e. more subrelations) than horizontally (i.e. less sibling relations), facilitating the categorisation and inferencing of individuals. See also the chapter EMMO Relations . Imposing all relations to fall under mereotopology or semiotics is how the EMMO force the developers to respect its perspectives. Two entities are related only by contact or parthood (mereotopology) or by standing one for another (semiosis): no other types of relation are possible within the EMMO. A unique feature in EMMO, is the introduction of direct parthood . As illustrated in the figure below, it is a mereological relation that lacks transitivity. This makes it possible to entities made of parts at different levels of granularity and to go between granularity levels in a well-defined manner. This is paramount for cross scale interoperability. Every material in EMMO is placed on a granularity level and the ontology gives information about the direct upper and direct lower level classes using the non-transitive direct parthood relations.","title":"EMMO relations"},{"location":"examples/emmodoc/introduction/#annotations","text":"All entities and relations in EMMO have some attributes, called annotations . In some cases, only the required International Resource Identifier (IRI) and relations are provided. However, descriptive annotations, like elucidation and comment , are planned to be added for all classes and relations. Possible annotations are: Elucidation is a human readable explanation and clearification of the documented class or relation. Example clearifies the elucidation through an example. A class may have several examples, each addressing different aspects. Comment is a clearifying note complementing the definition and elucidation. A class may have several comments, each clearifying different aspects. IRI stands for international resource identifier . It is an identifier that uniquely identifies the class or relation. IRIs are similar to URIs, but are not restricted to the ASCII character set. In EMMO, the IRIs are now valid URLs pointing to the stable version of EMMO. Relations is a list of relations applying to the current class or relation. The relations for relations are special and will be elaborated on in the introduction to chapter [Relations]. Some of the listed relations are defined in the OWL sources, while other are inferred by the reasoner. The relations are expressed using the Manchester OWL syntax introduced in section Description logic . %%### Graphs %%The generated graphs borrow some syntax from the Unified Modelling %%Language (UML) , which is a general purpose language for software %%design and modelling. The table below shows the style used for the %%different types of relations and the concept they correspond to in %%UML. %% %%Relation UML arrow UML concept %%------------- ----------- ----------- %%is-a ![img][isa] inheritance %%disjoint_with ![img][djw] association %%equivalent_to ![img][eqt] association %%encloses ![img][rel] aggregation %%has_abstract_part ![img][rel] aggregation %%has_abstraction ![img][rel] aggregation %%has_representation ![img][rel] aggregation %%has_member ![img][rel] aggregation %%has_property ![img][rel] aggregation %% %%Table: Notation for arrow styles used in the graphs. Only active %%relations are listed. Corresponding passive relations use the same %%style. %% %%[isa]: figs/arrow-is_a.png \"inheritance\" %%[djw]: figs/arrow-disjoint_with.png \"association\" %%[eqt]: figs/arrow-equivalent_to.png \"association\" %%[rel]: figs/arrow-relation.png \"aggregation\" %%All relationships have a direction. In the graphical visualisations, %%the relationships are represented with an arrow pointing from the %%subject to the object. In order to reduce clutter and limit the size %%of the graphs, the relations are abbreviated according to the %%following table: %% %%Relation Abbreviation %%-------- ------------ %%has_part only hp-o %%is_part_of only ipo-o %%has_member some hm-s %%is_member_of some imo-s %%has_abstraction some ha-s %%is_abstraction_of some iao-s %%has_abstract_part only pap-o %%is_abstract_part_of only iapo-o %%has_space_slice some hss-s %%is_space_slice_of some isso-s %%has_time_slice some hts-s %%is_time_slice_of some itso-s %%has_projection some hp-s %%is_projection_of some ipo-s %%has_proper_part some hpp-s %%is_proper_part_of some ippo-s %%has_proper_part_of some hppo-s %%has_spatial_direct_part min hsdp-m %%has_spatial_direct_part some hsdp-s %%has_spatial_direct_part exactly hsdp-e %% %%Table: Abbriviations of relations used in the graphical representation %%of the different subbranches. %% %% %%UML represents classes as a box with three compartments; names, attributes %%and operators. However, since the classes in EMMO have no operators and %%since it gives little meaning to include the OWL annotations as attributes, %%we simply represent the classes as boxes by a name. %% %%As already mentioned, defined classes are colored orange, while %%undefined classes are yellow. %% %% %%","title":"Annotations"},{"location":"examples/emmodoc/relations/","text":"%% %% This file %% This is Markdown file, except of lines starting with %% will %% be stripped off. %% %HEADER \"EMMO Relations\" level=1 In the language of OWL, relations are called properties . However, since relations describe relations between classes and individuals and since properties has an other meaning in EMMO, we only call them relations . Resource Description Framework (RDF) is a W3C standard that is widely used for describing informations on the web and is one of the standards that OWL builds on. RDF expresses information in form of subject-predicate-object triplets. The subject and object are resources (aka items to describe) and the predicate expresses a relationship between the subject and the object. In OWL are the subject and object classes or individuals (or data) while the predicate is a relation. An example of an relationship is the statement dog is_a animal . Here dog is the subject, is_a the predicate and animal the object. %%We distinguish between %% active relations where the subject is acting on the object and %% passive relations where the subject is acted on by the object. OWL distingues between object properties , that link classes or individuals to classes or individuals, and data properties that link individuals to data values. Since EMMO only deals with classes, we will only be discussing object properties. However, in actual simulation or characterisation applications build on EMMO, datatype propertyes will be important. The characteristics of the different properties are described by the following property axioms : rdf:subPropertyOf is used to define that a property is a subproperty of some other property. For instance, in the figure below showing the relation branch, we see that active_relation is a subproperty or relation . The rdf:subPropertyOf axioms forms a taxonomy-like tree for relations. owl:equivalentProperty states that two properties have the same property extension. owl:inverseOf axioms relate active relations to their corresponding passive relations, and vice versa. The root relation relation is its own inverse. owl:FunctionalProperty is a property that can have only one (unique) value y for each instance x, i.e. there cannot be two distinct values y1 and y2 such that the pairs (x,y1) and (x,y2) are both instances of this property. Both object properties and datatype properties can be declared as \"functional\". owl:InverseFunctionalProperty . owl:TransitiveProperty states that if a pair (x,y) is an instance of P, and the pair (y,z) is instance of P, then we can infer that the pair (x,z) is also an instance of P. owl:SymmetricProperty states that if the pair (x,y) is an instance of P, then the pair (y,x) is also an instance of P. A popular example of a symmetric property is the siblingOf relation. rdfs:domain specifies which classes the property applies to. Or said differently, the valid values of the subject in a subject-predicate-object triplet. rdfs:range specifies the property extension, i.e. the valid values of the object in a subject-predicate-object triplet. %HEADER \"Root of EMMO relations\" level=2 %BRANCHFIG EMMORelation caption=\"Top-level of the EMMO relation hierarchy.\" %ENTITY EMMORelation %%BRANCHDOC mereotopological %BRANCHHEAD mereotopological %BRANCH mereotopological %BRANCHDOC connected %BRANCHDOC hasPart %BRANCHDOC semiotical","title":"Relations"},{"location":"examples/jupyter-visualization/","text":"Visualise an ontology using pyctoscape in Jupyter Notebook \u00b6 Installation instructions \u00b6 In a terminal, run: cd /path/to/env/dirs python -m venv cytopy # cytopy is my name, you can choose what ouy want source cytopy/bin/activate cd /dir/to/EMMO-python/ pip install -e . pip install jupyterlab python -m ipykernel install --user --name = cytopy pip install ipywidgets pip install nodejs # Note requires that node.js and npm has already been isntalled! pip install ipycytoscape pydotplus networkx pip install --upgrade setuptools jupyter labextension install @jupyter-widgets/jupyterlab-manager Test the notebook \u00b6 In a terminal, run: jupyter-lab That should start jupyter kernel and open a new tab in your browser. In the side pane, select team40.ipynb and run the notebook.","title":"Visualise an ontology using pyctoscape in Jupyter Notebook"},{"location":"examples/jupyter-visualization/#visualise-an-ontology-using-pyctoscape-in-jupyter-notebook","text":"","title":"Visualise an ontology using pyctoscape in Jupyter Notebook"},{"location":"examples/jupyter-visualization/#installation-instructions","text":"In a terminal, run: cd /path/to/env/dirs python -m venv cytopy # cytopy is my name, you can choose what ouy want source cytopy/bin/activate cd /dir/to/EMMO-python/ pip install -e . pip install jupyterlab python -m ipykernel install --user --name = cytopy pip install ipywidgets pip install nodejs # Note requires that node.js and npm has already been isntalled! pip install ipycytoscape pydotplus networkx pip install --upgrade setuptools jupyter labextension install @jupyter-widgets/jupyterlab-manager","title":"Installation instructions"},{"location":"examples/jupyter-visualization/#test-the-notebook","text":"In a terminal, run: jupyter-lab That should start jupyter kernel and open a new tab in your browser. In the side pane, select team40.ipynb and run the notebook.","title":"Test the notebook"}]}